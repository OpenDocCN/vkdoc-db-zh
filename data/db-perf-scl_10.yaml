- en: 11. Administration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11. 管理操作
- en: '[Admin Operations and Performance](#Sec1)[Looking at Admin Operations Through
    the Lens of Performance](#Sec2)[Backups](#Sec3)[Compaction](#Sec6)[Summary](#Sec9)'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[管理操作和性能](#Sec1)[从性能的角度看待管理操作](#Sec2)[备份](#Sec3)[压缩](#Sec6)[总结](#Sec9)'
- en: A database’s automated admin operations work to keep things tight and tidy behind
    the scenes, but a level of supervision is required. Databases don’t know your
    business and could very naively decide to execute resource-intensive admin operations
    at what’s actually a performance-critical time. This final chapter details how
    common admin operations tend to impact performance. It covers the nature and severity
    of representative impacts and offers some tips on how you might mitigate them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的自动化管理操作旨在在幕后保持事物的紧凑和整洁，但需要一定的监督。数据库不了解你的业务，可能会非常天真地决定在实际上是一个性能关键的时间执行资源密集型的管理操作。最后一章详细介绍了常见的管理操作通常如何影响性能。它涵盖了代表性影响的本性和严重性，并提供了一些关于如何减轻这些影响的建议。
- en: Admin Operations and Performance
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理操作和性能
- en: You might see promises of “zero impact” admin operations, but remember that
    the laws of physics mean that’s not possible. Performing any operation consumes
    resources. And when you’re operating at extreme speed and scale, these operations
    may introduce exacerbated impacts. Given use cases that need to operate at sub-millisecond
    or single-digit millisecond P99 latency, it doesn’t take much for background tasks
    to have a noticeable impact. With a latency-sensitive use case, there can be absolutely
    no system contention during its execution. Even admin operations that will ultimately
    improve your database performance could inevitably hurt performance to some extent
    as they are executing. The better you understand the extent of their impact on
    your specific workload, the more effectively you can strategize to minimize disruption.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到“零影响”管理操作的承诺，但请记住，物理定律意味着这是不可能的。执行任何操作都会消耗资源。当你以极端的速度和规模运行时，这些操作可能会引入加剧的影响。对于需要以亚毫秒或个位数毫秒
    P99 延迟运行的用例，背景任务对性能的影响是显而易见的。对于延迟敏感的用例，在其执行过程中绝对不能有任何系统争用。即使最终会提高数据库性能的管理操作，在执行过程中也可能会在一定程度上损害性能。你越了解它们对你特定工作负载的影响程度，你就能越有效地制定策略来最小化干扰。
- en: Low-level details about what admin operations are required will vary from database
    to database and also change over time; that’s well beyond the scope of this book.
    This chapter focuses on how admin operations could end up undermining the other
    work you’ve done to optimize database performance—and how to avoid that scenario.
    It starts by presenting a quick rule of thumb to prioritize your focus. Then,
    examples of backups and compaction will showcase the potentially significant—and
    also highly variable—impact of admin operations on performance.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 关于需要哪些管理操作的低级细节会因数据库而异，并且会随时间变化；这超出了本书的范围。本章重点介绍管理操作如何最终削弱你为优化数据库性能所做的其他工作——以及如何避免这种情况。它首先提出一个快速规则，以确定你的重点。然后，备份和压缩的例子将展示管理操作对性能的潜在重大影响——这些影响也是高度可变的。
- en: Looking at Admin Operations Through the Lens of Performance
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从性能的角度看待管理操作
- en: Every admin operation, from backups to data migrations to adding and reducing
    capacity, consumes resources that *might* otherwise be spent on your workload.
    The impact of an admin operation will vary across databases and workloads. What’s
    more, an impact that results in lost revenue for one company might be completely
    acceptable for another.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每个管理操作，从备份到数据迁移，再到增加和减少容量，都会消耗本可以用于你工作负载的资源。管理操作的影响将在数据库和工作负载之间有所不同。更重要的是，对一个公司导致收入损失的影响，对另一个公司可能是完全可接受的。
- en: What admin operations should you focus on from the performance perspective?
    As shown in Figure [11-1](#Fig1), work through three key considerations for every
    admin operation that’s being performed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能的角度来看，你应该关注哪些管理操作？如图 [11-1](#Fig1) 所示，针对正在执行的所有管理操作，考虑三个关键因素。
- en: '![](../images/541783_1_En_11_Chapter/541783_1_En_11_Fig1_HTML.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图 11-1](../images/541783_1_En_11_Chapter/541783_1_En_11_Fig1_HTML.jpg)'
- en: A Venn diagram of performance optimization focus. It has three circles that
    denote performance impact, business impact, and controllable. Focus is present
    at the intersection of the three circles.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 性能优化关注点的维恩图。它有三个圆圈，分别表示性能影响、业务影响和可控性。三个圆圈的交汇处是关注的焦点。
- en: Figure 11-1
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-1
- en: A quick rule of thumb for where to focus your admin-related performance optimizations
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关于在哪里集中你的管理相关性能优化的快速规则
- en: What’s the impact on your specific workload at your current or projected scale?
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种影响对你当前或预测的规模的具体工作负载有多大？
- en: How much does that impact matter to your business?
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种影响对你的业务有多重要？
- en: To what extent can you control it?
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能控制到什么程度？
- en: If there is no discernible performance impact for your scenario, then the second
    and third questions don’t really matter. If there’s a significant and business-critical
    impact but you can’t control it, you’re in the tough position of deciding whether
    to accept it or consider moving to an alternative database. If the stars align
    and you *can* control something that’s both impactful and business-critical, that’s
    a great place to focus.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的场景中没有明显的性能影响，那么第二个和第三个问题实际上并不重要。如果存在重大且业务关键的影响，但你无法控制它，你将处于一个艰难的位置，决定是接受它还是考虑迁移到另一个数据库。如果一切顺利，你*可以*控制一些既具有影响力和业务关键性的东西，那将是一个值得关注的绝佳位置。
- en: For example, consider PostgreSQL’s autovacuum function. As of this writing,
    autovacuum is triggered when a specified scale factor/threshold is exceeded. This
    is likely to coincide with heavy activity on the table—which is probably *not*
    when you want background admin tasks to kick in. Starving some tables while repeatedly
    vacuuming others is common, and users trying to compel autovacuum to hit starved
    tables can easily end up pushing the system beyond its limit. What’s the likely
    impact on the business? Probably fairly high for any performance-sensitive use
    case. And to what extent can you control it? Quite well. For example, you can
    tune autovacuum settings at both the global and table level, as well as apply
    strategies like supplementing autovacuum with additional scheduled vacuum jobs.
    The bottom line here is that this is a great performance optimization opportunity.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑PostgreSQL的自动清理功能。截至本文撰写时，自动清理在指定的比例因子/阈值超过时被触发。这很可能会与表上的高活动量相吻合——这很可能不是你希望后台管理任务启动的时候。反复清理一些表而让其他表处于饥饿状态是常见的，试图强迫自动清理击中饥饿表的用户很容易将系统推向极限。这对业务的影响可能有多大？对于任何性能敏感的使用场景，可能相当高。你能控制到什么程度？相当好。例如，你可以在全局和表级别调整自动清理设置，以及应用补充自动清理的额外计划性清理作业等策略。这里的底线是，这是一个很好的性能优化机会。
- en: On the other hand, if you are using a managed DBaaS such as DynamoDB, admin
    operations such as data cleanup might be largely beyond your scope of visibility
    and control. It certainly doesn’t hurt to ask your vendor what they’re willing
    to divulge about what, when, and how admin operations are performed. Even if you
    discover that an admin operation undermines performance in a way that matters
    for you, you might not be able to control it—but at least you can better prepare
    for it and diagnose the performance hit when it occurs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你使用的是如DynamoDB这样的托管数据库即服务（DBaaS），数据清理等管理操作可能很大程度上超出了你的可见性和控制范围。询问你的供应商他们愿意透露关于管理操作是什么、何时以及如何执行的信息当然不会有害。即使你发现管理操作以对你来说有意义的方式损害了性能，你可能无法控制它——但至少你可以更好地为它做准备，并在它发生时诊断性能打击。
- en: 'Among admin operations that could negatively impact performance, some of the
    most common suspects are:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能对性能产生负面影响的管理操作中，一些最常见的嫌疑人是：
- en: '**Node recovery**: This involves existing replicas streaming data in order
    to recover the missing replica. Existing replicas need to read through all the
    data required by the recovered replica and transfer its results via the network.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点恢复**：这涉及到现有的副本通过流式传输数据来恢复丢失的副本。现有的副本需要读取恢复副本所需的所有数据，并通过网络传输其结果。'
- en: '**Ramping up/down capacity**: This often requires an entire cluster or region
    to rebalance data. Ramping up capacity means that data will be streamed from other
    replicas to the new one, while ramping down means that the node being removed
    will stream data out to existing replicas.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加/减少容量**：这通常需要整个集群或区域重新平衡数据。增加容量意味着数据将从其他副本流到新的副本，而减少容量则意味着被移除的节点将数据流出到现有的副本。'
- en: '**Data migration**: Migration often affects latency on the source cluster.
    Since a data migration typically involves no downtime, a balance between speed
    and service stability is needed in order to avoid impacting existing production
    workloads.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据迁移**：迁移通常会影响源集群的延迟。由于数据迁移通常不涉及停机时间，因此需要在速度和服务稳定性之间取得平衡，以避免影响现有的生产工作负载。'
- en: '**Database upgrades**: Although the outcome of an upgrade is likely to improve
    performance, remember that restarting a database instance results in a cold cache.
    This may affect read latencies if the use case in question is cache heavy.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库升级**：尽管升级的结果很可能会提高性能，但请记住，重启数据库实例会导致缓存变冷。这可能会影响读取延迟，如果相关用例对缓存依赖性很高的话。'
- en: '**Logging and tracing**: When you’re trying to understand a specific pattern
    or impact, logging and tracing will be important. Databases provide several verbosity
    levels for many logging components, as well as the ability to enable tracepoints
    toward your query plans. However, enabling both logging and tracing should be
    done with caution because they can potentially be resource-intensive operations.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志和跟踪**：当你试图理解特定的模式或影响时，日志和跟踪将非常重要。数据库为许多日志组件提供了多个详细程度级别，以及启用针对查询计划的跟踪点的功能。然而，启用日志和跟踪应谨慎进行，因为它们可能成为资源密集型操作。'
- en: '**Data synchronization**: Eventually consistent databases don’t guarantee that
    all the data you’re looking for will be immediately available across all natural
    replicas. As a result, a background process is often needed to get data in sync.
    This typically involves each replica reading through its existing data, comparing
    it with its peers, and applying any relevant changes.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据同步**：最终一致性的数据库不保证你寻找的所有数据将立即在所有自然副本中可用。因此，通常需要一个后台进程来同步数据。这通常涉及每个副本读取其现有数据，将其与对等数据比较，并应用任何相关更改。'
- en: Two of the most common operations that impact performance across a variety of
    databases are backups and compaction. Let’s take a deeper look at both.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 影响各种数据库性能的两种最常见操作是备份和压缩。让我们更深入地看看这两个方面。
- en: Backups
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备份
- en: Backups—a common maintenance procedure for any database—can be surprisingly
    resource intensive. For example, consider a backup strategy where data deduplication
    is required. As data in the database frequently gets written or overwritten, backups
    may consume several CPU cycles and disk I/O on reads in order to compare whether
    the data to be backed up has already been saved. Then, as it finds newer data
    that must be retained, it eventually uploads the data (which also involves issuing
    underlying I/O reads) to a safe location. As the process is repeated across multiple
    nodes, its parallelism often ends up hurting latencies, especially for use cases
    that heavily rely on disk I/O to fetch information.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 备份——任何数据库的常见维护程序——可能会非常消耗资源。例如，考虑一种需要数据去重（deduplication）的备份策略。由于数据库中的数据经常被写入或覆盖，备份可能需要消耗多个CPU周期和磁盘I/O来读取，以便比较要备份的数据是否已经被保存。然后，当它找到必须保留的新数据时，它最终会将数据（这也涉及到发出底层的I/O读取）上传到安全位置。随着该过程在多个节点上重复，其并行性通常会导致延迟增加，特别是对于严重依赖磁盘I/O来获取信息的用例。
- en: Impacts
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 影响
- en: 'Factors that influence a backup’s performance impact include:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 影响备份性能的因素包括：
- en: '**Dataset size and replication factor**: The more data you’re backing up, the
    more time it takes to run a backup. Depending on the number of files stored on
    disk, backing up may use a lot of read I/O to scan through all the required database
    blobs.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据集大小和复制因子**：你备份的数据越多，运行备份所需的时间就越长。根据磁盘上存储的文件数量，备份可能需要大量的读取I/O来扫描所有必需的数据库blob。'
- en: '**Scope**: Are you backing up all on-disk data files all the time (full backup)?
    A specific cluster? A system-wide snapshot? An incremental backup? A properly
    defined backup strategy and scope will help you mitigate the impact.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**范围**：你是否一直在备份所有磁盘上的数据文件（完全备份）？一个特定的集群？系统范围内的快照？增量备份？一个定义良好的备份策略和范围将有助于你减轻影响。'
- en: '**Frequency**: Frequent small backups will result in a more constant low-level
    pain; less frequent, but larger backups will cause a sharper pain, but that pain
    will be inflicted less frequently.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频率**：频繁的小型备份会导致更恒定的低级别痛苦；不那么频繁但更大的备份会导致更尖锐的痛苦，但这种痛苦发生的频率较低。'
- en: '**Bandwidth throttling**: The option to compress or spread out the backup pain
    helps teams who want to get backups completed as fast as possible during low peak
    periods (if any exist) or to run them as unobtrusively as possible during steady
    workloads.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带宽限制**：压缩或分散备份压力的选项有助于团队在低峰时段（如果有的话）尽可能快地完成备份，或者在稳定的工作负载期间尽可能不引人注目地运行备份。'
- en: '**Scheduling options**: The ability to control precisely when backups occur
    allows teams with spiky workloads to avoid backups during likely peak periods.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调度选项**：能够精确控制备份发生的时间，使得具有峰值工作负载的团队能够在可能的峰值期间避免备份。'
- en: '**Data compression**: Greater compression will save on storage, but it comes
    at the cost of increased CPU usage as the backup runs.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据压缩**：更高的压缩率可以节省存储空间，但备份运行时CPU使用量的增加是一个代价。'
- en: '**Parallelism**: The more nodes you back up in parallel, the faster it completes—but
    at the risk of starving disk I/O capacity along with your ongoing workload.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行性**：你并行备份的节点越多，完成速度越快——但这也可能耗尽磁盘I/O容量以及你的持续工作负载。'
- en: '**Storage medium**: Reads from local SSDs are noticeably faster than regular
    disks. As a result, if your database relies on slow-access storage devices, it
    is much easier for backups to deplete your available read capacity.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储介质**：从本地SSD读取的速度明显快于常规磁盘。因此，如果你的数据库依赖于慢速访问的存储设备，备份耗尽可用读取容量的可能性就更大。'
- en: Optimization
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化
- en: 'Before you start adjusting any options, consider these two critical questions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始调整任何选项之前，考虑这两个关键问题：
- en: What’s your business’ tolerance for data loss?
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的业务对数据丢失的容忍度是多少？
- en: What type of backup makes the most sense given your workloads?
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据你的工作负载，哪种类型的备份最有意义？
- en: For example, if you’re working on a food delivery app, a large backup that kicks
    off in the middle of the Friday lunch surge could result in lost business. The
    pain could be alleviated by running regular backups during predictable downtimes
    (e.g., very early in the morning), when there are resources to spare.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你正在开发一个食品配送应用，在周五午餐高峰期中启动的大型备份可能会导致业务损失。通过在可预测的停机时间（例如，非常早的早晨）运行定期备份，当有资源可用时，可以减轻这种痛苦。
- en: But other businesses don’t have a predictable downtime. For another example,
    consider an application that provides location tracking services for ambulances—a
    use case where a catastrophic event could bring a dramatic surge at any time without
    warning. In that case, many small and frequent backups might be the best strategy.
    This way, backups are unlikely to significantly impact database performance, no
    matter when the unpredictable demand happens to rise.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但其他业务没有可预测的停机时间。例如，考虑一个为救护车提供位置跟踪服务的应用程序——这是一个可能在没有预警的情况下随时发生灾难性事件并带来急剧增长的用例。在这种情况下，许多小型且频繁的备份可能是最好的策略。这样，无论不可预测的需求何时上升，备份都不太可能对数据库性能产生重大影响。
- en: Work with your team to understand the backup coverage that you need and what
    type of backup pain you’re willing to accept, then adjust your options accordingly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与你的团队合作，了解你需要多少备份覆盖范围以及你愿意接受哪种类型的备份痛苦，然后相应地调整你的选项。
- en: Note
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Repairs are a totally different process, but they have a similar impact. Eventually
    consistent databases need to ensure that replicas (eventually) all have the appropriate
    updates. In Cassandra and Cassandra-like databases, this process is referred to
    as *repairs*. When repair runs, it could cause latency to spike. The key to minimizing
    its performance impact varies according to your workload. If there’s a time when
    your database is predictably idle, run repair then—with high parallelism and intensity.
    If your use case can withstand minor latency spikes, you can try to limit the
    repair’s intensity and parallelism. But, if you can’t afford *any* latency spikes
    (e.g., a real-time bidding use case that must provide sub-millisecond P9999 latencies
    around the clock), your best bet is to limit the operation to run as slowly as
    possible.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 维修是一个完全不同的过程，但它们有相似的影响。最终一致性的数据库需要确保副本（最终）都拥有适当的更新。在Cassandra和类似Cassandra的数据库中，这个过程被称为*修复*。当修复运行时，可能会造成延迟的峰值。最小化其性能影响的关键取决于你的工作负载。如果你的数据库在某个时间点是可预测的空闲状态，那么就运行修复——以高并行度和强度。如果你的用例可以承受轻微的延迟峰值，你可以尝试限制修复的强度和并行度。但是，如果你无法承受*任何*延迟峰值（例如，必须提供全天候亚毫秒级P9999延迟的实时竞标用例），那么最好的办法是将操作限制在尽可能慢的速度下运行。
- en: Compaction
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压缩
- en: As mentioned in Chapter [2](541783_1_En_2_Chapter.xhtml) and covered more in
    Appendix A, LSM-based databases use *compaction*—a process of rewriting tables
    to remove deleted entries and reorganize data to enable faster, more efficient
    reads and writes. Compaction operations are expensive in terms of CPU, memory,
    and disk I/O.^([1](#Fn1))
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 [2](541783_1_En_2_Chapter.xhtml) 章所述，并在附录 A 中有更详细的介绍，基于 LSM 的数据库使用 *压缩*——一个重写表以删除已删除条目并重新组织数据的过程，以实现更快、更高效的读写。从
    CPU、内存和磁盘 I/O 的角度来看，压缩操作成本很高.^([1](#Fn1))
- en: The degree to which you can control compaction varies dramatically from database
    to database. For example, with Bigtable, it’s all done automatically. However,
    databases such as Couchbase, HBase, Cassandra, and ScyllaDB let you choose from
    a variety of compaction strategies, many of which have additional options you
    can use to fine-tune how compaction is performed, as well as other settings that
    influence compaction performance (for example, rate-limiting it).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以控制的压缩程度在不同数据库之间差异很大。例如，在 Bigtable 中，所有操作都是自动完成的。然而，Couchbase、HBase、Cassandra
    和 ScyllaDB 等数据库允许您从各种压缩策略中进行选择，其中许多策略都有额外的选项，您可以使用这些选项来微调压缩的执行方式，以及影响压缩性能的其他设置（例如，速率限制）。
- en: Impacts
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 影响
- en: The performance impact of compaction also varies dramatically from database
    to database. One fundamental factor that influences compaction speed is whether
    the database is performing the major compactions on each shard/CPU concurrently,
    or the compaction is bound to a single thread. As shown in Figure [11-2](#Fig2),
    benchmarks found that there can reflect a nearly 60X difference in the time required
    to run a major compaction of 1TB of data at RF=1 on i3.4xlarge machines.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩对性能的影响在不同数据库之间差异很大。影响压缩速度的一个基本因素是数据库是否在每个分片/CPU上并发执行主要压缩，或者压缩被绑定到单个线程。如图 [11-2](#Fig2)
    所示，基准测试发现，在 i3.4xlarge 机器上，RF=1 时对 1TB 数据进行主要压缩所需的时间可以相差近 60 倍。
- en: '![](../images/541783_1_En_11_Chapter/541783_1_En_11_Fig2_HTML.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/541783_1_En_11_Chapter/541783_1_En_11_Fig2_HTML.jpg)'
- en: A bar graph of time taken versus compaction on databases. The lowest time taken
    is 36 minutes for Scylla 4 dot 4 dot 3 and the highest is 37 hours 56 minutes
    for Cassandra 4 dot 0 dot 0.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库上压缩与时间对比的条形图。所需时间最短的是 Scylla 4 dot 4 dot 3 的 36 分钟，最长的是 Cassandra 4 dot 0
    dot 0 的 37 小时 56 分钟。
- en: Figure 11-2
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-2
- en: The wide range of time required to perform compaction on similar databases—from
    36 minutes to 37 hours and 56 minutes
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似数据库上执行压缩所需时间的范围很广——从 36 分钟到 37 小时 56 分钟
- en: 'Additional factors that influence the impact of compaction include:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 影响压缩影响的其他因素包括：
- en: '**Compaction backlog**: Since compacting data is a process that is always running
    in the background, the amount of data to compact is expressed by its growing backlog.
    If compaction falls behind, it will eventually try to catch up in an attempt to
    keep the database from running out of resources and to minimize read amplification.
    A growing compaction backlog indicates that the cluster is not sized appropriately,
    the use case in question is using an inappropriate compaction strategy, or the
    process is being throttled too aggressively in the database settings.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压缩积压**：由于压缩数据是一个始终在后台运行的过程，因此需要压缩的数据量通过其不断增长的积压来表示。如果压缩落后，它最终会试图赶上，以防止数据库资源耗尽并最小化读取放大。不断增长的压缩积压表明集群规模不合适，所涉及的使用案例正在使用不适当的压缩策略，或者数据库设置中的进程被过度限制。'
- en: '**Inefficient compaction strategy selection**: Write-mostly workloads are different
    from read-mostly workloads, which are different from update-heavy and delete-heavy
    workloads. Understanding the concepts behind every compaction strategy and how
    it impacts your workload is important to avoid read amplification, write amplification,
    or space amplification.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不合理的压缩策略选择**：以写为主的负载与以读为主的负载不同，它们与以更新和删除为主的负载也不同。理解每种压缩策略背后的概念以及它如何影响您的负载，对于避免读取放大、写入放大或空间放大非常重要。'
- en: '**Compaction throughput**: In situations where your use case relies heavily
    on reading from cold data, having overly aggressive compaction throughput would
    end up stealing some important IOPS and bandwidth needed for your workload. Play
    with different rate-limiting values and keep an eye on your compaction backlog
    until you find your sweet spot.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压缩吞吐量**：在您的用例严重依赖于从冷数据读取的情况下，过于激进的压缩吞吐量最终会窃取一些您工作负载所需的重要IOPS和带宽。尝试不同的速率限制值，并密切关注您的压缩积压，直到找到您的最佳点。'
- en: An inefficient compaction strategy may affect workloads differently, depending
    on what level of inefficiency it is. For example, a write-heavy workload will
    typically want to prevent compactions from running too aggressively; otherwise,
    it may exhaust the existing disk bandwidth capacity and eventually throttle down
    the database write path. On the other hand, a read-heavy workload will likely
    want compaction to run *more* aggressively, given that compactions may actually
    improve read latencies by requiring the database to issue fewer underlying storage
    disk I/O operations. Time-series use cases will typically prefer data to be separated
    into buckets so that eventual eviction can be done efficiently. And so on, and
    so on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 效率低下的压缩策略可能会根据其不效率的程度以不同的方式影响工作负载。例如，写密集型的工作负载通常会希望防止压缩过于激进地运行；否则，它可能会耗尽现有的磁盘带宽容量，并最终降低数据库的写入路径。另一方面，读密集型的工作负载可能会希望压缩运行得更激进，因为压缩实际上可以通过要求数据库发出更少的底层存储磁盘I/O操作来改善读延迟。时间序列用例通常会倾向于将数据分离到不同的桶中，以便最终可以有效地执行驱逐。等等，等等。
- en: Optimization
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化
- en: 'When selecting a compaction strategy, keep in mind that the ultimate goal should
    be low amplification. You want to avoid:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择压缩策略时，请记住，最终目标应该是低放大。您想避免：
- en: Read amplification (read requests needing many files to look up relevant data)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读放大（需要查找多个文件以查找相关数据的读请求）
- en: Excessive temporary disk space that requires the disk to be larger than a perfectly-compacted
    representation of the data (space amplification)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过多的临时磁盘空间，需要磁盘比数据完美压缩后的表示更大（空间放大）
- en: Compacting the same data over and over again (write amplification)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反复压缩相同的数据（写放大）
- en: Overwritten/deleted/expired data remaining on disk, slowing down your read path
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘上剩余的已覆盖/删除/过期的数据，会减慢你的读取路径
- en: Since not everyone is using a database that performs compaction, this chapter
    doesn’t go deep into the weeds of the pros and cons of specific strategies. Table
    [11-1](#Tab1) provides an overview of which compaction strategy *generally* works
    best for different workloads (your results may vary).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于并非每个人都使用执行压缩的数据库，因此本章不会深入探讨特定策略的优缺点。表 [11-1](#Tab1) 提供了不同工作负载中哪种压缩策略 *通常*
    工作得最好的概述（你的结果可能会有所不同）。
- en: Table 11-1
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-1
- en: Comparing Compaction Strategies
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 比较压缩策略
- en: '|   | Size-Tiered | Leveled | Incremental | Time Window | Comments |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|   | Size-Tiered | Leveled | Incremental | Time Window | Comments |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| **Write-only** | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figa_HTML.jpg)
    An icon of a check mark. | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figb_HTML.jpg)
    An icon of a cross mark. | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figc_HTML.jpg)
    An icon of a check mark. | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figd_HTML.jpg)
    An icon of a cross mark. | When using size-tiered with write-only workloads, it
    will use approximately 2x peak space. With incremental, the size amplification
    is much less.When using leveled compaction with write-only workloads, you will
    experience high write amplification. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **只写** | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figa_HTML.jpg)
    一个勾选标记的图标。 | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figb_HTML.jpg)
    一个叉号标记的图标。 | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figc_HTML.jpg)
    一个勾选标记的图标。 | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figd_HTML.jpg)
    一个叉号标记的图标。 | 当使用只写工作负载的分层大小时，它将使用大约2倍的峰值空间。使用增量时，大小放大要小得多。当使用只写工作负载的分层压缩时，您将经历高写放大。
    |'
- en: '| **Overwrite** | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Fige_HTML.jpg)
    An icon of a check mark. | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figf_HTML.jpg)
    An icon of a cross mark. | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figg_HTML.jpg)
    An icon of a check mark. | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figh_HTML.jpg)
    An icon of a cross mark. | When using size-tired or incremental with overwrite
    workloads, size amplification occurs.When using leveled compaction with overwrite
    workloads, write amplification occurs. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| **覆盖** | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Fige_HTML.jpg)
    一个勾选标记的图标。 | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figf_HTML.jpg)
    一个叉号标记的图标。 | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figg_HTML.jpg)
    一个勾选标记的图标。 | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figh_HTML.jpg)
    一个叉号标记的图标。 | 当使用按大小分层的或增量与覆盖工作负载时，会发生大小放大。当使用分层压缩与覆盖工作负载时，会发生写放大。 |'
- en: '| **Read-mostly, with few updates** | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figi_HTML.jpg)
    An icon of a cross mark. | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figj_HTML.jpg)
    An icon of a check mark. | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figk_HTML.jpg)
    An icon of a cross mark. | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figl_HTML.jpg)
    An icon of a cross mark. | When using size-tiered with read-mostly workloads with
    few updates, size amplification and read amplification occur. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| **读多写少，更新稀疏** | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figi_HTML.jpg)
    一个叉号标记的图标。 | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figj_HTML.jpg)
    一个勾选标记的图标。 | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figk_HTML.jpg)
    一个叉号标记的图标。 | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figl_HTML.jpg)
    一个叉号标记的图标。 | 当使用按大小分层的与读多写少且更新稀疏的工作负载时，会发生大小放大和读取放大。 |'
- en: '| **Read-mostly, with many updates** | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figm_HTML.jpg)
    An icon of a check mark. | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Fign_HTML.jpg)
    An icon of a cross mark. | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figo_HTML.jpg)
    An icon of a check mark. | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figp_HTML.jpg)
    An icon of a cross mark. | When using leveled with read-mostly workloads with
    many updates, write amplification occurs in excess. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **读多写少，更新频繁** | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figm_HTML.jpg)
    一个勾选标记的图标。 | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Fign_HTML.jpg)
    一个叉号标记的图标。 | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figo_HTML.jpg)
    一个勾选标记的图标。 | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figp_HTML.jpg)
    一个叉号标记的图标。 | 当使用分层与读多写少且更新频繁的工作负载时，会发生过度的写放大。 |'
- en: '| **Time series** | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figq_HTML.jpg)
    An icon of a cross mark. | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figr_HTML.jpg)
    An icon of a cross mark. | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figs_HTML.jpg)
    An icon of a cross mark. | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figt_HTML.jpg)
    An icon of a check mark. | When using size-tiered or incremental with time series
    workloads, size amplification, read amplification, and write amplification all
    occur.When using leveled with time series workloads, size amplification and write
    amplification occur. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **时间序列** | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figq_HTML.jpg)
    一个叉号标记的图标。 | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figr_HTML.jpg)
    一个叉号标记的图标。 | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figs_HTML.jpg)
    一个叉号标记的图标。 | ![](../images/541783_1_En_11_Chapter/541783_1_En_11_Figt_HTML.jpg)
    一个勾选标记的图标。 | 当使用按大小分层的或增量与时间序列工作负载时，会发生大小放大、读取放大和写放大。当使用分层与时间序列工作负载时，会发生大小放大和写放大。
    |'
- en: Two key takeaways should be that 1) one size never fits all, so it’s nice to
    have a choice in admin matters, and 2) tradeoffs are inevitable—know what pain
    you can tolerate best so pick your poison.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 两个关键要点应该是：1) 没有一种大小适合所有人，所以在管理事项上有选择权是很好的；2) 权衡是不可避免的——了解你能最好容忍的痛苦，然后选择你的毒药。
- en: To drive the point home, here’s a real-world story. Once upon a time, a new
    ScyllaDB user reported high read latencies. The use case was a TTL’d time series
    to support live media streaming. Time series use cases heavily rely on fetching
    data in specific timeframes and expect that such lookups are fast enough to be
    served by the database. As a result, time series use cases often rely on a Time-Bucketed
    compaction strategy, which ensures that the data in question is compacted together
    under the same time window to avoid the database having to potentially scan through
    multiple files across distinct windows just to retrieve the data. However, if
    configured incorrectly, the strategy may backfire and introduce severe performance
    headaches.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个观点更加明确，这里有一个现实世界的例子。曾经，一位新的ScyllaDB用户报告了高读延迟。用例是一个带有TTL的时间序列，用于支持实时媒体流。时间序列用例严重依赖于在特定时间范围内获取数据，并期望这些查找足够快，可以由数据库提供。因此，时间序列用例通常依赖于时间分桶的压缩策略，该策略确保相关数据在相同的时间窗口内一起压缩，以避免数据库需要扫描多个文件来检索数据。然而，如果配置不当，该策略可能会适得其反，并引发严重的性能问题。
- en: In this particular situation, we discovered that their time buckets were too
    small for the amount of data they were frequently retrieving as part of a single
    query. For example, if you decide to time-bucket your data every ten minutes,
    but always want to retrieve ten hours’ worth of data, that will require the database
    to scan through 60 (6 buckets/hour * 10 hours) of buckets! With the right amount
    of concurrency, every query scanning through these large chunks of data could
    starve the underlying disk I/O capacity. Therefore, the resolution was to update
    the compaction configuration to reflect a more realistic data grouping as required
    by the use case.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的情况下，我们发现他们的时间桶对于他们经常作为单个查询一部分频繁检索的数据量来说太小了。例如，如果您决定每十分钟对数据进行一次时间分桶，但总是想检索十小时的数据，那么这将要求数据库扫描60个桶（每小时6个桶
    * 10小时）！在适当的并发量下，每个查询扫描这些大量数据都可能导致底层磁盘I/O容量不足。因此，解决方案是更新压缩配置，以反映符合用例要求的数据分组。
- en: 'One final note on adjusting your compaction strategy for performance: Remember
    that when you adjust your compaction strategy, your database will need to rewrite
    all your table data. This will incur a significant performance penalty and should
    be carefully planned to occur at a time that works best for your business.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关于调整压缩策略以提高性能的注意事项：记住，当您调整压缩策略时，您的数据库将需要重写所有表数据。这将产生重大的性能惩罚，并且应该仔细计划在最适合您业务的时间进行。
- en: Summary
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Admin operations like repair, compactions, and backups are an unavoidable part
    of running a healthy, well-performing database. There’s no such thing as a “zero
    impact” admin operation; performing any operation consumes resources, and these
    operations can have exacerbated impacts if you’re operating at extreme scale.
    This chapter used the examples of backups and compaction to showcase the potentially
    significant—and also highly variable—impact of admin operations on performance.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 管理操作，如修复、压缩和备份，是运行健康、性能良好的数据库不可避免的一部分。不存在“零影响”的管理操作；执行任何操作都会消耗资源，如果您的操作规模极大，这些操作可能会产生加剧的影响。本章通过备份和压缩的例子展示了管理操作对性能可能产生的重要影响——这些影响也是高度可变的。
- en: 'This is the final official chapter of this book—the end of these highly opinionated
    recommendations for improving database performance based on what we’ve seen working
    with a broad range of database users and databases. It’s hardly the end of options
    for optimizing database performance though. Some potential next steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的最后一章——基于我们与广泛数据库用户和数据库合作的经验，对提高数据库性能提出的具有高度意见的建议的终结。尽管如此，优化数据库性能的选项远未结束。一些可能的下一步行动：
- en: Flag the considerations/recommendations that seem to offer potential for your
    specific workloads and use case, then discuss with your team.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记出似乎对您的特定工作负载和用例具有潜在价值的考虑事项/建议，然后与您的团队讨论。
- en: Take another look at your database’s specific options (e.g., for monitoring,
    drivers, admin, etc.) and see if it’s time to rethink any of your previous decisions.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视您数据库的具体选项（例如，用于监控、驱动程序、管理等），看看是否需要重新考虑您之前的任何决定。
- en: Tap your database vendor and/or community to learn about performance-related
    engineering decisions and optimizations that might offer untapped opportunities
    (or be responsible for some of your current constraints).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与您的数据库供应商和/或社区联系，了解与性能相关的工程决策和优化，这些可能提供未开发的机会（或导致您当前的一些限制）。
- en: Consider whether your data modeling might need a tune-up or overhaul (monitoring
    can help you assess this). If so, we recommend *NoSQL Distilled* by Pramod J.
    Sadalge and Martin Fowler—assuming you’re using NoSQL. If not, browse the wealth
    of resources on RDBMS data modeling.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑一下您的数据建模可能需要调整或彻底改造（监控可以帮助您评估这一点）。如果是这样，我们推荐Pramod J. Sadalge和Martin Fowler的《NoSQL
    Distilled》——假设您正在使用NoSQL。如果不是，请浏览关于RDBMS数据建模的丰富资源。
- en: 'Continue learning more about the fundamental database design decisions made
    when building any distributed database: replication and sharding strategies, consensus
    algorithms, data structures (B-tree vs LSM tree), and so on. You can get a performance-focused
    introduction to these topics, as well as recommendations for learning more from
    the masters, in Appendix A.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续深入了解在构建任何分布式数据库时做出的基本数据库设计决策：复制和分片策略、共识算法、数据结构（B树与LSM树）等。您可以在附录A中找到这些主题的性能介绍，以及从大师那里学习更多建议。
- en: '[![Creative Commons](../css/cc-by.png)](https://creativecommons.org/licenses/by/4.0)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![Creative Commons](../css/cc-by.png)](https://creativecommons.org/licenses/by/4.0)'
- en: '**Open Access** This chapter is licensed under the terms of the Creative Commons
    Attribution 4.0 International License ([http://​creativecommons.​org/​licenses/​by/​4.​0/​](http://creativecommons.org/licenses/by/4.0/)),
    which permits use, sharing, adaptation, distribution and reproduction in any medium
    or format, as long as you give appropriate credit to the original author(s) and
    the source, provide a link to the Creative Commons license and indicate if changes
    were made.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放获取** 本章节根据Creative Commons Attribution 4.0国际许可协议（[http://creativecommons.org/licenses/by/4.0/](http://creativecommons.org/licenses/by/4.0/)）许可，允许在任何媒介或格式中使用、分享、改编、分发和复制，只要您适当引用原始作者和来源，提供Creative
    Commons许可的链接，并指出是否进行了更改。'
- en: The images or other third party material in this chapter are included in the
    chapter's Creative Commons license, unless indicated otherwise in a credit line
    to the material. If material is not included in the chapter's Creative Commons
    license and your intended use is not permitted by statutory regulation or exceeds
    the permitted use, you will need to obtain permission directly from the copyright
    holder.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的图像或其他第三方材料均包含在章节的Creative Commons许可协议中，除非在材料引用行中另有说明。如果材料未包含在章节的Creative
    Commons许可协议中，且您的使用未获得法定规定的许可或超出了允许的使用范围，您将需要直接从版权持有人处获得许可。
