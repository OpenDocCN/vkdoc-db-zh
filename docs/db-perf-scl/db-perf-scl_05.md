# 6. 将数据更靠近

数据库作为计算引擎边缘计算总结

位置，位置，位置。有时对数据库性能的重要性与对房地产一样重要。正如房屋的位置影响其销售速度一样，数据“居住”和被处理的位置对于响应时间和延迟也很重要。

将更多逻辑推入数据库通常可以减少网络延迟（以及成本，例如，当你的基础设施提供商对入站/出站网络流量收费时），同时利用数据库强大的计算能力。将数据库逻辑从较少的强大数据中心重新分配到更简约且更靠近用户的数据中心，在适当条件下也是一种可以带来明显性能提升的措施。

本章探讨了这两个转变中的机会。首先，它将数据库视为计算引擎，重点关注用户定义的函数和用户定义的聚合。然后，它更深入地探讨了 WebAssembly，它现在越来越多地被用于实现用户定义的函数和聚合（以及其他许多事物）。最后，章节探索了边缘——探讨将数据库服务器移至非常靠近用户可以获得的好处，以及在这种场景下需要克服的潜在陷阱。

## 数据库作为计算引擎

现代数据库提供的功能远不止存储和检索数据。其中一些几乎等同于操作系统，能够进行流式传输、修改、加密、授权、认证以及处理它们所管理的数据的几乎所有其他操作。

数据局部性是分布式系统中的圣杯。你越少需要移动数据，就有更多时间可以用来在数据上执行有意义的操作——而不需要过高的带宽成本。这就是为什么尝试将更多逻辑推入数据库本身，让它尽可能本地处理，然后将结果返回给用户或某些中间件进行进一步处理是有意义的。当你考虑到数据库节点通常运行在强大的硬件上，拥有大量的 RAM 和快速的 I/O 设备时，这一点就更加合理了。这通常意味着强大的 CPU 性能。除了专用的大数据处理框架（例如，Apache Spark，本书范围之外）之外，常规数据库引擎几乎总是支持某种程度上的用户定义计算。这些可以归类为两大类：用户定义的函数/过程和用户定义的聚合。

注意，定义可能会有所不同。一些数据库供应商使用“函数”这个通用名称来同时指代聚合函数和标量函数。而另一些供应商在提到“函数”时实际上是指“标量函数”，并使用“聚合”这个名称来指代“聚合函数”。本章中应用的就是这种惯例。

### 用户定义的函数和过程

与本地函数相比，本地函数通常在数据库引擎中实现（例如`lowercase()`、`now()`、`concat()`、类型转换、代数运算等），由数据库的用户（例如，构建应用程序的开发者）提供。在这个上下文中，“过程”实质上与函数相同，只是它不返回任何结果；相反，它具有副作用。

允许用户定义自己的函数或过程的精确接口在数据库供应商之间差异很大。尽管如此，这里列出的几个核心策略通常都会实现：

1.  一组硬编码的本地函数，不可扩展，但至少是可组合的。例如，将类型转换为字符串，将其与预定义的后缀连接，然后进行哈希处理。

1.  一种定制的脚本语言，专门针对特定数据库，并允许用户在数据上编写和执行简单的程序。

1.  支持单一通用嵌入式语言。例如，Lisp、Lua、ChaiScript、Squirrel 或 WebAssembly 可能用于此目的。注意：你将在本章稍后更深入地了解 WebAssembly。

1.  支持多种可插拔的嵌入式语言。一个很好的例子是 Apache Cassandra 及其对 Java（本地语言）和 JavaScript 的支持，以及通过.jar 文件加载的可插拔后端。

列表中的第一个选项最不灵活，提供了最差的开发者体验，并且具有最低的安全风险。最后一个选项最灵活，提供了最佳的开发者体验，同时也潜藏着成为值得单独 CVE 编号的安全风险的最大可能性。

标量函数通常按行调用，至少对于面向行的数据库来说是这样，这对于 SQL 通常是情况。你可能想知道计算是否不能简单地由最终用户在自己的机器上执行。这是一个有效的观点。这种方法的主要优势是无论有多少用户执行数据转换（如果他们在自己的机器上本地执行，那么数据库集群就不会过载），都具有出色的可扩展性。

有几个很好的理由将计算推近到数据存储的地方：

+   数据库有更多的上下文来有效地缓存计算结果。想象一下成千上万的用户请求在特定行集上应用相同的函数。这个结果只需计算一次，然后分发给所有感兴趣的各方。

+   如果计算结果与其输入相比明显较小（例如，仅返回文本值的长度），则最好节省带宽，只发送最终结果。

+   某些维护操作（例如，删除一周以上的数据）可以有效地在本地执行，而无需将任何信息检索到客户端进行验证。

+   如果处理是在数据库服务器上进行的，该数据库 CPU 芯片上驻留的指令缓存可能因为执行每行计算所需的操作码而非常热。一般来说，热缓存意味着代码执行更快，延迟更低。

+   有些计算不能简单地分发给用户。如果它们涉及到存储在数据库服务器上的加密私钥，实际上可能在服务器本身之外的其他地方无法运行代码。

+   如果执行计算的数据是敏感的（例如，它属于臭名昭著且不断变化的欧洲数据保护法规，如 GDPR），将原始数据发送给用户可能是非法的。在这种情况下，在服务器端运行加密函数可以是用户获取混淆后合法数据的一种方式。

#### 确定性

在分布式环境中，幂等性（在第五章中讨论）是一个重要的属性，它使得以推测方式发送请求成为可能，从而可能提高性能。因此，最好确保用户定义的函数是确定性的。换句话说，用户定义函数的值应仅取决于其参数的值，而不是任何外部因素（如时间、日期、伪随机种子等）的值。

一个非确定性函数的完美例子是`now()`。如果你足够快，调用它两次可能得到相同的结果，但通常不能保证，因为其结果是依赖于时间的。如果可能的话，以确定性方式编写用户定义的函数并将其标记为确定性是一个好主意。对于时间/日期，这可能涉及基于传递的时间戳计算结果，而不是使用内置的时间实用程序。对于伪随机抽样，种子也可以作为参数传递，而不是依赖于用户定义函数运行时提供的熵源。

#### 延迟

在您的数据库集群上运行用户提供的代码在安全以外的方面也可能很危险。大多数嵌入式语言都是图灵完备的，通常允许开发者在其代码中使用循环、递归和其他类似技术。这是有风险的。一个未被发现的无限循环可能作为拒绝服务攻击，迫使数据库服务器无限期地处理一个函数，并阻止其他任务使用资源。即使用户定义函数的作者没有恶意意图，一些计算也可能消耗大量的 CPU 时间和内存。

从某种意义上说，用户定义函数应该被视为潜在的“嘈杂邻居”^(2)，其资源应该尽可能有限。对于某些用例，对内存和 CPU 时间使用的简单硬限制就足以确保其他数据库任务的性能不会因“嘈杂”的用户定义函数而受到影响。然而，有时需要更具体的解决方案——例如，将用户函数定义拆分为更小的时间块，为用户定义函数分配优先级，等等。

Wasmtime，^(3)一个 WebAssembly 运行时，应用了一个有趣的计量机制。在 WebAssembly 实例中运行的代码消耗*燃料*，^(4)这是一个用于跟踪实例耗尽系统资源速度的合成单位。当实例耗尽燃料时，运行时会执行预配置的操作之一——要么“补充燃料”并允许代码执行继续，要么决定任务达到了配额并终止它。

#### 即时编译（JIT）

用于用户定义函数的语言通常是解释型（例如，Lua）或以字节码形式表示，这些字节码在虚拟机上运行（例如，WebAssembly）。这两种方法都可以从即时编译中受益。这是一个广泛的话题，但其本质是在运行时，用户定义函数的代码可以被编译为另一种更有效的表示形式，并在过程中进行优化。这可能意味着将字节码转换为程序运行的机器代码（例如，x86-64 指令），或者将解释语言中表示的源代码编译成机器代码。

JIT 是一个非常强大的工具，但不是万能的——编译和额外的优化在资源方面可能是一个昂贵的流程。一个小型的用户定义函数可能运行时间不到一毫秒，但重新编译它可能会导致 CPU 和内存使用量突然增加，以及处理延迟多毫秒——导致高尾部延迟。因此，如果语言允许，是否为用户定义函数启用即时编译，或者完全禁用它，应该是一个有意识的决定。

#### 示例

让我们看看一些用户定义函数的例子。作为例子的函数操作浮点数；给定两个参数，它返回它们的和的倒数。给定 5 和 7，它应该返回 1/5+1/7，大约是 0.34285714285。

在 Apache Cassandra 中，可以这样定义它，它允许用户在 Java（其本地语言）以及其他语言中提供用户定义函数的定义：

```
CREATE OR REPLACE FUNCTION add_inverse(val1 double, val2 double)
RETURNS NULL ON NULL INPUT
RETURNS double LANGUAGE java
AS '
return (val1 == 0 || val2 == 0)
? Double.NaN
: (1/val1 + 1/val2);
';
```

让我们更仔细地看看定义。第一行很简单：它包括函数的名称、参数及其类型。它还指定，如果已经存在具有该名称的函数定义，则应替换它。接下来，它明确声明了如果任何参数为`null`（对于任何类型都是有效值）会发生什么。函数可以完全不调用函数就返回`null`，或者允许`null`并让源代码显式处理（该语法为`CALLED ON NULL INPUT`）。这种显式声明是 Apache Cassandra 所要求的。

随后是返回类型和选择的语言——从这些可以正确推断出支持多种语言。然后是函数体。程序员做出的唯一非直观的决定是如何处理作为参数的`0`。由于 Apache Cassandra 中实现的类型系统已经处理了 NaN，^(5)，它是一个不错的候选者（与正/负无穷大并列）。

新创建的函数可以通过创建一个表、用几个值填充它并检查结果来轻松测试：

```
CREATE TABLE test(v1 double PRIMARY KEY, v2 double);
INSERT INTO test(v1, v2) VALUES (5, 7);
INSERT INTO test(v1, v2) VALUES (2, 2);
INSERT INTO test(v1) VALUES (9);
INSERT INTO test(v1, v2) VALUES (7, 0);
SELECT v1, v2, add_inverse(v1, v2) FROM test;
cassandra@cqlsh:test> SELECT v1, v2, add_inverse(v1, v2) FROM test;
v1 | v2   | test.add_inverse(v1, v2)
----+------+--------------------------
9 | null |                     null
5 |    7 |                 0.342857
2 |    2 |                        1
7 |    0 |                      NaN
```

从性能的角度来看，将这样一个简单的函数卸载到数据库服务器上值得吗？不太可能——计算成本相当低，因此用户在接收到数据后应该能够立即自己推导出这些值。另一方面，数据库服务器可能需要初始化用户定义函数的运行时，因为这些函数通常为了安全目的而被沙盒化。这个运行时初始化需要时间和其他资源。如果数据在服务器端聚合，那么卸载这样的计算就更有意义，这在下一节（关于用户定义的聚合）中讨论。

#### 最佳实践

在学习用户定义的聚合函数之前，这些函数能够释放用户定义函数的真正潜力，总结一下在数据库管理系统中设置用户定义函数的一些最佳实践是很重要的：

1.  评估你是否真的需要用户定义的函数——比较使用用户定义函数的查询的延迟（以及一般性能）与在客户端端计算所有内容（假设这是可能的）。

1.  测试将计算卸载到数据库服务器是否可扩展。查看 CPU 利用率等指标，以评估你的数据库系统可以多好地处理数千名请求额外计算的用户。

1.  认识到用户定义的函数很可能会在“快速路径”上执行，因此它们也需要优化和基准测试！考虑你在用户定义函数实现中使用的语言的性能最佳实践。

1.  确保在用户定义的函数中妥善处理任何错误或异常情况，以避免干扰数据库系统的其他操作。

1.  在可能的情况下，考虑使用内置函数而不是创建用户定义函数。内置函数可能更优化和高效。

1.  保持你的用户定义函数简单且模块化，将复杂任务分解成更小、更易于管理的函数，这些函数可以轻松测试和重用。

1.  正确记录你的用户定义函数，以便其他数据库系统用户可以理解它们的工作原理以及如何正确使用它们。

### 用户定义的聚合

用户定义函数最大的潜力在于它们是用户定义聚合的构建块。聚合函数作用于多行或多列，有时作用于整个表或数据库。

将此类操作移至数据所在位置附近是完全合理的。想象一下 1TB 的数据库行需要聚合成一个单一值：它们值的总和。当成千上万的用户请求所有这些行以在客户端执行聚合时，以下情况会发生：

1.  总共 PB 级的数据通过网络发送到每个用户。

1.  每个用户都会执行大量的计算，从 RAM 和 CPU 的角度来看成本高昂，但得到的结果与其它用户完全相同。

如果聚合操作由数据库服务器执行，它不仅避免了 PB 级的数据流量；同时也为用户节省了计算能力（这是一个相当环保的解决方案）。如果计算被适当地缓存，它只需要执行一次。这在性能方面是一个巨大的胜利，许多用例可以立即从将聚合计算推近数据处受益。这对于倾向于处理大量数据以生成有用统计和反馈的分析工作负载尤为重要——这个过程本身就是一种聚合。

#### 内置聚合

允许创建用户定义聚合的数据库通常也提供一些传统的内置聚合函数：著名的`COUNT(*)`，还有`MAX`、`MIN`、`SUM`、`AVG`等。这些函数考虑了多行或多值，并返回一个聚合结果。结果可能是一个单一值。或者，如果输入被分成更小的类别，它也可能是一组值。此类操作的一个例子是 SQL 的`GROUP BY`语句，它将聚合应用于多个不相交的值组。

在可能的情况下，应优先选择内置聚合而不是用户定义的聚合——它们很可能是用数据库服务器本机语言编写的，已经优化，并且安全。然而，预定义的聚合函数集通常非常基础，不允许用户执行那些使用户定义的聚合成为强大工具的复杂计算。

#### 组件

用户定义的聚合通常建立在用户定义的标量函数之上。具体细节很大程度上取决于数据库系统，但以下组件绝对值得提及。

##### 初始值

聚合需要从一个地方开始，并且用户需要提供一个初始值，最终结果将从该值计算得出。对于返回表中行数或值的`COUNT`函数，初始值自然可以是`0`。对于计算所有列值的算术平均值的`AVG`，初始状态可以由两个变量组成：值的总数，初始化为`0`，以及值的总和，也初始化为`0`。

##### 状态转换函数

每个用户定义的聚合的核心是其状态转换函数。这个函数会在需要处理的新值被调用时被调用，每次调用都会返回聚合的新状态。以`COUNT`函数为例，其状态转换函数只是简单地通过增加一行来增加行数。`AVG`聚合的状态转换函数只是将当前值加到总和上，并将值的总数增加一。

##### 最终函数

最终函数是用户定义聚合的一个可选特性。它的唯一目的是将聚合的最终状态转换成其他形式。对于`COUNT`，不需要进一步的转换。用户只对聚合的最终状态（值的数量）感兴趣，所以最终函数不需要存在；可以假设它是一个恒等函数。然而，在`AVG`的情况下，最终函数是使结果对用户有用的关键。它通过简单地除以另一个值来转换最终状态——值的总数和总和——从而产生算术平均值，并处理避免除以零的特殊情况。

##### 聚合函数

聚合函数是用户定义聚合世界中的一个有趣的附加特性，尤其是在分布式数据库中。它可以被看作是另一个状态转换函数，但它是将两个部分状态合并为一个的函数。

在聚合函数的帮助下，用户定义聚合的计算可以分布到多个数据库节点上，以 map-reduce^(6)的方式。这反过来又可以实现巨大的性能提升，因为计算突然变得并发。请注意，这种优化并不总是可能的——如果状态转换函数不是交换的，分布部分计算可能会导致错误的结果。

为了更好地想象一个聚合函数可能的样子，让我们回到`AVG`的例子。`AVG`的部分状态可以表示为*(n, s)*，其中*n*是值的数量，*s*是它们的总和。通过简单地将相应的值相加，可以将两个部分状态合并成一个新的有效状态：*(n*[*1*]*, s*[*1*]*) + (n*[*2*]*, s*[*2*]*) → (n*[*1*]*+ n*[*2*]*, s*[*1*] *+ s*[*2*]*)*. 可以定义一个可选的聚合函数（例如，在 ScyllaDB 的用户定义聚合实现中^(7)）。

用户定义的聚合支持在数据库供应商之间并不标准化，每个数据库都有自己的怪癖和实现细节。例如，在 PostgreSQL 中，你也可以通过提供另一组函数和参数（`msfunc`、`minvfunc`、`mstype` 和 `minitcond`）来实现一个“移动”聚合^(8)。尽管如此，基本思想保持不变：让用户尽可能地将聚合逻辑推近数据。

#### 示例

让我们在 PostgreSQL 中创建一个自定义的整数算术平均数实现。

这将通过提供状态转换函数（在 PostgreSQL 术语中称为 `sfunc`）、最终函数（称为 `finalfunc`）、初始值（`initcond`）和状态类型（`stype`）来实现。所有函数都将使用 SQL，即 PostgreSQL 的原生查询语言来实现。

##### 状态转换函数

状态转换函数，称为 `accumulate`，接受一个新的整数值（第二个参数）并将其应用于现有状态（第一个参数）。如本章前面所述，简单的实现将两个变量保留在状态中——所有值的当前总和和它们的计数。因此，过渡到下一个状态 simply means that the sum is incremented by the current value, and the total count is increased by one.

```
CREATE OR REPLACE FUNCTION accumulate(integer[], integer) RETURNS integer[]
AS 'select array[$1[1] + $2, $1[2] + 1];'
LANGUAGE SQL
IMMUTABLE
RETURNS NULL ON NULL INPUT;
```

##### 最终函数

最终函数将值的总和除以值的总数，对于`0`个值的平均值进行特殊处理，其结果应为`0`。最终函数返回一个浮点数，因为这是聚合函数表示算术平均数的方式。

```
CREATE OR REPLACE FUNCTION divide(integer[]) RETURNS float8
AS 'select case when $1[2]=0 then 0 else $1[1]::float/$1[2] end;'
LANGUAGE SQL
IMMUTABLE
RETURNS NULL ON NULL INPUT;
```

##### 聚合定义

在所有构建块就绪后，现在可以声明用户定义的聚合：

```
CREATE OR REPLACE AGGREGATE alternative_avg(integer)
(
sfunc = accumulate,
stype = integer[],
finalfunc = divide,
initcond = '{0, 0}'
);
```

除了声明状态转换函数和最终函数外，状态类型也被声明为整数数组（在实现中始终保留两个值），以及将两个计数器、总和和值的总数都设置为`0`的初始条件。

就这样！由于整数的 `AVG` 聚合是内置的，这为你提供了一个完美的机会来验证实现是否正确：

```
postgres=# CREATE TABLE t(v INTEGER);
postgres=# INSERT INTO t VALUES (3), (5), (9);
postgres=# SELECT * FROM t;
v
---
3
5
9
(3 rows)
postgres=# SELECT AVG(v), alternative_avg(v) FROM t;
avg         |  alternative_avg
--------------------+-------------------
5.6666666666666667 | 5.666666666666667
(1 row)
```

哇！记住，虽然为 `AVG` 创建一个替代实现是用户定义聚合的一个很好的学术示例，但对于生产使用来说，只要内置聚合可用，几乎总是更好的选择。

##### 分布式用户定义聚合

为了完整性，让我们看看一个几乎相同的自定义平均函数的实现，但这次是为了适应在多个节点上分布。这次我们将使用 ScyllaDB 作为参考，因为它的用户定义聚合实现包括一个用于以 map-reduce 方式分布计算的扩展。以下是完整的源代码：

```
CREATE FUNCTION accumulate(acc tuple, val int)
RETURNS NULL ON NULL INPUT
RETURNS tuple
LANGUAGE lua
AS $$
return { acc[1]+val, acc[2]+1 }
$$;
CREATE FUNCTION reduce(acc tuple, acc2 tuple)
RETURNS NULL ON NULL INPUT
RETURNS tuple
LANGUAGE lua
AS $$
return { acc[1]+acc2[1], acc[2]+acc2[2] }
$$;
CREATE FUNCTION divide(acc tuple)
RETURNS NULL ON NULL INPUT
RETURNS double
LANGUAGE lua
AS $$
return acc[1]/acc[2]
$$;
CREATE AGGREGATE alternative_avg(int)
SFUNC accumulate
STYPE tuple
REDUCEFUNC reduce
FINALFUNC divide
INITCOND (0, 0);
```

ScyllaDB 的原生查询语言 CQL 与 SQL 非常相似，甚至在缩写上也是如此。很容易看出，大部分源代码对应于上一段中提到的 PostgreSQL 实现。ScyllaDB 不允许在 CQL 中定义用户定义函数，但它支持 Lua，一种流行的轻量级嵌入式语言，以及 WebAssembly。由于本书预期主要供人类阅读（偶尔 ChatGPT 一旦实现完全意识，也会阅读），因此选择了 Lua 作为此示例，因为它更加简洁。

最显著的区别是 `reduce` 函数，该函数在 `REDUCEFUNC` 关键字下声明。此函数接受两个部分状态并返回另一个（组合）状态。如果 ScyllaDB 服务器存在此函数，可以执行以下操作：

1.  将域（例如，数据库中的所有行）划分为多个部分，并让多个服务器部分聚合它们，然后将结果发送回来。

1.  将 reduce 函数应用于将部分结果合并为单个最终结果。

1.  将最终结果返回给用户。

因此，通过提供 reduce 函数，用户还允许 ScyllaDB 在多台机器上并发计算聚合。与仅在单个服务器上执行的大型查询相比，这可以大幅减少查询执行时间。

在这个特定情况下，甚至可能更倾向于提供一个用户定义函数的用户定义替代方案，以提高其并发性——除非内置原语也附带现成的 reduce 函数。这是 ScyllaDB 的情况，但并不一定适用于提供类似功能的其他数据库。

#### 最佳实践

1.  如果计算可以用内置聚合有效地表示，则这样做——或者至少基准测试自定义实现是否更快。用户定义的聚合非常灵活，但通常与内置实现相比，会带来额外的开销。

1.  研究是否可以自定义用户定义聚合以更好地适应特定用例——例如，如果计算可以分布到多个数据库节点，或者数据库允许配置其缓存以将用户定义聚合的中间结果存储在某个位置。

1.  在生产中使用之前，始终彻底测试您用户定义聚合的性能。这将有助于确保它们效率高，并且可以处理您期望它们处理的负载。

1.  测量您的工作负载中使用用户定义聚合的集群级影响。类似于全表扫描，聚合是一个昂贵的操作，并且确保它们尊重其他工作负载的服务质量，不要超出您系统中可接受的范围，这一点很重要。

### WebAssembly 用于用户定义函数

WebAssembly，也称为 Wasm，是一种表示可执行代码的二进制格式，旨在易于嵌入到其他项目中。结果证明，WebAssembly 也是后端用户定义函数的完美候选者，这得益于其易于集成、性能和普及。

关于 WebAssembly 有许多优秀的书籍和文章^(9)，它们都一致认为，首先，这是一个误称——WebAssembly 的用途远远超出了网络应用。它实际上是一种坚实的通用语言，已经成为全球嵌入式语言的默认选择。它满足了所有条件：

+   ☒ 它是开源的，拥有一个充满活力的社区

+   ☒ 它是可移植的

+   ☒ 默认情况下它是隔离的，所有内容都在沙盒环境中运行

+   ☒ 它速度快，在性能上与本地 CPU 代码相当

#### 运行时

WebAssembly 被编译成字节码。这种字节码旨在在虚拟机上运行，这通常是更大开发环境（称为运行时）的一部分。存在多个 WebAssembly 运行时的实现，最著名的是：

+   Wasmtime

    [`https://wasmtime.dev/`](https://wasmtime.dev/)

    一个快速且安全的 WebAssembly 运行时，用 Rust 实现，由 Bytecode Alliance^(10) 非营利组织支持。

+   Wasmer.io

    [`https://wasmer.io/`](https://wasmer.io/)

    另一个在 Rust 中实现的开源项目；WAPM^(11) 项目的维护者，这是一个 Wasm 包管理器。

+   WasmEdge:

    [`https://wasmedge.org/`](https://wasmedge.org/)

    使用 C++ 实现的运行时，通用但专注于边缘计算。

+   V8:

    [`https://v8.dev/`](https://v8.dev/)

    谷歌的 JavaScript 单体运行时；用 C++ 编写，也支持 WebAssembly。

此外，由于 WebAssembly 规范是公开的，您可以自由地实现自己的版本！但请注意：该标准仍在快速发展中，每天都在快速变化。

#### 回到延迟问题

每个运行时都可以自由定义自己的性能特性和保证。Wasmtime 引入的一个有趣特性是 *燃料* 的概念，这在之前关于用户定义函数的讨论中已经提到。结合 Wasmtime 为运行 WebAssembly 模块提供可选的异步接口的事实，这使用户有机会根据他们的延迟需求微调运行时。

当 Wasmtime 开始执行一个给定的 WebAssembly 函数时，这个执行单元被分配了一定数量的燃料。每个执行步骤消耗一小部分燃料——在撰写本文时，它简单地消耗每个 WebAssembly 字节码指令的一个单位燃料，不包括一些流程控制指令，如分支。一旦执行单元耗尽燃料，它就会让出。之后，执行单元会采取预配置的操作之一：要么终止执行单元，要么为其油箱加油，并允许它返回到之前正在计算的任务。这种机制允许开发者控制单个函数执行可以消耗的总 CPU 时间，以及执行应该让出并交出 CPU 给其他任务的频率。因此，正确配置燃料管理可以防止函数执行长时间占用 CPU。这有助于在整个系统中保持低且可预测的延迟。

WebAssembly 的另一个有趣方面是其可移植性。代码可以分发到多个地方，并且保证在多个环境中正确运行，这使得它不仅适合移动数据，也适合移动计算，更靠近用户。

将数据库逻辑从庞大的数据中心推向更小的数据中心，这些数据中心更靠近最终用户，得到了一个响亮的名字：边缘计算。

## 边缘计算

由于物联网（IoT）成为现实，术语“边缘计算”需要明确区分。本段（不幸地？）**不是**关于：

+   利用你所在地区的智能冰箱的联合计算能力

+   从你的本地蓝牙灯泡网络创建一个数据网格

+   将你的智能手表集成到见证模式的 Raft 集群中

本段中描述的“边缘”是一种更无聊的类型。它仍然意味着在服务器上执行计算，但是在更靠近用户的地方（例如，位于华沙的本地 Equinix 数据中心，而不是法兰克福的 Amazon 的`eu-central-1`）。

### 性能

边缘计算与数据库性能有何关联？它将数据更靠近用户，而更近的物理距离意味着更低的延迟。另一方面，将数据库集群分布到多个位置也有其不利之处。在这些地区之间移动大量数据可能会很昂贵，因为云服务提供商往往对跨区域流量收费。如果数据库节点之间的延迟达到数百毫秒，这是北美和欧洲之间的客户级延迟（除非你能负担得起 Hibernia Express^(12))，它们很容易失去同步。即使只有几次往返——仅分布式共识算法就需要至少两次——也可能导致超过一秒舒适区的延迟。由于集群跨越多个地理位置，数据包丢失发生的频率更高，因此故障检测机制也受到影响。

需要为边缘友好型数据库的数据库驱动程序了解所有这些提到的限制。特别是，它们需要尽可能小心地选择最近的区域，以最小化延迟和失败的可能性。

### 无冲突复制数据类型

CRDT（无冲突复制数据类型）是一种处理不一致性的有趣方法。它是一组数据结构，旨在具有以下特性：

+   用户可以独立更新数据库副本，无需与其他数据库服务器协调。

+   存在一个算法可以自动解决当相同数据同时独立写入多个副本时可能发生的冲突。

+   允许副本处于不同的状态，但它们最终将收敛到共同的状态。

随着边缘计算的兴起，CRDT 的概念也获得了关注，因为两者相辅相成。数据库被允许在多个地方保持副本，并允许它们在没有中央协调的情况下行动——但与此同时，用户可以假设数据库状态最终将变得一致。

接下来将讨论一些符合 CRDT 定义的有趣数据结构。

#### G-计数器

只增计数器。通常实现为一个计数器数组，为每个数据库节点保持一个局部计数器值。来自不同节点的两个数组状态可以通过取每个相应字段的最高值来合并。G-计数器的实际值只是所有局部计数器的总和。

#### PN-计数器

正负计数器，通过保持两个 G-计数器实例——一个用于累积正值，另一个用于累积负值——来巧妙地实现。最终值是通过从其中一个减去另一个得到的。

#### G-集合

只增集合，即禁止删除元素的集合。合并两个 G-集合是一个简单的集合联合，因为值永远不会从 G-集合中删除。G-集合的一种变体是 G-映射，其中与键关联的条目、键和值一旦添加就不能删除。

#### LWW-集合

最后写入获胜集合（以及相应的映射）。这是两个 G-集合的组合，一个收集添加的元素，另一个包含移除的元素。冲突解决基于“添加”G-集合的集合联合，减去“移除”G-集合的联合，但也会考虑时间戳。如果值在“添加”集合中的时间戳大于其在“移除”集合中的时间戳，或者它根本不在“移除”集合中，则该值存在。

显然，这个列表并不全面，还有无数其他 CRDT 存在。如果你对这个主题感兴趣，请鼓励你进行研究！

CRDTs 不仅仅是理论结构；它们在实践中的应用非常广泛。在提供最终一致性（如 Apache Cassandra 和 ScyllaDB）的数据库中，冲突自由复制的数据类型的变体很常见。它们的写入操作具有“最后写入者胜出”的语义用于冲突解决，它们的计数器实现基于 PN-Counter 的概念。

## 摘要

到目前为止，应该很清楚，通过稍微不常规地使用数据库以及理解（并利用）数据库及其驱动程序中内置的专用功能，有几种方法可以提高性能。让我们转换一下思路，看看我们推荐的确保数据库性能最佳的前“应该做”和“不应该做”事项。下一章将重点讨论基础设施选项（CPU、内存、存储和网络）和部署模型，以此开始这一讨论。

![Creative Commons](https://creativecommons.org/licenses/by/4.0)

**开放获取** 本章节根据 Creative Commons Attribution 4.0 International License（[`creativecommons.org/licenses/by/4.0/`](http://creativecommons.org/licenses/by/4.0/)）的条款进行许可，允许在任何媒介或格式中使用、分享、改编、分发和复制，只要您适当引用原始作者和来源，提供 Creative Commons 许可的链接，并指明是否进行了修改。

本章节中的图像或其他第三方材料包含在本章节的 Creative Commons 许可中，除非在材料引用行中另有说明。如果材料未包含在本章节的 Creative Commons 许可中，且您的使用意图不受法定法规允许或超出允许的使用范围，您需要直接从版权持有人处获得许可。
