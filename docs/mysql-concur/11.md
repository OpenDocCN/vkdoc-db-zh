# 十一、事务

事务是报表的老大哥。它们将多个更改组合在一起，无论是在单个语句中还是在几个语句中，因此它们作为一个单元被应用或放弃。大多数情况下，事务只是事后的想法，只是在需要将几个语句一起应用时才考虑。这不是考虑事务的好方法。它们对于确保数据完整性非常重要，如果使用不当，会导致严重的性能问题。

本章首先讨论什么是事务和 ACID 概念，然后通过回顾事务对锁和性能的影响，继续讨论为什么需要从性能的角度认真对待事务。最后，讨论了组提交特性如何提高高并发系统的性能。

## 事务和 ACID

从最简单的角度来看，事务是一个包含一个或多个语句的容器。然而，这是一种过于简单化的观点，因为事务也有其自身的属性。最重要的是，它是实现*原子性、一致性、隔离性和持久性* ( *酸*)的主要工具。本节将详细介绍这四个属性。

### 原子数

原子性的概念意味着事务中的所有更改要么被提交，要么被回滚。这就是容器的概念发挥作用的地方，因此所有语句都被视为一个工作单元——或者换句话说，一个事务是原子的。

原子性为什么重要的经典例子是两个银行账户之间的金融事务。从付款人的账户中提取一笔金额，并将其插入收款人的账户。如果没有原子性，你可能最终会把钱取出来，但永远不会插入，从而让双方中的一方赔钱。事务是原子保证，如果钱被提取，接收者也收到他们账户上的钱。

### 一致性

数据库满足一致性属性意味着有适当的检查来确保如果事务成功提交，那么数据是一致的。一致性的含义很大程度上是由业务逻辑定义的。例如，您不能为不存在的实体创建银行帐户。在数据库内部，约束(包括外键)的工作是确保数据的一致性。通过使用事务，由于其原子行为，即使约束在第二步或后面的步骤中失败，也可以恢复(回滚)整个事务，并且数据库保持其原始和一致的状态。

在某些数据库中，约束检查可以推迟到提交事务时进行。如果您考虑这样一个例子，不允许您拥有一个不存在的实体的银行帐户，延迟约束允许您首先创建帐户，然后在同一事务中注册拥有该帐户的实体。延迟约束主要用于循环关系，如添加必须具有默认组成员的组，但由于成员必须属于某个组，因此在添加组及其初始成员时，有必要暂时放松约束。

Note

延迟约束的使用是一个有争议的话题，可以认为它违反了关系数据库理论的原则。例如，C.J. Date 认为约束必须在语句边界得到满足； [`https://www.brcommunity.com/articles.php?id=b065b`见](https://www.brcommunity.com/articles.php%253Fid%253Db065b)。

InnoDB 不支持延迟约束，但支持通过显式禁用`foreign_key_checks`变量来禁用外键检查，该变量可在全局和会话范围内更改。

Tip

在已经确保数据一致的情况下执行大容量装载时，禁用外键检查会很有用。

InnoDB 不能禁用唯一键约束检查，因为`unique_checks`选项仅指示不需要检查；InnoDB 在某些情况下仍然会这样做。(顺便说一下，`NDBCluster`确实将一些约束检查推迟到提交时。)

### 隔离

隔离属性是连接事务和锁定的纽带。两个事务是独立的，这意味着它们不会干扰彼此的数据视图。隔离是在数据内容级别；两个并发事务在性能和锁定方面仍然可能相互干扰。与大多数数据库系统一样，MySQL 使用锁来实现隔离，InnoDB 有事务隔离级别的概念来定义隔离的含义。下一章将更详细地讨论事务隔离级别。

### 持久性

数据是持久的意味着数据更改不会丢失。在 MySQL 中，这仅适用于提交的数据或准备阶段事务的 XA 事务。InnoDB 通过重做日志和二进制日志(如果启用，这是 MySQL 8 中的默认设置)在本地级别实现持久性，并使用内部 XA 事务来确保两个日志之间的一致性。

Note

XA 事务是一个允许分布式事务的特性，例如，跨两个系统或在 MySQL 内部对 InnoDB 和二进制日志一起提交或回滚进行更改。它通过一个事务管理器和一个或多个资源管理器(例如，一个数据库)来工作。有关 MySQL 和 XA 事务的更多信息，请参见 [`https://dev.mysql.com/doc/refman/en/xa.html`](https://dev.mysql.com/doc/refman/en/xa.html) 。

只有当`innodb_flush_log_at_trx_commit`和`sync_binlog`都设置为 1(默认值)时，提交才保证是持久的。为了确保本地系统崩溃时的持久性，您还必须确保二进制日志事件已经复制到至少一个副本。MySQL 组复制或 MySQL InnoDB 集群是实现这一点的最佳方式。

Tip

复制超出了本书的范围。关于 MySQL 组复制和 InnoDB 集群的介绍，参见，例如，查尔斯·贝尔(Apress)的*介绍 InnoDB 集群*([`https://www.apress.com/gp/book/9781484238844`](https://www.apress.com/gp/book/9781484238844))。

## 事务的影响

如果您将事务视为用于分组查询的容器，那么事务可能看起来是一个简单的概念。然而，重要的是要理解，因为事务为查询组提供原子性，所以事务活动的时间越长，与查询相关联的资源被占用的时间就越长，并且事务中完成的工作越多，需要的资源就越多。提交事务之前一直在使用的查询使用了哪些资源？主要的两个是锁和撤销日志。

Tip

InnoDB 支持比读写事务开销更低的只读事务。对于自动提交的单语句事务，InnoDB 将尝试自动确定该语句是否是只读的。对于多语句事务，可以在启动时明确指定它是只读事务:`START TRANSACTION READ ONLY;`

### 锁

当查询执行时，它获取锁，并且当您使用默认的事务隔离级别–`REPEATABLE READ`时，所有锁都被保留，直到事务被提交或回滚。当您使用`READ COMMITTED`事务隔离级别时，一些锁可能会被释放，但至少那些涉及已更改记录的锁会被保留。锁本身就是一种资源，但是它也需要内存来存储关于锁的信息。对于正常的工作负载来说，您可能不认为这有什么了不起，但是巨大的事务最终会使用如此多的内存，以至于事务失败，并出现`ER_LOCK_TABLE_FULL`错误:

```sql
ERROR: 1206: The total number of locks exceeds the lock table size

```

从错误日志中记录的警告消息可以看出(更简短地说)，锁所需的内存来自缓冲池。因此，持有的锁越多、时间越长，可用于缓存数据和索引的内存就越少。

Caution

因为使用了所有的锁内存而中止一个事务是四重打击。首先，更新足够多的行以使用足够多的锁内存来触发错误需要一些时间。那项工作被浪费了。第二，由于所需更改的数量，回滚事务可能需要很长时间。第三，当锁内存被使用时，InnoDB 实际上处于只读模式(一些小的事务是可能的)，并且直到回滚完成后锁内存才被释放。第四，缓冲池中几乎没有空间来缓存数据和索引。

该错误之前，错误日志中有一条警告，指出超过 67%的缓冲池用于锁或自适应哈希索引:

```sql
2020-06-08T10:47:11.415127Z 10 [Warning] [MY-011958] [InnoDB] Over 67 percent of the buffer pool is occupied by lock heaps or the adaptive hash index! Check that your transactions do not set too many row locks. Your buffer pool size is 7 MB. Maybe you should make the buffer pool bigger? Starting the InnoDB Monitor to print diagnostics, including lock heap and hash index sizes.

```

该警告之后是 InnoDB monitor 的定期重复输出，因此您可以确定哪些事务是罪魁祸首。

一种在事务中经常被忽略的锁类型是元数据锁。当一个语句查询一个表时，会获取一个共享的元数据锁，并且该元数据锁会一直保持到事务结束。当一个表上有一个元数据锁时，任何连接都不能对该表执行任何 DDL 语句——包括`OPTIMIZE TABLE`。如果一个 DDL 语句被一个长时间运行的事务阻塞，它将依次阻塞所有使用该表的新查询。第 14 章将展示一个调查此类问题的例子。

当事务处于活动状态时，锁被持有。但是，即使事务已经通过撤消日志完成，它仍然会产生影响。

### 撤消日志

如果您选择回滚事务，则还必须根据需要存储事务期间所做的更改。这很容易理解。更令人惊讶的是，即使一个事务没有进行任何更改，也会使来自其他事务的撤销信息保留下来。当事务需要读视图(一致快照)时会发生这种情况，当使用`REPEATABLE READ`事务隔离级别时，在事务持续期间就是这种情况。读取视图意味着无论其他事务是否更改数据，事务都将返回与事务开始时间相对应的行数据。为了能够实现这一点，有必要保留在事务生命周期中发生变化的行的旧值。具有读视图的长时间运行的事务是导致大量撤销日志的最常见原因，在 MySQL 5.7 和更早的版本中，这可能意味着 ibdata1 文件变得很大。(在 MySQL 8 中，撤消日志总是存储在单独的可以被截断的撤消表空间中。)

Tip

`READ COMMITTED`事务隔离级别不太容易出现大的撤销日志，因为读取视图只在语句持续期间维护。

撤消日志的活动部分的大小在历史列表长度中测量。历史列表长度是尚未清除撤消日志的已提交事务的数量。这意味着您不能使用历史列表长度来衡量行更改的总量。它告诉您的是在执行查询时必须考虑的变更链表中有多少个旧行单元(每个事务一个单元)。这个链表越长，找到每一行的正确版本的代价就越大。最后，如果您有一个很大的历史列表，它会严重影响所有查询的性能。

Note

历史列表长度的问题是使用逻辑备份工具创建大型数据库备份的最大问题之一，例如使用单个事务获得一致备份的`mysqlpump`和`mysqldump`。如果在备份过程中提交了许多事务，备份可能会导致历史列表变得非常长。

什么构成了一个大的历史列表长度？这方面没有严格的规则，只是越小越好。通常，当列表有几千到一百万个事务时，性能问题就开始出现了，但是当历史列表很长时，它成为瓶颈的点取决于撤消日志中提交的事务和工作负载。

当不再需要最旧的部件时，InnoDB 会在后台自动清除历史列表。有两个选项可以控制清洗，也有两个选项可以影响清洗无法进行时会发生什么。这些选项包括

*   `innodb_purge_batch_size` **:** 每批清除的撤消日志页数。该批次在清除线程之间划分。该选项不应在生产系统上更改。默认值为 300，有效值介于 1 和 5000 之间。

*   `innodb_purge_threads` **:** 并行使用的清除线程数。如果数据更改跨越多个表，那么更高的并行度会很有用。另一方面，如果所有更改都集中在少数几个表上，则首选低值。更改清除线程的数量需要重启 MySQL。默认值为 4，有效值介于 1 和 32 之间。

*   `innodb_max_purge_lag` **:** 当历史列表长度大于`innodb_max_purge_lag`的值时，会给更改数据的操作增加一个延迟，以降低历史列表的增长速度，但代价是语句延迟增加。默认值为 0，这意味着永远不会添加延迟。有效值为 0–4294967295。

*   `innodb_max_purge_lag_delay` **:** 当历史列表长度大于`innodb_max_purge_lag`时，可以添加到 DML 查询的最大延迟。

通常没有必要更改这些设置；但是，在特殊情况下，它可能是有用的。如果清除线程跟不上，您可以尝试根据被修改的表的数量来更改清除线程的数量；修改的表越多，清除线程就越有用。当您更改清除线程的数量时，从更改前的基线开始监控效果非常重要，这样您就可以看到更改是否带来了改进。

最大清除延迟选项可用于降低修改数据的 DML 语句的速度。当写入仅限于特定的连接，并且延迟不会导致创建额外的写入线程以保持相同的吞吐量时，此功能非常有用。

## 群组提交

请记住，为了使 InnoDB 中的 D in ACID(耐久性)为真，您需要将`innodb_flush_log_at_trx_commit`和`sync_binlog`设置保持为默认值 1，以便事务所做的更改作为提交的一部分被同步到磁盘。虽然这对于确保您在崩溃时不会丢失已确认提交的更改非常有用，但从成本效益的角度来看，这确实是有代价的，因为磁盘的刷新性能常常会成为瓶颈。

存在组提交功能是为了减少这种性能影响，方法是稍微延迟提交，并对延迟期间发生的所有提交(即名称)进行分组，同时将它们刷新到磁盘。本质上，组提交牺牲了一点延迟来获得更高的吞吐量。在数据更改具有高并发性的系统中，当使用`sync_binlog = 1`时，组提交可以极大地提高性能。

使用两个配置选项来控制组提交功能:

*   `binlog_group_commit_sync_delay` **:** 等待更多事务提交的延迟时间(毫秒)。允许的值为 0–1000000，默认值为 0。值越大，一起提交的事务就越多，因此`fsync()`调用就越少。

*   `binlog_group_commit_sync_no_delay_count` **:** 在完成组提交之前，组提交队列中允许的最大事务数。如果该选项设置为大于 0 的值，提交的次数可能会比`binlog_group_commit_sync_delay`设置的次数更多。值为 0 意味着可以对无限数量的提交进行排队。允许的值为 0–1000000，默认值为 0。

如果您可以接受提交事务时的小延迟，建议增加`binlog_group_commit_sync_delay`以降低刷新速率。原则上，该值越大，吞吐量就越大，但是您当然应该考虑您的工作负载的最大可接受的提交延迟增加量。您可以使用`binlog_group_commit_sync_no_delay_count`来避免每个组提交中的事务数量变得过大。

如果您启用了复制，那么增加`binlog_group_commit_sync_delay`也会对副本产生积极的性能影响，因为一起提交的事务越多，用于并行复制的`LOGICAL_CLOCK`算法(`slave_parallel_type`选项)就变得越有效。(如果有`binlog_transaction_dependency_tracking = WRITESET`，效果会小一些，因为事务可以跨组提交并行化。)您必须在复制源上设置`binlog_group_commit_sync_delay`，以提高副本上的并行复制性能。

## 摘要

事务是数据库中的一个重要概念。它们有助于确保您可以将更改作为一个单元应用到几行，并且可以选择是应用更改还是回滚更改。

本章开始讨论什么是事务和 ACID 概念。ACID 代表原子性、一致性、隔离性和持久性，事务直接参与确保前三个属性，部分代表持久性。在并发环境中，隔离很有意思，因为它可以确保您可以安全地并发执行多个事务。在 MySQL 中，隔离是通过锁定实现的。

下一节将讨论为什么了解事务是如何被使用的很重要。虽然它们本身可以被认为是更改的容器，但锁会一直保持到事务被提交或回滚，并且它们可以阻止撤消日志被清除。锁和大量撤消日志都会影响查询的性能，即使它们不是在导致大量锁或大量撤消日志的事务中执行的。锁使用来自缓冲池的内存，因此可用于缓存数据和索引的内存较少。根据历史列表长度来衡量，大量的撤销日志意味着在 InnoDB 执行语句时必须考虑更多的行版本。

最后，讨论了组提交的概念。当在每次提交时将更改刷新到磁盘时，可以使用组提交特性通过一起完成几次提交来减少`fsync()`调用的数量。组复制的一个好的副作用是它可以提高并行复制的`LOGICAL_CLOCK`算法的性能。

在本章中，我们多次提到了事务隔离级别的概念。下一章将更详细地介绍四个受支持的事务隔离级别是如何工作的，以及每个级别如何影响锁定。