# 十一、MongoDB 中的备份和恢复

概述

在本章中，我们将详细研究如何将备份、示例和测试数据库加载到目标 MongoDB 实例中，同样重要的是，您将了解如何导出现有数据集以便在以后进行备份和恢复。在本章结束时，您将能够备份、导出、导入 MongoDB 数据，并将其恢复到现有服务器中。这允许您从灾难中恢复数据，并将已知信息快速加载到系统中进行测试。

# 导言

在前面的章节中，我们主要依赖于预加载到 MongoDB Atlas 实例中的示例数据。除非您正在处理一个新项目，否则这通常是数据库第一次出现在您面前的方式。但是，当您被雇佣或转移到另一个使用 MongoDB 数据库的项目时，它将包含在您开始之前创建的所有数据。

现在，如果您需要此数据的本地副本来测试您的应用程序或查询，该怎么办？直接对生产数据库运行查询通常不安全或不可行，因此将数据集复制到测试环境的过程非常常见。类似地，在创建新项目时，您可能希望将一些示例数据或测试数据加载到数据库中。在本章中，我们将研究迁移、导入或导出现有 MongoDB 服务器以及使用现有数据建立新数据库的过程。

笔记

在本章中，包含的练习和活动都是针对单个场景的迭代。数据和示例基于名为**sample_mflix**的 MongoDB Atlas 样本数据库。

在本章期间，我们将根据理论情景进行一系列练习。这是对*第 7 章*、*数据聚合*和*第 8 章*、*在 MongoDB*中编码 JavaScript 的场景的扩展。您可能还记得，一家电影院连锁店要求您创建查询和程序，以分析他们的数据库，生成在促销季节上映的电影列表。

在这些章节的过程中，您构建了一些聚合，其输出是包含摘要数据的新集合。您还创建了一个应用程序，允许用户以编程方式更新电影。公司对您的工作非常满意，他们决定将整个系统迁移到更重要、更好的硬件上。尽管系统管理员认为他们有信心将现有 MongoDB 实例迁移到新硬件，但您已决定最好手动测试该过程，以确保在需要时提供帮助。

# MongoDB 公用事业公司

mongo shell 不包括用于导出、导入、备份或还原的功能。然而，MongoDB 已经创建了实现这一点的方法，因此不需要脚本工作或复杂的 GUI。为此，提供了几个工具脚本，可用于批量获取数据库中的数据。这些工具脚本是：

*   **蒙高进口**
*   **mongoexport**
*   **mongodump**
*   **蒙哥雷斯托雷**

我们将在接下来的章节中详细介绍这些工具。顾名思义，这四个工具对应于导入文档、导出文档、备份数据库和恢复数据库。我们将从导出数据的主题开始。

# 导出 MongoDB 数据

当涉及到批量进出 MongoDB 的数据时，最常见和最常用的实用工具是**mongoexport**。此命令非常有用，因为它是以可用格式从 MongoDB 提取大量数据的主要方法之一。将 MongoDB 数据输出到 JSON 文件中，可以将其与其他应用程序或数据库一起接收，并与 MongoDB 之外的利益相关者共享数据。

需要注意的是，**mongoexport**必须在单个指定的数据库和集合上运行。您不能在整个数据库或多个集合上运行**mongoexport**。我们将在本章后面看到如何完成类似这些更大范围的备份。下面的代码片段是正在运行的**mongoexport**示例：

```js
mongoexport --uri=mongodb+srv://USERNAME:PASSWORD@provendocs-fawxo.gcp.mongodb.net/sample_mflix –quiet --limit=10 --sort="{theaterId:1}" --collection=theaters --out=output.json
```

本例是一个更复杂的命令，它包含一些可选参数，并显式设置其他参数。但在实践中，导出命令可能要简单得多。下文将详细说明此处使用的结构和参数。

## 使用 mongoexport

学习**mongoexport**语法的最好方法是逐个参数建立命令参数。让我们从导出的最简单版本开始：

```js
mongoexport –-collection=theaters
```

如您所见，在最简单的形式中，该命令只需要一个参数：**–-collection**。此参数是我们希望导出文档的集合。

如果执行此命令，可能会遇到一些令人费解的结果，如下所示：

```js
2020-03-07-T13:16:09.152+1100 error connecting to db server: no reachable servers
```

我们得到这个结果是因为我们没有指定数据库或 URI。在这种情况下，如果未指定这些详细信息，**mongoexport**默认使用端口 27017 上的本地 MongoDB 和默认数据库。由于在前一章的示例和练习中，我们一直在 Atlas 上运行 MongoDB 服务器，所以让我们更新命令以指定这些参数。

笔记

不能同时指定数据库和 URI；这是因为数据库是 URI 的一部分。在本章中，我们将使用 URI 进行导出。

更新后的命令如下所示：

```js
mongoexport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlasServer.gcp.mongodb.net/sample_mflix --collection=theaters
```

现在您已经有了一个有效的命令，请在 MongoDB Atlas 数据库上运行它。您将看到以下输出：

```js
2020-08-17T11:07:23.302+1000    connected to: mongodb+srv://[**REDACTED**]@performancetuning.98afc.gcp.mongodb.net/sample_mflix
{"_id":{"$oid":"59a47286cfa9a3a73e51e72c"},"theaterId":1000,"location":  {"address":{"street1":"340 W Market","city":"Bloomington","state":"MN","zipcode":"55425"},"geo":  {"type":"Point","coordinates":[-93.24565,44.85466]}}}
{"_id":{"$oid":"59a47286cfa9a3a73e51e72d"},"theaterId":1003,"location":  {"address":{"street1":"45235 Worth Ave.","city":"California","state":"MD","zipcode":"20619"},"geo":  {"type":"Point","coordinates":[-76.512016,38.29697]}}}
{"_id":{"$oid":"59a47286cfa9a3a73e51e72e"},"theaterId":1008,"location":  {"address":{"street1":"1621 E Monte Vista Ave","city":"Vacaville","state":"CA","zipcode":"95688"},"geo":  {"type":"Point","coordinates":[-121.96328,38.367649]}}}
{"_id":{"$oid":"59a47286cfa9a3a73e51e72f"},"theaterId":1004,"location":  {"address":{"street1":"5072 Pinnacle Sq","city":"Birmingham","state":"AL","zipcode":"35235"},"geo":  {"type":"Point","coordinates":[-86.642662,33.605438]}}}
```

在输出的末尾，您应该看到导出记录的数量：

```js
{"_id":{"$oid":"59a47287cfa9a3a73e51ed46"},"theaterId":952,"location":  {"address":{"street1":"4620 Garth Rd","city":"Baytown","state":"TX","zipcode":"77521"},"geo":  {"type":"Point","coordinates":[-94.97554,29.774206]}}}
{"_id":{"$oid":"59a47287cfa9a3a73e51ed47"},"theaterId":953,"location":  {"address":{"street1":"10 McKenna Rd","city":"Arden","state":"NC","zipcode":"28704"},"geo":  {"type":"Point","coordinates":[-82.536293,35.442486]}}}
2020-08-17T11:07:24.992+1000    [########################]  sample_mflix.theaters  1564/1564  (100.0%)
2020-08-17T11:07:24.992+1000    exported 1564 records
```

指定了 URI 后，导出操作开始工作，您可以看到**剧院**收藏中的所有文档。但是，让所有这些文档充斥您的输出并不是很有用。您可以使用一些 shell 命令将此输出管道化或附加到文件中，但是，**mongoexport**命令在其语法中提供了另一个参数，用于自动输出到文件。您可以在以下命令中看到此参数（**--out**）：

```js
mongoexport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlasServer.gcp.mongodb.net/sample_mflix --collection=theaters --out=output.json
```

运行此命令后，您将看到以下输出：

```js
2020-08-17T11:11:44.499+1000    connected to: mongodb+srv://[**REDACTED**]@performancetuning.98afc.gcp.mongodb.net/sample_mflix
2020-08-17T11:11:45.634+1000    [........................]  sample_mflix.theaters  0/1564  (0.0%)
2020-08-17T11:11:45.694+1000    [########################]  sample_mflix.theaters  1564/1564  (100.0%)
2020-08-17T11:11:45.694+1000    exported 1564 records
```

现在，在该目录中创建了一个名为**output.json**的新文件。如果您查看此文件，您可以看到我们从剧院集合导出的文档。

参数**uri**、**collection**和**out**支持导出大多数用例。一旦将数据保存在磁盘上的文件中，就可以轻松地将其与其他应用程序或脚本集成。

## mongoexport 选项

我们现在知道了**mongoexport**最重要的三个选项。但是，还有一些其他有用的选项有助于从 MongoDB 导出数据。以下是一些选项及其效果：

*   **--quiet**：此选项减少导出期间发送到命令行的输出量。
*   **——键入**：这将影响文档在控制台中的打印方式，默认为 JSON。例如，您可以通过指定 CSV 以**逗号分隔值**（**CSV**格式）导出数据。
*   **--pretty**：以良好的格式输出文档。
*   **——字段**：指定要导出的文档中以逗号分隔的键列表，类似于导出级投影。
*   **——跳过**：类似于查询级跳过，在导出时跳过单据。
*   **——排序**：其工作原理类似于查询级排序，通过一些键对文档进行排序。
*   **——限制**：类似于查询级限制，限制输出的文档数量。

下面是一个使用了其中一些选项的示例，在本例中，将十个**剧院**文档（按 id 排序）输出到名为**output.json**的文件中。此外，还使用了**--quiet**参数：

```js
mongoexport --uri=mongodb+srv://USERNAME:PASSWORD@provendocs-fawxo.gcp.mongodb.net/sample_mflix --quiet --limit=10 --sort="{theaterId:1}" --collection=theaters --out=output.json
```

因为我们已经使用了**--quiet**选项，所以根本看不到任何输出。

```js
> mongoexport --uri=mongodb+srv://testUser:testPassword@performancet uning.98afc.gcp.mongodb.net/sample_mflix --quiet --limit=10 --sort="{theaterId:1}" --collection=theaters --out=output.json
>
```

但是，如果我们查看**output.json**文件，我们可以看到按 ID 排序的十个文档：

![Figure 11.1: Contents of output.json file (truncated) ](img/B15507_11_01.jpg)

图 11.1:output.json 文件的内容（截断）

还有一个选项可以用于更高级的导出，那就是查询选项。查询选项允许您使用与标准 MongoDB 查询相同的格式指定查询。将仅导出与此查询匹配的文档。将此选项与其他选项（如--fields、**--skip**和**--limit**）结合使用，可以使用格式化输出定义完整的查询，然后将其导出到文件中。

以下是使用查询选项返回特定文档子集的导出。在这种情况下，我们得到的所有电影院都有一个**主题**的**4**。

```js
mongoexport --uri=mongodb+srv://USERNAME:PASSWORD@provendocs-fawxo.gcp.mongodb.net/sample_mflix --query="{theaterId: 4}" --collection=theaters
```

笔记

在 MacOS 上，您可能需要将**TheateId**用引号括起来，例如：**--query=“{\'TheateId\'：4}”**

现在，我们将看到我们正在寻找的文档，如下所示：

```js
2020-08-17T11:22:48.559+1000    connected to: mongodb+srv://[**REDACTED**]@performancetuning.98afc.gcp.mongodb.net/sample_mflix
{"_id":{"$oid":"59a47287cfa9a3a73e51eb78"},"theaterId":4,"location":  {"address":{"street1":"13513 Ridgedale Dr","city":"Hopkins","state":"MN","zipcode":"55305"},"geo":  {"type":"Point","coordinates":[-93.449539,44.969658]}}}
2020-08-17T11:22:48.893+1000    exported 1 record
```

让我们在下一个练习中使用这些选项。

## 练习 11.01：导出 MongoDB 数据

在开始本练习之前，让我们从*简介*一节中概述的场景重新审视电影公司。假设你的客户（电影公司）要迁移他们现有的数据，你担心有价值的信息会丢失。您决定首先要做的事情之一是将数据库中的文档导出为 JSON 文件，在发生灾难时，这些文件可以存储在廉价的云存储中。此外，您将为每个电影类别创建不同的导出。

笔记

为了展示对**mongoexport**的了解，我们不会为每个类别创建导出，而只是为单个类别创建导出。您还将仅导出前三个文档。

在本练习中，您将使用**mongoexport**创建一个名为**action_movies.json**的文件，其中包含三部动作片，按发行年份排序。以下步骤将帮助您完成任务：

1.  微调导出并将其保存以备将来使用。创建一个名为**Exercise11.01.txt**的新文件来存储导出命令。
2.  接下来，键入标准的**mongoexport**语法，其中只包含 URI 和**电影**集合：

    ```js
    mongoexport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/sample_mflix --collection=movies
    ```

3.  添加额外的参数以满足您的条件。首先，将导出输出到名为**action_movies.json**的文件中。使用**--out**参数如下：

    ```js
    mongoexport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/sample_mflix --collection=movies --out=action_movies.json
    ```

4.  接下来，根据本练习的规范，添加排序条件以按发行年份对电影进行排序。您可以使用**——排序**：

    ```js
    mongoexport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/sample_mflix --collection=movies --out=action_movies.json --sort='{released: 1}'
    ```

    来完成此操作
5.  If you were to run this command at its current intermediary stage, you would encounter the following error:

    ```js
    2020-08-17T11:25:51.911+1000    connected to: mongodb+srv://[**REDACTED**]@performancetuning.98afc.gcp.mongodb.net/sample_mflix
    2020-08-17T11:25:52.581+1000    Failed: (OperationFailed) Executor error during find command :: caused by :: Sort operation used more than the maximum 33554432 bytes of RAM. Add an index, or specify a smaller limit.
    ```

    这是因为 MongoDB 服务器正在尝试为我们排序大量文档。为了提高导出和导入的性能，可以限制检索的文档数量，这样 MongoDB 就不必为您排序这么多文档。

6.  Add a **--limit** parameter to reduce the number of documents being sorted and satisfy the three-document condition:

    ```js
    mongoexport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/sample_mflix --collection=movies --out=action_movies.json --sort='{released: 1}' --limit=3
    ```

    最后，您需要添加查询参数以过滤掉任何不属于电影类型的文档。

    笔记

    根据您的操作系统和 shell，您可能必须修改单引号和双引号，以确保引号中的值不会干扰 shell。例如，当对字符串使用查询时，可能必须在筛选文档周围使用双引号，在值周围使用单引号。对于命令提示符用户，请尝试使用反斜杠字符转义双引号，例如，**query=“{\'genres\'：\'Action\'}”**

    查询如下：

    ```js
    mongoexport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/sample_mflix --collection=movies --out=action_movies.json --sort='{released : 1}' --limit=3 --query="{'genres': 'Action'}"
    ```

    笔记

    在 MacOS 和 Linux 上，您可能需要更改参数中字符串周围的引号，例如，在前面的查询中，您需要使用：**--query='{“流派”：“操作”}'**

7.  With your command complete, copy it from your **Exercise11.01.txt** file into your terminal or command prompt to run it:

    ```js
    2020-08-18T12:35:42.514+1000    connected to: mongodb+srv://[**REDACTED**]@performancetuning.98afc.gcp.mongodb.net/sample_mflix
    2020-08-18T12:35:42.906+1000    exported 3 records
    ```

    到目前为止，输出看起来不错，但是您需要检查输出文件以确保导出了正确的文档。在刚刚执行命令的目录中，您应该会看到新文件**action_movies.json**。打开此文件并查看其中的内容。

    笔记

    删除绘图字段以提高输出的清晰度。

    您应该看到以下文档：

    ![Figure 11.2: Contents of the action_movies.json file (truncated for brevity) ](img/B15507_11_02.jpg)

图 11.2:action_movies.json 文件的内容（为简洁起见被截断）

本练习演示了以健壮灵活的方式从 MongoDB 导出文档所需的基础知识。结合这里学到的参数，大多数基本导出现在都很容易。要掌握 MongoDB 中的数据导出，不断尝试和学习是很有帮助的。

# 将数据导入 MongoDB

现在，您知道了如何将收集的数据从 MongoDB 中取出，并转换为磁盘上易于使用的格式。但是假设您在磁盘上有这个文件，并且您想与拥有自己 MongoDB 数据库的人共享它？这种情况下，**mongoimport**就派上了用场。您可能已经从名称中猜到，该命令本质上与**mongoexport**相反，其设计目的是将**mongoexport**的输出作为**mongoimport**的输入。

但是，您可以与**mongoimport**一起使用的不仅仅是从 MongoDB 导出的数据。该命令支持 JSON、CSV 和 TSV 格式，这意味着从其他应用程序提取或手动创建的数据仍然可以使用**mongoimport**轻松添加到数据库中。通过支持这些广泛使用的文件格式，该命令成为将批量数据加载到 MongoDB 的通用方法。

与**mongoexport**一样，**mongoimport**在指定数据库内的单个目标集合上运行。这意味着，如果希望将数据导入多个集合，则必须将数据分离到各个文件中。

以下是一个复杂的**mongoimport**示例。我们将在下一节详细介绍语法。

```js
mongoimport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/imports  --collection=oldData --file=old.csv --type=CSV --headerline --ignoreBlanks --drop
```

## 使用 mongoimport

以下是一个参数可能最少的**mongoimport**命令。这比前面的命令要简单得多。

```js
mongoimport --db=imports --collection=contacts --file=contacts.json
```

这个例子看起来也应该与我们在上一节中看到的一些代码片段非常相似。它几乎与我们的**mongoexport**语法相同，只是我们没有提供使用**--out**创建新文件的位置，而是输入了一个**--file**参数，该参数指定了我们希望加载的数据。我们的数据库和集合参数的语法与**mongoexport**示例中的语法相同。

正如您可能已经猜到的，**mongoimport**与**mongoexport**的另一个相似之处是，默认情况下，它将运行在本地机器上运行的 MongoDB 数据库上。我们使用相同的**--uri**参数来指定我们正在将数据加载到远程 MongoDB 服务器中，在本例中，在 MongoDB Atlas 上。

笔记

与**mongoexport**一样，**db**和**uri**参数是互斥的，因为数据库是在**uri**本身中定义的。

使用**--uri**参数时，**mongoimport**命令如下：

```js
mongoimport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlasServer-fawxo.gcp.mongodb.net/imports --collection=contacts --file=contacts.json
```

在对 MongoDB 数据库执行此命令并导入之前，需要一个包含有效数据的文件。现在让我们创建一个。创建可导入数据的最简单方法之一是运行**mongoexport**。但是，为了提高您导入文件的知识，我们将从头开始创建一个。

首先创建一个名为**contacts.json**的文件。在文本编辑器中打开文件并创建一些非常简单的文档。导入 JSON 文件时，文件中的每一行必须包含一个文档。

**contacts.json**文件应如下所示：

```js
//contacts.json
{"name": "Aragorn","location": "New Zealand","job": "Park Ranger"}
{"name": "Frodo","location": "New Zealand","job": "Unemployed"}
{"name": "Ned Kelly","location": "Australia","job": "Outlaw"}
```

执行以下导入：

```js
mongoimport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlasServer-fawxo.gcp.mongodb.net/imports --collection=contacts --file=contacts.json
```

这将产生以下输出：

```js
2020-08-17T20:10:38.892+1000    connected to: mongodb+srv://[**REDACTED**]@performancetuning.98afc.g
cp.mongodb.net/imports
2020-08-17T20:10:39.150+1000    3 document(s) imported successfully. 0 document(s) failed to import. 
```

您还可以对文件使用 JSON 数组格式，这意味着您的导入文件包含许多不同 JSON 文档的数组。在这种情况下，必须在命令中指定**--jsonArray**选项。到目前为止，您应该非常熟悉这个 JSON 数组结构，因为它既匹配**mongoexport**输出，也匹配您从 MongoDB 查询中收到的结果。例如，如果文件包含如下数组：

```js
[
    {
        "name": "Aragorn",
        "location": "New Zealand",
        "job": "Park Ranger"
    },
    {
        "name": "Frodo",
        "location": "New Zealand",
        "job": "Unemployed"
    },
    {
        "name": "Ned Kelly",
        "location": "Australia",
        "job": "Outlaw"
    }
]
```

您仍然可以使用带有**--jsonArray**选项的**mongoimport**命令导入文件，如下所示：

```js
mongoimport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlasServer-fawxo.gcp.mongodb.net/imports --collection=contacts --file=contacts.json --jsonArray
```

这将产生以下输出：

```js
2020-08-17T20:10:38.892+1000    connected to: mongodb+srv://[**REDACTED**]@performancetuning.98afc.g
cp.mongodb.net/imports
2020-08-17T20:10:39.150+1000    3 document(s) imported successfully. 0 document(s) failed to import. 
```

笔记

在前面的示例中，您会注意到，您可以为导入中的文档提供**\U id**值。如果没有提供**标识，则会为单据生成一个。您必须确保您提供的**id**未被使用；否则，**mongoimport**命令将抛出错误。**

 **这两个导入向我们展示了将数据导入 MongoDB 数据库的简单方法，但让我们看看出现问题时会发生什么。让我们修改我们的文件，为我们的一些文档指定**id**。

```js
[
    {
        "_id": 1,
        "name": "Aragorn",
        "location": "New Zealand",
        "job": "Park Ranger"
    },
    {
        "name": "Frodo",
        "location": "New Zealand",
        "job": "Unemployed"
    },
    {
        "_id": 2,
        "name": "Ned Kelly",
        "location": "Australia",
        "job": "Outlaw"
    }
]
```

执行一次，您应该会得到一个没有错误的输出。

```js
mongoimport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlasServer-fawxo.gcp.mongodb.net/imports --collection=contacts --file=contacts.json --jsonArray
```

您将看到以下输出：

```js
2020-08-17T20:12:12.164+1000    connected to: mongodb+srv://[**REDACTED**]@performancetuning.98afc.g
cp.mongodb.net/imports
2020-08-17T20:12:12.404+1000    3 document(s) imported successfully. 0 document(s) failed to import.
```

现在，如果您重新运行相同的命令，您会看到一个错误，因为您的集合中已经存在**\U id**值。

```js
2020-08-17T20:12:29.742+1000    connected to: mongodb+srv://[**REDACTED**]@performancetuning.98afc.g
cp.mongodb.net/imports
2020-08-17T20:12:29.979+1000    continuing through error: E11000 duplicate key error collection: imp
orts.contacts index: _id_ dup key: { _id: 1 }
2020-08-17T20:12:29.979+1000    continuing through error: E11000 duplicate key error collection: imp
orts.contacts index: _id_ dup key: { _id: 2 }
2020-08-17T20:12:29.979+1000    1 document(s) imported successfully. 2 document(s) failed to import.
```

您可以在输出中看到错误。您可能会注意到的另一件事是，没有问题的文档仍然成功导入。如果您要导入一万个文档文件，mongoimport 不会在单个文档上失败。

假设您确实希望更新此文档，但不更改其**\U id**。您无法使用此**mongoimport**命令，因为每次都会收到重复的密钥错误。

您可以使用 MongoShell 登录 MongoDB，并在导入之前手动删除此文档，但这将是一种缓慢的方式。使用**mongoimport**，我们可以使用--drop 选项在导入之前删除集合。这是确保文件中存在的内容在集合中存在的好方法。

例如，考虑到在我们的导入之前，在我们的集合中有下列文件：

```js
MongoDB Enterprise PerformanceTuning-shard-0:PRIMARY> db.contacts.find({})
{ "_id" : ObjectId("5e0c1db3fa8335898940129ca8"), "name": "John Smith"}
{ "_id" : ObjectId("5e0c1db3fa8335898940129ca8"), "name": "Jane Doe"}
{ "_id" : ObjectId("5e0c1db3fa8335898940129ca8"), "name": "May Sue"}
```

现在，使用**——drop**运行以下**mongoimport**命令：

```js
mongoimport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlasServer-fawxo.gcp.mongodb.net/imports --collection=contacts –-file=contacts.json --jsonArray --drop
2020-08-17T20:16:08.280+1000    connected to: mongodb+srv://[**REDACTED**]@performancetuning.98afc.g
cp.mongodb.net/imports
2020-08-17T20:16:08.394+1000    dropping: imports.contacts
2020-08-17T20:16:08.670+1000    3 document(s) imported successfully. 0 document(s) failed to import.  
```

执行命令后，您将看到集合中有以下文档，请使用 find 命令查看这些文档。

```js
db.contacts.find({})
```

您应该看到以下输出：

```js
{ "_id" : ObjectId("5f3a58e8fd0803fc3dec8cbf"), "name" : "Frodo", "location" : "New Zealand", "job" : "Unemployed" }
{ "_id" : 1, "name" : "Aragorn", "location" : "New Zealand", "job" : "Park Ranger" }
{ "_id" : 2, "name" : "Ned Kelly", "location" : "Australia", "job" : "Outlaw" }
```

在下一节中，我们将研究可用于**mongoimport**的选项。

## mongoimport 选项

我们现在了解了需要使用**mongoimport**和**--uri**、**--collection**和**--file**参数的基本选项。但是，与上一节中的**mongoexport**一样，您可能希望在运行该命令时使用几个附加选项。其中许多选项与**mongoexport**中的选项相同。下面的列表描述了一些选项及其效果。

*   **——安静**：这减少了导入的输出消息量。
*   **--drop**：在开始导入之前，此操作会删除集合。
*   **--jsonArray**：仅为 JSON 类型，用于指定文件是否为 JSON 数组格式。
*   **——类型**：可以是 JSON、CSV 或 TSV 来指定要导入的文件类型，但默认类型是 JSON。
*   **--仅忽略**TSV 和 CSV，这将忽略导入文件中的空字段。
*   **--标题行**：仅限 TSV 和 CSV，这将假定导入文件的第一行是字段名列表。
*   **--字段**：仅限 TSV 和 CSV，这将在您的文档中为 CSV 和 TSV 格式指定以逗号分隔的密钥列表。只有在没有标题行时才需要此选项。
*   **--stopOnError**：如果指定，导入将在遇到第一个错误时停止。

下面是一个具体使用了更多这些选项的示例，即带有标题行的 CSV 导入。我们还必须忽略空白，这样文档就不会被赋予空白的**\U id**值。

这是我们的**.csv**文件，名为**contacts.csv**：

```js
_id,name,location,job
1,Aragorn,New Zealand,Park Ranger
,Frodo,New Zealand,Unemployed
2,Ned Kelly,Australia,Outlaw
```

我们将使用以下命令导入 CSV：

```js
mongoimport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlasServer-fawxo.gcp.mongodb.net/imports --collection=contacts --file=contacts.csv --drop --type=CSV --headerline --ignoreBlanks
2020-08-17T20:22:39.750+1000    connected to: mongodb+srv://[**REDACTED**]@performancetuning.98afc.gcp.mongodb.net/imports
2020-08-17T20:22:39.863+1000    dropping: imports.contacts
2020-08-17T20:22:40.132+1000    3 document(s) imported successfully. 0 document(s) failed to import.
```

前面的命令将在我们的集合中生成以下文档：

```js
MongoDB Enterprise atlas-nb3biv-shard-0:PRIMARY> db.contacts.find({})
{ "_id" : 2, "name" : "Ned Kelly", "location" : "Australia", "job" : "Outlaw" }
{ "_id" : 1, "name" : "Aragorn", "location" : "New Zealand", "job" : "Park Ranger" }
{ "_id" : ObjectId("5f3a5a6fc67ba81a6d4bcf69"), "name" : "Frodo", "location" : "New Zealand", "job" : "Unemployed" }
```

当然，这些只是您可能遇到的一些更常见的选项。文档中提供了完整的列表。在需要对不同配置的 MongoDB 服务器运行更高级的导入时，熟悉这些是非常有用的。

## 练习 11.02：将数据加载到 MongoDB

在此场景中，您已经成功地在本地计算机上创建了客户端数据的导出。您已在不同版本上设置了新服务器，并希望确保数据正确导入到新配置中。此外，您还收到了来自另一个旧数据库的 CSV 格式的一些数据文件，这些文件将迁移到新的 MongoDB 服务器。您希望确保这种不同的格式也能正确导入。考虑到这一点，您的目标是将两个文件（如下所示）导入 Atlas 数据库，并测试文档是否存在于正确的集合中。

在本练习中，您将使用**mongoimport**将两个文件（**old.csv**和**new.json**导入到两个单独的集合（**oldData**和**newData**中），并使用 drop 确保不存在遗留文档。

可通过执行以下步骤实现此目标：

1.  微调导入并将其保存以备将来使用。创建一个名为**Exercise11.02.txt**的新文件来存储导出命令。
2.  Create your **old.csv** and **new.json** files that contain the data to be imported. Either download the files from GitHub at [https://packt.live/2LsgKS3](https://packt.live/2LsgKS3) or copy the following into identical files in your current directory.

    **old.csv**文件应如下所示：

    ```js
    _id,title,year,genre
    54234,The King of The Bracelets,1999,Fantasy
    6521,Knife Runner,1977,Science Fiction
    124124,Kingzilla,1543,Horror
    64532,Casabianca,1942,Drama
    23214,Skyhog Day,1882,Comedy
    ```

    **new.json**文件应如下所示：

    ```js
    [
        {"_id": 54234,"title": "The King of The Bracelets","year": 1999,"genre": "Fantasy"},
        {"_id": 6521, "title": "Knife Runner","year": 1977,"genre": "Science Fiction"},
        {"_id": 124124,"title": "Kingzilla","year": 1543,"genre": "Horror"},
        {"_id": 64532,"title": "Casabianca","year": 1942,"genre": "Drama"},
        {"_id": 23214,"title": "Skyhog Day","year": 1882,"genre": "Comedy"}
    ]
    ```

3.  在您的**Exercise11.02.txt**文件中输入标准的**mongoimport**语法，其中只包含 URI、集合和文件位置。将您的数据导入**“导入”**数据库，先导入旧数据：

    ```js
    mongoimport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/imports --collection=oldData --file=old.csv
    ```

4.  现在，开始添加额外参数以满足 CSV 文件的条件。指定**类型=CSV**：

    ```js
    mongoimport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/ imports  --collection=oldData --file=old.csv --type=CSV
    ```

5.  接下来，由于旧数据中有一个标题行，请使用**headerline**参数。

    ```js
    mongoimport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/imports  --collection=oldData --file=old.csv --type=CSV --headerline
    ```

6.  当您在本章前面的一些示例中看到 CSV 导入时，**--ignoreBlanks**参数用于确保未导入空字段。这是一个很好的实践，所以也在这里添加它。

    ```js
    mongoimport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/imports  --collection=oldData --file=old.csv --type=CSV --headerline --ignoreBlanks
    ```

7.  最后，对于本练习，您需要确保不在现有数据之上导入，因为这可能会导致冲突。为确保您的数据被干净地导入，请按如下方式使用**--drop**参数：

    ```js
    mongoimport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/imports  --collection=oldData --file=old.csv --type=CSV --headerline --ignoreBlanks --drop
    ```

8.  这应该是 CSV 导入所需的一切。通过将现有命令复制到新行，然后删除 CSV 特定参数，开始编写 JSON 导入。

    ```js
    mongoimport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/imports  --collection=oldData --file=old.csv --drop
    ```

9.  现在，通过将您的**new.json**文件导入**newData**集合，更改**文件**和**集合**参数，如下所示：

    ```js
    mongoimport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/imports  --drop --collection=newData --file=new.json 
    ```

10.  您可以看到您的**new.json**文件中的数据是 json 数组格式的，所以添加匹配参数，如下所示：

    ```js
    mongoimport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/imports --collection=newData --file=new.json --drop --jsonArray
    ```

11.  您现在应该在**Exercise11.02.txt**文件中有以下两个命令。

    ```js
    mongoimport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/imports  --collection=newData --file=new.json --drop --jsonArray
    mongoimport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/imports  --collection=oldData --file=old.csv --type=CSV --headerline --ignoreBlanks --drop
    ```

12.  Run your **newData** import using the following command:

    ```js
    mongoimport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/imports  --collection=newData --file=new.json --drop --jsonArray
    ```

    结果如下：

    ```js
    2020-08-17T20:25:21.622+1000    connected to: mongodb+srv://[**REDACTED**]@performancetuning.98afc.gcp.mongodb.net/imports
    2020-08-17T20:25:21.734+1000    dropping: imports.newData
    2020-08-17T20:25:22.019+1000    5 document(s) imported successfully. 0 document(s) failed to import.
    ```

13.  Now, execute the **oldData** import as follows:

    ```js
    mongoimport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/imports  --collection=oldData --file=old.csv --type=CSV --headerline --ignoreBlanks --drop
    ```

    结果如下：

    ```js
    2020-08-17T20:26:09.588+1000    connected to: mongodb+srv://[**REDACTED**]@performancetuning.98afc.gcp.mongodb.net/imports
    2020-08-17T20:26:09.699+1000    dropping: imports.oldData
    2020-08-17T20:26:09.958+1000    5 document(s) imported successfully. 0 document(s) failed to import. 
    ```

14.  Check the two new collections in MongoDB by running the following command:

    ```js
    show collections
    ```

    结果如下：

    ![Figure 11.3: Displaying the new collections ](img/B15507_11_03.jpg)

图 11.3：显示新集合

首先，我们学习了如何从 MongoDB 服务器导出数据。现在我们可以使用 import 命令获取外部数据并将其输入 MongoDB。通过组合这两个简单命令，我们还可以在 MongoDB 实例之间移动数据，或者在将数据导入 MongoDB 之前使用外部工具创建数据。

# 备份整个数据库

使用**mongoexport**，理论上我们可以获取整个 MongoDB 服务器，提取每个数据库和集合中的所有数据。但是，我们必须一次对一个集合执行此操作，以确保文件正确映射到原始数据库和集合。手动执行此操作是可能的，但很困难。对于整个 MongoDB 服务器，即使有数百个集合，脚本也可以可靠地完成此任务

幸运的是，除了**mongoimport**和**mongoexport**之外，MongoDB 工具包还提供了导出数据库全部内容的工具。此工具称为**mongodump**。此命令创建整个 MongoDB 实例的备份。您只需要提供 URI（或主机和端口号），其余部分由**mongodump**命令完成。此导出创建一个二进制文件，可使用**mongorestore**（下一节将介绍一个命令）还原该文件。通过将**mongodump**和**mongorestore**相结合，您可以可靠地跨不同的硬件和软件配置备份、恢复和迁移 MongoDB 数据库。

## 使用 mongodump

以下是一个最简单的**mongodump**命令：

```js
mongodump
```

非常有趣的是，您可以在不使用单个参数的情况下运行**mongodump**。这是因为命令需要使用的唯一信息是 MongoDB 服务器的位置。如果未指定 URI 或主机，它将尝试为本地系统上运行的 MongoDB 服务器创建备份。

我们可以使用**--URI**参数指定 URI 来指定 MongoDB 服务器的位置。

笔记

与**mongoexport**一样，**--db/--host**和**--uri**参数是互斥的。

但是，如果我们确实有一台本地 MongoDB 服务器在运行，我们可能会收到以下输出：

```js
2020-08-18T12:38:43.091+1000    writing imports.newData to 
2020-08-18T12:38:43.091+1000    writing imports.contacts to 
2020-08-18T12:38:43.091+1000    writing imports.oldData to 
2020-08-18T12:38:43.310+1000    done dumping imports.newData (5 documents)
2020-08-18T12:38:44.120+1000    done dumping imports.contacts (3 documents)
2020-08-18T12:38:44.120+1000    done dumping imports.oldData (5 documents)
```

在这个命令的末尾，我们可以看到在我们的目录中有一个新文件夹，其中包含数据库的转储。默认情况下，**mongodump**导出我们 MongoDB 服务器中的所有内容。然而，我们可以对我们的出口进行更多的选择，我们将在下一节中看到一个例子。

## mongodump 选项

**mongodump**命令需要的功能选项非常少；在大多数情况下，您可能只使用了**--uri**参数。但是，我们可以使用几个选项来充分利用这个工具命令。下面列出了一些最有用的选项。

*   **——安静**：这减少了转储的输出消息量。
*   **--out**：这允许您为要写入磁盘的导出指定不同的位置，默认情况下，它将在运行命令的同一目录中创建一个名为“dump”的目录。
*   **--db**：这允许您为要备份的命令指定单个数据库，默认情况下它将备份所有数据库。
*   **--collection**：允许您指定要备份的单个集合，默认情况下会备份所有集合。
*   **--excludeCollection**：这允许您指定要从备份中排除的集合。
*   **--query**：这允许您指定一个查询文档，该文档将只备份与查询匹配的文档。
*   **--gzip**：如果启用，则导出输出为**.gz**格式的压缩文件，而不是目录。

我们将考虑创建一个包含用户和角色的单个数据库转储到磁盘上的特定位置。因为我们只做一个数据库转储，所以我们可以对我们想要使用的数据库使用**--uri**。

```js
mongodump --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/imports --out="./backups"
      2020-08-18T12:39:51.457+1000    writing imports.newData to 
2020-08-18T12:39:51.457+1000    writing imports.contacts to 
2020-08-18T12:39:51.457+1000    writing imports.oldData to 
2020-08-18T12:39:51.697+1000    done dumping imports.newData (5 documents)
2020-08-18T12:39:52.472+1000    done dumping imports.contacts (3 documents)
2020-08-18T12:39:52.493+1000    done dumping imports.oldData (5 documents)
```

正如您在前面的屏幕截图中所看到的，仅导出了指定数据库中存在的集合。如果查看包含我们的导出的文件夹，您甚至可以看到：

```js
╭─ ~/backups
╰─ ls
      imports/
╭─ ~/backups
╰─ ls imports 
      contacts.bson          contacts.metadata.json newData.bson 
      newData.metadata.json  oldData.bson           oldData.metadata.json 
```

您可以在 imports 目录中看到，为转储中的每个集合创建了两个文件，一个包含我们的数据的**.bson**文件和一个用于集合元数据的**.metadata.json**文件。所有**mongodump**结果都将匹配此格式。

接下来，使用您的**--query**参数仅转储集合中的特定文档。可以使用标准查询文档指定集合。例如，在 Windows 上考虑以下命令：

```js
mongodump --uri=mongodb+srv://USERNAME:PASSWORD@myAtlasServer-fawxo.gcp.mongodb.net/sample_mflix --collection="movies" --out="./backups" --query="{genres: 'Action'}"
```

在 MacOS/Linux 上，您必须将引号修改为以下内容：

```js
mongodump --uri=mongodb+srv://USERNAME:PASSWORD@myAtlasServer-fawxo.gcp.mongodb.net/sample_mflix --collection="movies" --out="./backups" --query='{"genres": "Action"}'
```

结果如下：

```js
2020-08-18T12:57:06.533+1000    writing sample_mflix.movies to 
2020-08-18T12:57:07.258+1000    sample_mflix.movies  101
2020-08-18T12:57:09.109+1000    sample_mflix.movies  2539
2020-08-18T12:57:09.110+1000    done dumping sample_mflix.movies (2539 documents)
```

电影收藏中有 20000 多个文档，但我们只导出了**2539**匹配文档。

现在，在不使用**--query**参数的情况下执行相同的导出：

```js
mongodump --uri=mongodb+srv://USERNAME:PASSWORD@myAtlasServer-fawxo.gcp.mongodb.net/sample_mflix --collection="movies" --out="./backups"
```

结果如下：

```js
2020-08-18T12:57:45.263+1000    writing sample_mflix.movies to 
2020-08-18T12:57:45.900+1000    [........................]  sample_mflix.movies  101/23531  (0.4%)
2020-08-18T12:57:48.891+1000    [........................]  sample_mflix.movies  101/23531  (0.4%)
2020-08-18T12:57:51.894+1000    [##########..............]  sample_mflix.movies  10564/23531  (44.9%
)
2020-08-18T12:57:54.895+1000    [##########..............]  sample_mflix.movies  10564/23531  (44.9%)
2020-08-18T12:57:57.550+1000    [########################]  sample_mflix.movies  23531/23531  (100.0%)
2020-08-18T12:57:57.550+1000    done dumping sample_mflix.movies (23531 documents)
```

我们可以在前面的输出中看到，如果没有**--query**参数，转储的文档数量会显著增加，这意味着我们已经将从集合导出的文档数量减少到了仅与查询匹配的文档数量。

与我们前面学习的命令一样，这些选项只表示您可以提供给**mongodump**的参数的一小部分。通过结合并试用这些选项，您将能够为您的 MongoDB 服务器创建一个健壮的备份和快照解决方案。

通过使用**mongoimport**和**mongoexport**，您可以轻松地从数据库中获取特定集合。但是，作为 MongoDB 服务器备份策略的一部分，您可能需要备份 MongoDB 数据库的整个状态。在下一个练习中，我们将只创建一个**sample_mflix**数据库的转储，而不是在 MongoDB 服务器中创建许多不同数据库的更大转储。

## 练习 11.03：备份 MongoDB

在本练习中，您将使用**mongodump**创建**sample_mflix**数据库的备份。将数据导出到名为**movies\u backup**文件夹中的**.gz**文件中。

执行以下步骤以完成此练习：

1.  要微调导入并将其保存以备将来使用，请创建一个名为**Exercise11.03.txt**的新文件来存储您的**mongodump**命令。
2.  接下来，键入标准的**mongodump**语法，其中只包含**--uri**参数集。记住，**--uri**包含目标数据库。

    ```js
    mongodump --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/sample_mflix
    ```

3.  接下来，添加指定转储文件应保存到的位置的参数。在本例中，这是一个名为**movies_backup**：

    ```js
    mongodump --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/sample_mflix --out=movies_backup
    ```

    的文件夹
4.  Finally, to automatically place your dump file in a **.gz** file, use the **--gzip** parameter and run the command.

    ```js
    mongodump --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/sample_mflix --out=movies_backup --gzip
    ```

    笔记

    由于此命令将转储整个**sample_mflix**数据库，因此可能需要一点时间，具体取决于您的 internet 连接。

    执行命令后，您将看到类似于以下屏幕截图的输出：

    ![Figure 11.4: Output after the mongodump command is executed ](img/B15507_11_04.jpg)

    图 11.4：执行 mongodump 命令后的输出

5.  检查您的转储目录。您可以看到所有的**mongodump**数据都已写入正确的目录。

    ```js
    ╰─ ls movies_backup
          sample_mflix/
    ╰─ ls movies_backup/sample_mflix
          comments.bson.gz                   comments.metadata.json.gz
          most_commented_movies.bson.gz       most_commented_movies.metadata.json.gz 
          movies.bson.gz                      movies.metadata.json.gz
          movies_top_romance.bson.gz          movies_top_romance.metadata.json.gz
          sessions.bson.gz                    sessions.metadata.json.gz
          theaters.bson.gz                    theaters.metadata.json.gz
          users.bson.gz                       users.metadata.json.gz
    ```

在本练习的过程中，您学习了如何编写一个**mongodump**命令来正确创建数据库的压缩备份。现在，您可以将此技术作为数据库迁移或备份策略的一部分进行集成。

# 恢复 MongoDB 数据库

在上一节中，我们学习了如何使用**mongodump**创建整个 MongoDB 数据库的备份。但是，这些导出在我们的备份策略中不会有好处，除非我们拥有将它们加载回 MongoDB 服务器的方法。通过将我们的导出放回数据库来补充**mongodump**的命令是**mongorestore**。

与**mongoimport**允许我们将常用格式导入 MongoDB 不同，**mongorestore**只用于导入**mongodump**结果。这意味着它最常用于将大部分或全部数据库恢复到特定状态。**mongordore**命令是灾难后恢复转储或将整个 MongoDB 实例迁移到新配置的理想选择。

当与我们的其他命令结合使用时，**mongorestore**完成了导入和导出生命周期。通过三个命令（**mongoimport**、**mongoexport**和**mongodump**，我们了解到我们可以导出采集级数据、导入采集级数据、在服务器级导出，现在，通过**mongorestore**，我们可以导入服务器级信息。

## 使用 mongorestore

与其他命令一样，让我们看一看**mongorestore**命令的简单实现。

```js
mongorestore .\dump\
```

或者在 MacOS/Linux 上，您可以输入以下内容：

```js
mongorestore ./dump/
```

我们需要传入的唯一必需参数是要恢复的转储的位置。但是，正如您可能从我们的其他命令中猜到的，默认情况下，**mongorestore**尝试将备份恢复到本地系统。

笔记

转储位置不需要**--参数**格式，而是可以作为命令的最后一个值传入。

这里，我们可以再次使用**--URI**参数指定 URI，以指定 MongoDB 服务器的位置。

例如，假设我们确实有一台本地 MongoDB 服务器在运行。要完成恢复，我们需要一个以前创建的转储。以下是基于*练习 11.03 的转储命令，备份 MongoDB*：

```js
mongodump --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/imports --out=./dump
```

如果我们现在使用**--drop**选项对此转储运行**mongorestore**，您可能会看到类似于以下内容的输出：

![Figure 11.5: Output after mongorestore is run using the –drop option ](img/B15507_11_05.jpg)

图 11.5：使用–drop 选项运行 mongorestore 后的输出

正如您所期望的，此输出应该与**mongoimport**的输出最为相似，告诉我们从转储文件还原了多少文档和索引。如果您的用例是作为备份策略的一部分进行恢复，那么您只需要这个参数最少的简单命令。

默认情况下，**mongorestore**恢复目标转储中的所有数据库、集合和文档。如果您希望更具体地执行还原，有几个方便的选项，允许您在还原过程中仅还原特定集合，甚至重命名集合。下一节将提供这些选项的示例。

## mongorestore 选项

与**mongodump**一样，**mongorestore**命令可以满足大多数用例，只需要它的基本参数，如**--uri**和转储文件的位置。如果希望完成更具体的恢复类型，可以使用以下一些选项：

*   **——安静**：这减少了转储的输出消息量。
*   **--drop**：与**mongoimport**类似，**--drop**选项将在恢复之前删除要恢复的集合，这样可以确保在命令运行后不会保留旧数据。
*   **--dryRun**：这允许您查看运行**mongorestore**的输出，而不需要实际更改数据库中的信息，这是在执行潜在危险操作之前测试您的命令的极好方法。
*   **--stopOnError**：如果启用，则只要出现一个错误，流程就会停止。
*   **--n 包括**：此选项不专门提供数据库和集合，而是允许您定义应从转储文件导入哪些名称空间（数据库和集合）。我们将在本章后面看到一个例子。
*   **--nsExclude**：这是**nsInclude**的补充选项，允许您提供在运行还原时未导入的命名空间模式。在下一节中有一个例子。
*   **--nsFrom**：使用与**nsInclude**和**nsExclude**中相同的名称空间模式，此参数可与**--nsTo**一起使用，以提供导出中名称空间到还原备份中新名称空间的映射。这允许您在恢复过程中更改集合的名称。

现在，让我们看一些正在使用的这些选项的示例。请注意，对于这些示例，我们使用的是上一节中创建的转储文件。作为提醒，这是创建此转储文件所需的命令：

```js
mongodump --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/sample_mflix --out=dump
```

首先，假设您有一个完整的**mongodump**是从**sample\u mflix**数据库创建的。以下是仅恢复集合的一个子集所需的命令示例。您可能会注意到参数的格式为**{database}.{collection}**，但您可以使用 wild star（*****运算符）匹配所有值。在下面的示例中，我们将包括与名称空间**“sample_mflix.movies”**（仅包括**sample_mflix**数据库的 movies 集合）匹配的任何集合。

```js
mongorestore --uri=mongodb+srv://USERNAME:PASSWORD@myAtlasServer-fawxo.gcp.mongodb.net --drop --nsInclude="sample_mflix.movies" dump
```

此命令运行完成后，您将看到类似于以下内容的输出：

```js
2020-08-18T13:12:28.204+1000    [###################.....]  sample_mflix.movies  7.53MB/9.06MB  (83.2%)
2020-08-18T13:12:31.203+1000    [#######################.]  sample_mflix.movies  9.04MB/9.06MB  (99.7%)
2020-08-18T13:12:33.896+1000    [########################]  sample_mflix.movies  9.06MB/9.06MB  (100.0%)
2020-08-18T13:12:33.896+1000    no indexes to restore
2020-08-18T13:12:33.902+1000    finished restoring sample_mflix.movies (6017 documents, 0 failures)
2020-08-18T13:12:33.902+1000    6017 document(s) restored successfully. 0 document(s) failed to restore.
```

在输出中，您可以看到仅恢复匹配的名称空间。现在，让我们检查一下如何使用**nsFrom**和**nsTo**参数来重命名集合，使用与上例相同的格式。我们将把**sample_mflix**数据库中的集合重命名为相同的集合名称，但在一个名为 backup 的新数据库中：

```js
mongorestore --uri=mongodb+srv://USERNAME:PASSWORD@myAtlasServer-fawxo.gcp.mongodb.net --drop --nsFrom="sample_mflix.*" --nsTo="backup.*" dump
```

完成此命令的执行后，最后几行应类似于以下内容：

```js
2020-08-18T13:13:54.152+1000    [################........]    backup.movies  6.16MB/9.06MB  (68.0%)
2020-08-18T13:13:54.152+1000
2020-08-18T13:13:56.916+1000    [########################]  backup.comments  4.35MB/4.35MB  (100.0%)
2020-08-18T13:13:56.916+1000    no indexes to restore
2020-08-18T13:13:56.916+1000    finished restoring backup.comments (16017 documents, 0 failures)
2020-08-18T13:13:57.153+1000    [###################.....]  backup.movies  7.53MB/9.06MB  (83.1%)
2020-08-18T13:14:00.152+1000    [#######################.]  backup.movies  9.04MB/9.06MB  (99.7%)
2020-08-18T13:14:02.929+1000    [########################]  backup.movies  9.06MB/9.06MB  (100.0%)
2020-08-18T13:14:02.929+1000    no indexes to restore
2020-08-18T13:14:02.929+1000    finished restoring backup.movies (6017 documents, 0 failures)
2020-08-18T13:14:02.929+1000    23807 document(s) restored successfully. 0 document(s) failed to restore. 
```

现在，如果我们观察 MongoDB 数据库中的集合，我们将看到**样本**集合也存在于名为**备份**的数据库中，例如：

```js
MongoDB Enterprise atlas-nb3biv-shard-0:PRIMARY> use backup
switched to db backup
MongoDB Enterprise atlas-nb3biv-shard-0:PRIMARY> show collections
comments
most_commented_movies
movies
movies_top_romance
sessions
theaters
users
```

最后，让我们快速了解一下**dryRun**参数是如何工作的。请查看以下命令：

```js
mongorestore --uri=mongodb+srv://USERNAME:PASSWORD@myAtlasServer-fawxo.gcp.mongodb.net --drop --nsFrom="imports.*" --nsTo="backup.*" --dryRun .\dump\
```

您将注意到一个关于准备恢复的命令的输出。但是，它不会加载任何数据。MongoDB 中的基础数据均未更改。这是一种很好的方法，可以确保您的命令在执行之前不会出错。

**mongorestore**命令完成了我们的四个命令，即**mongoimport**、**mongoexport**、**mongodump**和**mongorestore**。尽管使用**mongorestore**很简单，但如果您的备份策略有更复杂的设置，您可能需要使用多个选项并参考文档。

## 练习 11.04：恢复 MongoDB 数据

在上一个练习中，您使用**mongodump**创建了**sample_mflix**数据库的备份。作为 MongoDB 服务器备份策略的一部分，您现在需要将这些数据放回数据库中。在本练习中，假设从中导出和导入到的数据库是不同的数据库。因此，为了向客户机证明备份策略有效，您将使用**mongorestore**将该转储导入到另一个命名空间中。

笔记

在完成本练习之前，您需要从*练习 11.03**备份 MongoDB*创建转储。

在本练习中，您将使用**mongorestore**从上一练习中创建的**movies\u backup**转储中恢复**sample\u mflix**数据库，将每个集合的名称空间更改为**backup\u mflix**。

1.  微调导入并将其保存以备将来使用。创建一个名为**Exercise11.04.txt**的新文件来存储还原命令。
2.  确保来自*练习 11.03**备份 MongoDB*的**电影备份**转储文件也在您当前的目录中。否则，您可以使用以下命令创建新备份：

    ```js
    mongodump --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/sample_mflix --out=./movies_backup --gzip
    ```

3.  接下来，键入标准的**mongorestore**语法，只需提供转储文件的 URI 和位置。请记住，URI 中包含目标数据库：

    ```js
    mongorestore --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net ./movies_backup
    ```

4.  由于转储文件为**gzip**格式，您还需要在 restore 命令中添加**--gzip**参数，以便它可以解压缩数据。

    ```js
    mongorestore --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net --gzip ./movies_backup
    ```

5.  为确保恢复结果干净，请在尝试恢复相关集合之前，使用您的**--drop**参数删除相关集合：

    ```js
    mongorestore --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net --gzip --drop ./movies_backup
    ```

6.  现在，添加修改名称空间的参数。因为您正在恢复**样本**数据库的转储，**样本**将是您的**nsFrom**参数的值：

    ```js
    mongorestore --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net --nsFrom="sample_mflix.*" --gzip --drop ./movies_backup
    ```

7.  此用例规定这些集合将在名为**backup_mflix**的数据库中恢复。为这个新名称空间提供如下的**nsTo**参数。

    ```js
    mongorestore --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net --nsFrom="sample_mflix.*" --nsTo="backup_mflix.*" --gzip --drop ./movies_backup
    ```

8.  Your command is now complete. Copy and paste this code into your Terminal or Command Prompt and run it. There will be a lot of output to show you the progress of the restore, but at the end, you should see an output like the following:

    ```js
    2020-08-18T13:18:08.862+1000    [####################....]  backup_mflix.movies  10.2MB/11.7MB  (86.7%)
    2020-08-18T13:18:11.862+1000    [#####################...]  backup_mflix.movies  10.7MB/11.7MB  (90.8%)
    2020-08-18T13:18:14.865+1000    [######################..]  backup_mflix.movies  11.1MB/11.7MB  (94.9%)
    2020-08-18T13:18:17.866+1000    [#######################.]  backup_mflix.movies  11.6MB/11.7MB  (98.5%)
    2020-08-18T13:18:20.217+1000    [########################]  backup_mflix.movies  11.7MB/11.7MB  (100.0%)
    2020-08-18T13:18:20.217+1000    restoring indexes for collection backup_mflix.movies from metadata
    2020-08-18T13:18:26.389+1000    finished restoring backup_mflix.movies (23531 documents, 0 failures)
    2020-08-18T13:18:26.389+1000    75594 document(s) restored successfully. 0 document(s) failed to restore.
    ```

    通过读取输出，您可以看到恢复已完成，将每个现有集合恢复到名为**backup_mflix**的新数据库中。输出甚至会准确地告诉您在恢复过程中写入了多少文档。例如，**23541**文档被还原到**电影**收藏中。

    现在，如果您使用 mongo shell 登录服务器，您应该可以看到新恢复的**备份\u mflix**数据库和相关集合，如下所示：

    ```js
    MongoDB Enterprise atlas-nb3biv-shard-0:PRIMARY> use backup_mflix
    switched to db backup_mflix
    MongoDB Enterprise atlas-nb3biv-shard-0:PRIMARY> show collections
    comments
    most_commented_movies
    movies
    movies_top_romance
    sessions
    theaters
    users
    ```

    就这样。您已成功将备份还原到 MongoDB 服务器。凭借您对**mongorestore**的工作知识，您现在将能够高效地备份和迁移整个 MongoDB 数据库或服务器。如本章前面所述，您可能已经能够使用**mongoimport**来管理相同的任务，但是能够使用**mongodump**和**mongorestore**将使您的任务大大简化。

    通过本章中学习的四个关键命令（**mongoexport**、**mongoimport**、**mongodump**和**monogrestore**），您现在应该能够完成使用 MongoDB 时遇到的大部分备份、迁移和恢复任务。

    ## 活动 11.01：MongoDB 中的备份和恢复

    您的客户（电影院公司）已经有几个每晚运行的脚本来导出、导入、备份和恢复数据。它们同时运行备份和导出，以确保数据存在冗余副本。但是，由于缺乏 MongoDB 的经验，这些命令无法正常运行。为了解决这个问题，他们要求您协助他们微调备份策略。按照以下步骤完成此活动：

    笔记

    此活动中的四个命令必须以正确的顺序运行，**导入**和**还原**命令取决于**导出**和**转储**命令的输出。

9.  **导出**：将所有剧场数据，包括位置和**剧场 ID**字段，按**剧场 ID**排序，导出到名为**剧场.CSV**：

    ```js
    mongoexport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/sample_mflix --db=sample_mflix --collection=theaters --out="theaters.csv" --type=csv --sort='{theaterId: 1}'
    ```

    的 CSV 文件中
10.  **导入**：将**theaters.csv**文件导入一个名为**theaters 的新集合【U 导入**：

    ```js
    mongoimport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/imports --collection=theaters_import --file=theaters.csv
    ```

11.  **转储**：将除**影院**收藏之外的所有收藏转储到一个名为**备份**的文件夹中，该文件夹采用**gzip**格式：

    ```js
    mongodump --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/sample_mflix --out=./backups –gz --nsExclude=theaters
    ```

12.  **恢复**：恢复备份文件夹中的转储。每个集合都应恢复到名为**样本**：

    ```js
    mongorestore --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net --from="sample_mflix" --to="backup_mflix_backup" --drop ./backups
    ```

    的数据库中

您的目标是从客户端获取提供的脚本，确定这些脚本的错误，并修复这些问题。您可以测试这些脚本是否在您自己的 MongoDB 服务器上正确运行。

您可以通过多种方式完成此目标，但请记住我们在本章中所学到的内容，并尝试创建简单易用的代码。以下步骤将帮助您完成此任务：

1.  目标数据库已指定两次，请尝试删除冗余参数。
2.  Rerun the **export** command. We are missing an option specific to the CSV format. Add this parameter to ensure we export the **theaterId** and location fields.

    现在看一下**导入**命令，您应该立即注意到 CSV 导入所需的一些缺少的参数。

3.  首先对于**dump**命令，其中一个选项不正确；运行命令获取提示。
4.  第二，**nsInclude**选项对于 dump 命令不可用，因为这是一个**mongorestore**选项。将其替换为适用于**mongodump**的相应选项。
5.  在**restore**命令中，有一些选项的名称不正确。修正这些名字。
6.  同样在**restore**命令中，从前面的命令恢复**gzip**格式转储。向 restore 命令添加一个选项以支持此格式。
7.  最后，在**restore**命令中，查看和**nsTo**选项的**值，并检查它们是否具有正确的命名空间格式。**

要测试结果，请依次运行四个生成的命令（导出、导入、转储和还原）

**mongoexport**命令的输出如下：

```js
2020-08-18T13:21:29.778+1000    connected to: mongodb+srv://[**REDACTED**]@performancetuning.98afc.gcp.mongodb.net/sample_mflix
2020-08-18T13:21:30.891+1000    exported 1564 records
```

**mongoimport**命令的输出如下：

```js
2020-08-18T13:22:20.720+1000    connected to: mongodb+srv://[**REDACTED**]@performancetuning.98afc.g
cp.mongodb.net/imports
2020-08-18T13:22:22.817+1000    1564 document(s) imported successfully. 0 document(s) failed to import.
```

**mongodump**命令的输出如下：

![Figure 11.6 Output from the mongodump command ](img/B15507_11_06.jpg)

图 11.6 mongodump 命令的输出

**mongorestore**命令的输出开始如下所示：

![Figure 11.7: Start of the output from the mongorestore command ](img/B15507_11_07.jpg)

图 11.7:mongorestore 命令输出的开始

**mongorestore**命令的输出结束如下：

![Figure 11.8: End of the output from the mongorestore command ](img/B15507_11_08.jpg)

图 11.8:mongorestore 命令输出的结束

笔记

此活动的解决方案可通过[此链接](14.html#_idTextAnchor481)找到。

# 总结

在本章中，我们介绍了四个独立的命令。但是，这四个命令都是 MongoDB 完整备份和恢复生命周期中的元素。通过将这些基本命令与其高级选项结合使用，您现在应该能够确保您负责的任何 MongoDB 服务器都可以在数据损坏、丢失或灾难时进行适当的快照、备份、导出和恢复。

您可能不负责备份 MongoDB 数据，但这些命令也可用于大量工具。例如，当试图以电子表格的形式直观地浏览信息，甚至向不熟悉文档模型的同事展示信息时，能够将数据导出为 CSV 格式将非常方便。通过使用**mongoimport**，您还可以减少导入非 MongoDB 格式数据所需的人工工作量，以及从其他服务器批量导入 MongoDB 数据。

下一章将介绍数据可视化，这是一个非常重要的概念，用于将 MongoDB 信息转化为易于理解的结果，从而为业务问题提供洞察力和清晰度，并将其集成到演示中，以说服或说服利益相关者了解难以解释的数据趋势。**