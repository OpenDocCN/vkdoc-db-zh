# 八、在 MongoDB 中编写 JavaScript

概述

在本章中，您将学习如何使用 Node.js 驱动程序阅读、理解和创建简单的 MongoDB 应用程序。这些应用程序将帮助您以编程方式获取、更新和创建 MongoDB 集合中的数据，以及处理错误和用户输入。到本章结束时，您将能够创建一个构建在 MongoDB 之上的简单应用程序。

# 导言

到目前为止，我们已经使用 MongoShell 直接与 MongoDB 数据库交互。这些直接交互快速、简单，是学习或试验 MongoDB 特性的绝佳方式。然而，在许多生产环境中，将由软件代替用户连接数据库。MongoDB 是存储和查询数据的好地方，但通常，它最基本的用途是作为大型应用程序的后端。这些应用程序以编程方式写入、读取和更新数据，通常是在某些条件或用户界面触发之后。

要将软件与数据库连接，通常需要使用称为驱动程序的库（通常由数据库创建者提供）。此驱动程序将帮助您连接、分析、读取和写入数据库，而无需为简单操作编写多行代码。它为常见用例提供函数和抽象，以及处理从数据库中提取的数据的框架。MongoDB 为不同的编程语言提供了几种不同的驱动程序，其中最流行的（我们将在本章中探讨）是 Node.js 驱动程序（有时称为 Node）。

要将此与现实生活联系起来，请考虑一下您的在线购物体验。第一次从网站购买产品时，您必须输入所有帐单和发货详细信息。但是，如果您已经注册了一个帐户，那么在第二次结账时，您的所有详细信息都已保存在网站上。这是一个很好的体验，对于许多网站来说，这是通过 web 应用程序查询后端数据库来实现的。能够支持这些应用程序的一个这样的数据库是 MongoDB。

MongoDB 取得如此优异的增长和采用率的主要原因之一是它成功地说服软件开发人员选择它作为应用程序的数据库。这种说服力很大程度上来自 MongoDB 与 Node 的集成程度。

Node.js 已经成为基于 web 的应用程序的主要语言之一，我们将在本章后面部分学习。然而，就目前而言，充分了解 Node 和 MongoDB 的易集成性对这两种技术都非常有益。这种共生关系还导致了大量成功的 Node/MongoDB 实现，从小型移动应用程序到大型 web 应用程序。在演示 MongoDB 驱动程序时决定选择哪种编程语言时，Node.js 是首选。

根据您的工作角色，您可能负责编写将在 MongoDB 上运行的应用程序，或者希望编写偶尔的代码行。但是，无论您的编程级别或专业职责如何，了解应用程序如何使用驱动程序与 MongoDB 集成都是非常有价值的。大多数 MongoDB 生产查询由应用程序运行，而不是由人运行。无论您是数据分析师、前端开发人员还是数据库管理员，您的生产环境都极有可能使用其中一个 MongoDB 驱动程序。

笔记

在本章期间，包含的练习和活动是单个场景的迭代。数据和示例基于 MongoDB Atlas 样本数据库，名为**样本**。

在本章期间，我们将根据理论情景进行一系列练习。这是我们在*第 7 章*、*聚合*中所述场景的扩展。

根据*第 7 章*、*聚合*中的场景，一家电影公司正在举办年度经典电影马拉松，并希望确定自己的阵容，他们需要满足特定标准的各种流行电影来满足其客户群。在探索数据并帮助他们做出业务决策后，您为他们提供了新的见解。电影公司对你的建议很满意，并决定让你参与他们的下一个项目。该项目包括创建一个简单的 Node.js 应用程序，允许其员工查询电影数据库，而无需知道 MongoDB，也无需对电影院放映的电影进行投票。在本章中，您将创建此应用程序。

# 接司机

在较高的层次上，在 MongoDB 中使用 Node.js 驱动程序的过程类似于直接连接 shell。您将指定一个 MongoDB 服务器 URI、几个连接参数，并且可以对集合执行查询。这一切都应该很熟悉；主要区别在于，这些指令将使用 JavaScript 而不是 Bash 或 PowerShell 编写。

## Node.js 简介

由于本章的目的不是学习 Node.js 编程，因此我们将简要介绍一些基本知识，以确保能够创建 MongoDB 应用程序。Node.js 中的**js**代表**JavaScript**，因为 JavaScript 是 Node.js 理解的编程语言。JavaScript 通常在浏览器中运行。但是，您可以将 Node.js 视为在计算机上执行 JavaScript 文件的引擎。

在本章中，您将编写 JavaScript（**.js**）语法，并使用 Node.js 执行它。尽管您可以使用任何文本编辑器编写 JavaScript 文件，但建议您使用有助于语法突出显示和格式设置的应用程序，如**Visual Studio 代码**或**升华**。

首先，让我们看一些示例代码：

```js
// 1_Hello_World.js
var message = "Hello, Node!";
console.log(message);
```

让我们从前面的语法中详细定义每个术语：

*   **var**关键字用于声明新变量；在本例中，变量名为**消息**。
*   **=**符号将此变量的值设置为一个名为**Hello，Node！**。
*   在每条语句的末尾使用分号（**；**）。
*   **console.log（message）**是输出**message**值的函数。

如果您熟悉编程基础知识，您可能已经注意到，我们不必显式地将**消息**变量声明为**字符串**。这是因为 JavaScript 是**动态类型化的**，这意味着您不必显式指定变量类型（数字、字符串、布尔值等）。

如果您对编程基础知识不太熟悉，本章中的一些术语可能会让您感到困惑。因为这不是一本 JavaScript 编程书，所以这些概念将不会被深入讨论。本章的目的是了解驱动程序如何与 MongoDB 交互；Node.js 的细节并不重要。尽管本章试图使编程概念保持简单，但如果有些事情看起来很复杂，请不要担心。

让我们尝试运行代码示例，将该代码保存到当前目录中名为**1_Hello_World.js**的文件中，然后使用以下命令在终端或命令提示符中运行该命令：

```js
> node 1_Hello_World.js
```

您将看到如下输出：

```js
Section1> node 1_Hello_World.js
Hello, Node!
Section1>
```

如您所见，运行 Node.js 脚本非常简单，因为无需构建或编译，您就可以编写代码并使用**节点**调用它。

**var**关键字将信息存储在变量中，然后在代码中对其进行更改。但是，还有另一个关键字，**const**，用于存储不会更改的信息。因此，在我们的示例中，我们可以用**const**关键字替换我们的**var**关键字。作为最佳实践，您可以将任何不会更改的内容声明为**常量**：

```js
// 1_Hello_World.js
const message = "Hello, Node!";
console.log(message);
```

现在，让我们考虑函数和参数的结构。它类似于 mongo shell 中前几章查询的结构。首先，让我们来看看下面定义函数的例子：

```js
var printHello = function(parameter) {
    console.log("Hello, " + parameter);
}
printHello("World")
```

下面是我们将在本章后面遇到的一些代码类型的预览。您可能会注意到，虽然这是一个复杂得多的代码片段，但您在前面几章（特别是*第 4 章*、*查询文档*）中学习到的 CRUD 操作中有一些常见元素，例如**find**命令的语法和 MongoDB URI：

```js
// 3_Full_Example.js
const Mongo = require('mongodb').MongoClient;
const server = 'mongodb+srv://username:password@server-  abcdef.gcp.mongodb.net/test?retryWrites=true&w=majority'
const myDB   = 'sample_mflix'
const myColl = 'movies';
const mongo = new Mongo(server);
mongo.connect(function(err) {
    console.log('Our driver has connected to MongoDB!');
    const database = mongo.db(myDB);
    const collection = database.collection(myColl);
    collection.find({title: 'Blacksmith Scene'}).each(function(err, doc) {
        if(doc) {
            console.log('Doc returned: ')
            console.log(doc);
        } else {
            mongo.close();
            return false;
        }
    })
})
```

开始时这可能有点吓人，但随着我们深入本章，这将变得更加熟悉。正如我们前面提到的，应该有一些元素可以从 mongo shell 中识别出来，即使它们看起来有点不同。代码中映射到 mongo shell 元素的一些元素如下所示：

*   **集合**对象，如外壳中的**db.collection**。
*   在我们的**集合**之后的**查找**命令，就像贝壳一样。
*   我们的**find**命令中的参数是一个文档过滤器，这正是我们将在 shell 中使用的。

Node.js 中的函数声明是使用**函数（参数）{…}**函数完成的，它允许我们创建可多次运行的更小、可重用的代码位，例如**find（）**或**insertOne（）**函数。定义一个函数很容易；您只需使用**函数**关键字，后跟函数名称、括号中的参数和大括号来定义此函数的实际逻辑。

下面是定义函数的代码。请注意，有两种方法可以做到这一点：您可以将函数声明为变量或将函数作为参数传递给另一个函数。我们将在本章后面详细介绍：

```js
// 4_Define_Function.js
const newFunction = function(parameter1, parameter2) {
    // Function logic goes here.
    console.log(parameter1);
    console.log(parameter2);
}
```

## 获取 Node.js 的 MongoDB 驱动程序

安装 Node.js 的 MongoDB 驱动程序最简单的方法是使用**npm**。**npm**或 node package manager 是一个包管理工具，用于添加、更新和管理 node.js 程序中使用的不同包。在本例中，要添加的包是 MongoDB 驱动程序，因此，在存储脚本的目录中，在终端或命令提示符中运行以下命令：

```js
> npm install mongo --save
```

安装软件包后，您可能会看到一些输出，如下所示：

![Figure 8.1: Installing the MongoDB driver with npm ](img/B15507_08_01.jpg)

图 8.1：使用 npm 安装 MongoDB 驱动程序

就这么简单。现在，让我们开始针对 MongoDB 编程。

## 数据库和采集对象

使用 MongoDB 驱动程序时，有三个主要组件可用于大多数操作。在后面的练习中，我们将看到它们是如何组合在一起的，但在此之前，让我们简要介绍一下它们及其用途。

**MongoClient**是您必须在代码中创建的第一个对象。这表示您与 MongoDB 服务器的连接。将其视为您的 mongo shell 的等价物；您传入数据库的 URL 和连接参数，它将创建一个供您使用的连接。要使用**MongoClient**，您必须导入脚本顶部的模块：

```js
// First load the Driver module.
const Mongo = require('MongoDB').MongoClient;
// Then define our server.
const server = 'mongodb+srv://username:password@server-  abcdef.gcp.mongodb.net/test?retryWrites=true&w=majority';
// Create a new client.
const mongo = new Mongo(server);
// Connect to our server.
mongo.connect(function(err) {
    // Inside this block we are connected to MongoDB.
mongo.close(); // Close our connection at the end.
})
```

接下来是**数据库**对象。与 mongo shell 一样，一旦建立了连接，就对服务器中的特定数据库运行命令。此数据库对象还将确定可以对哪些集合运行查询：

```js
…
mongo.connect(function(err) {
    // Inside this block we are connected to MongoDB.
    // Create our database object.
    const database = mongo.db(«sample_mflix»);
    mongo.close(); // Close our connection at the end.
})
…
```

在（几乎）每个基于 MongoDB 的应用程序中使用的第三个基本对象是**集合**对象。您可能已经猜到，**集合**对象用于发送查询。与 mongo shell 一样，最常见的操作将针对单个集合运行：

```js
…
mongo.connect(function(err) {
    // Inside this block we are connected to MongoDB.
    // Create our database object.
    const database = mongo.db("sample_mflix");
    // Create our collection object
    const collection = database.collection("movies");
    mongo.close(); // Close our connection at the end.
})
…
```

**数据库**和**集合**对象表达了相同的概念，就像您直接连接 mongo shell 一样。在本章中，**MongoClient**仅用于创建和存储与服务器的连接。

需要注意的是，这些对象之间的关系是**一对多**。这意味着，通常，一个**MongoClient**对象可以创建多个**数据库**对象，而一个**数据库**对象可以创建多个**集合**对象，用于对以下对象运行查询：

![Figure 8.2: Driver entity relationships ](img/B15507_08_02.jpg)

图 8.2：驱动程序-实体关系

上图是前一段中描述的实体关系的可视化表示。这里有一个**MongoClient**对象对多个**数据库**对象，每个对象可能有多个**集合**对象。

## 连接参数

在编写代码之前，了解如何建立与**MongoClient**的连接非常重要。创建新客户端时只有两个参数：服务器的 URL 和任何其他连接选项。如果需要创建客户端，连接选项是可选的，如下所示：

```js
const serverURL = 'mongodb+srv://username:password@server-  abcdef.gcp.mongodb.net/test';
const mongo = new Mongo(serverURL);
mongo.connect(function(err) {
    // Inside this block we are connected to MongoDB.
mongo.close(); // Close our connection at the end.
})
```

笔记

您可能会被此代码段的语法弄糊涂，尤其是 connect 函数中的函数块。这被称为**回调**。我们将在本章后面详细介绍这些内容。目前，在没有更深入理解的情况下使用此模式就足够了。

与 mongo shell 一样，**serverURL**支持所有 MongoDB URI 选项，这意味着您可以在这个连接字符串本身中指定配置，而不是在第二个可选参数中指定配置；例如：

```js
const serverURL = 'mongodb+srv://username:password@server-  abcdef.gcp.mongodb.net/test?retryWrites=true&w=majority';
```

为了简化这个字符串，在创建客户机时，可以在第二个参数中指定许多 URI 选项（以及其他选项，如 SSL 设置）；例如：

```js
const mongo = new Mongo(serverURL, {
     sslValidate: false
});
mongo.connect(function(err) {
     // Inside this block we are connected to MongoDB.
mongo.close(); // Close our connection at the end.
})
```

与 mongo shell 一样，有许多配置选项，包括 SSL、身份验证和写关注点选项。然而，其中大多数都超出了本章的范围。

笔记

请记住，您可以在 cloud.mongodb.com 的用户界面中找到 Atlas 的完整连接字符串。您可能希望复制此连接字符串，并将其用于**服务器 URL**的所有脚本中。

让我们通过一个练习了解如何与 Node.js 驱动程序建立连接。

## 练习 8.01：创建与 Node.js 驱动程序的连接

在开始此练习之前，请根据*简介*部分中概述的场景重新访问电影公司。您可能还记得电影院公司想要一个 Node.js 应用程序，允许用户查询和更新电影数据库中的记录。要实现这一点，应用程序需要做的第一件事是建立到服务器的连接。这可以通过执行以下步骤来完成：

1.  首先，在您当前的工作目录中，创建一个名为**Exercise8.01.js**的新 JavaScript 文件，并在您选择的文本编辑器中打开它（Visual Studio 代码、升华等）：

    ```js
    > node Exercise8.01.js
    ```

2.  Import the MongoDB driver library (as described earlier in this chapter) into your script file by adding the following line to the top of the file:

    ```js
    const MongoClient = require('mongodb').MongoClient;
    ```

    笔记

    如果您没有在本章前面安装 npm MongoDB 库，您现在应该通过在命令提示符或终端中运行**npm install mongo--save**来完成安装。在与脚本相同的目录中运行此命令。

3.  为您的 MongoDB 服务器创建一个包含 URL 的新变量：

    ```js
    const url = 'mongodb+srv://username:password@server-  abcdef.gcp.mongodb.net/test';
    ```

4.  使用**url**变量

    ```js
    const client = new MongoClient(url);
    ```

    创建一个名为**客户端**的新**MongoClient**对象
5.  使用**连接**功能打开与 MongoDB 的连接，如下所示：

    ```js
    client.connect(function(err) {
         …
    })
    ```

6.  在连接块中添加一条**console.log（）**消息，确认连接已打开：

    ```js
    console.log('Connected to MongoDB with NodeJS!');
    ```

7.  Finally, at the end of the connection block, close the connection using the following syntax:

    ```js
    client.close(); // Close our connection at the end.
    ```

    您的完整脚本应如下所示：

    ```js
    // Import MongoDB Driver module.
    const MongoClient = require('mongodb').MongoClient;
    // Create a new url variable.
    const url = 'mongodb+srv://username:password@server-  abcdef.gcp.mongodb.net/test';
    // Create a new MongoClient.
    const client = new MongoClient(url);
    // Open the connection using the .connect function.
    client.connect(function(err) {
        // Within the connection block, add a console.log to confirm the       connection
        console.log('Connected to MongoDB with NodeJS!');
        client.close(); // Close our connection at the end.
    })
    ```

    使用**节点 Exercise8.01.js**执行代码后，会生成以下输出：

    ```js
    Chapter8> node Excercise8.01.js
    Connected to MongoDB with NodeJS!
    Chapter8>
    ```

在本练习中，您使用 Node.js 驱动程序建立了与服务器的连接。

# 执行简单查询

现在我们已经连接到 MongoDB，我们可以对数据库运行一些简单的查询。在 Node.js 驱动程序中运行查询与在 shell 中运行查询非常相似。现在，您应该已经熟悉 shell 中的**find**命令了：

```js
db.movies.findOne({})
```

以下是驱动程序中**find**命令的语法：

```js
collection.find({title: 'Blacksmith Scene'}).each(function(err, doc) { … }
```

如您所见，一般结构与您将在 mongo shell 中执行的**find**命令相同。这里，我们从数据库对象获取一个集合，然后使用查询文档对该集合运行 find 命令。这个过程本身很简单。主要区别在于我们如何构造命令以及如何处理从驱动程序返回的结果。

在编写 Node.js 应用程序时，一个关键问题是确保您的代码的编写方式能够方便地修改、扩展或理解，无论是您自己将来还是其他可能需要处理该应用程序的专业人员。

## 创建和执行查找查询

考虑来自 Type T0.练习 8.01 的代码，To.t2，创建与 NoDE.js 驱动程序 Outt3t 的连接，作为一个引用，因为它已经包含了连接：

```js
const MongoClient = require('mongodb').MongoClient;
// Replace this variable with the connection string for your server, provided by   MongoDB Atlas.
const url = 'mongodb+srv://username:password@server-abcdef.gcp.mongodb.net/test';
const client = new MongoClient(url);
client.connect(function(err) {
    console.log('Connected to MongoDB with NodeJS!');
    // OUR CODE GOES BELOW HERE
    // AND ABOVE HERE
    client.close();
})
```

我们的查询逻辑将添加到此处：

```js
    // OUR CODE GOES BELOW HERE
    // AND ABOVE HERE
```

现在，我们已经连接到 MongoDB 服务器。然而，还有两个重要的对象——**db**和**集合**。让我们创建我们的数据库对象（针对**示例 _mflix**数据库），如下所示：

```js
    // OUR CODE GOES BELOW HERE
    const database = client.db("sample_mflix")
    // AND ABOVE HERE
```

我们现在有了**数据库**对象。在 mongo shell 中发送查询时，必须将文档作为文档的筛选器传递给命令。这与 Node.js 驱动程序中的相同。您可以直接传递文档。但是，建议将过滤器单独定义为变量，然后分配一个值。您可以在以下代码段中看到差异：

```js
// Defining filter first.
var filter = { title: 'Blacksmith Scene'};
database.collection("movies").find(filter).toArray(function(err, docs) { });
// Doing everything in a single line.
database.collection("movies").find({title: 'Blacksmith   Scene'}).toArray(function(err, docs) {});
```

与 mongoshell 一样，您可以传递一个空文档作为参数来查找所有文档。您可能还注意到我们的**查找**命令末尾的**toArray**。这是因为默认情况下，**find**命令将返回光标。我们将在下一节介绍游标，但与此同时，让我们看看这个完整脚本的样子：

```js
const MongoClient = require('mongodb').MongoClient;
// Replace this variable with the connection string for your server, provided by   MongoDB Atlas.
const url = 'mongodb+srv://mike:password@myAtlas-  fawxo.gcp.mongodb.net/test?retryWrites=true&w=majority'
const client = new MongoClient(url);
client.connect(function(err) {
    console.log('Connected to MongoDB with NodeJS!');
    const database = client.db("sample_mflix");
    var filter = { title: 'Blacksmith Scene'};
    database.collection("movies").find(filter).toArray(function(err, docs) {
        console.log('Docs results:');
        console.log(docs);
     });
    client.close();
})
```

如果将此修改后的脚本保存为**2\u Simple\u Find.js**并使用**节点 2\u Simple\u Find.js**命令运行，则会产生以下输出：

![Figure 8.3: Output for the preceding snippet (truncated for brevity) ](img/B15507_08_03.jpg)

图 8.3：前面代码段的输出（为简洁起见截断）

前面的输出与通过 mongo shell 而不是驱动程序执行的 MongoDB 查询的输出非常相似。通过驱动程序执行查询时，我们了解到，尽管语法可能与 mongo shell 不同，但查询及其输出中的基本元素是相同的。

## 使用游标和查询结果

在前面的示例中，我们使用**toArray**函数将查询输出转换为一个数组，我们可以使用**console.log**输出该数组。当处理少量数据时，这是处理结果的简单方法；但是，对于较大的结果集，应该使用游标。在*第 5 章*、*插入、更新和删除文档*中，您应该对 mongo shell 查询中的游标比较熟悉。在 mongo shell 中，您可以使用**it**命令迭代光标。在 Node.js 中，有许多方法可以访问光标，其中三种是更常见的模式，如下所示：

*   **toArray**：这将获取查询的所有结果，并将它们放在单个数组中。这很容易使用，但当您希望查询结果很大时，效率不是很高。在下面的代码中，我们正在对 movies 集合运行一个**find**命令，然后使用**toArray**将数组中的第一个元素记录到控制台：

    ```js
    database.collection("movies").find(filter).toArray(function(err, docsArray) {
        console.log('Docs results as an array:');
        console.log(docsArray[0]); // Print the first entry in the array.
     });
    ```

*   **each**: This will iterate through each document in the result set, one at a time. This is a good pattern if you want to inspect or use each document in the result. In the following code snippet, we're running a **find** command against the movies collection, using **each** to log every document that's returned until there are no documents left:

    ```js
    database.collection("movies").find(filter).each(function(err, doc) {
        if(doc) {
            console.log('Current doc');
            console.log(doc);
        } else {
            client.close(); // Close our connection.
            return false;   // End the each loop.
        }
     });
    ```

    当没有更多的单据需要退回时，单据将等于**空**。因此，每次检查新文档时，检查文档是否存在（使用**if（doc）**非常重要。

*   **下一个**：这将允许您访问结果集中的下一个文档。如果您只查找单个文档或结果的子集，而不必遍历整个结果，那么这是最好的模式。在下面的代码片段中，我们正在对 movies 集合运行一个**find**命令，使用**next**获取返回的第一个文档，然后将该文档输出到控制台：

    ```js
    database.collection("movies").find(filter).next(function(err, doc) {
        console.log("First doc in the cursor");
        console.log(doc);
     });
    ```

因为**next**一次只返回一个文档，所以在本例中，我们运行它三次来检查前三个文档。

在本章的示例、练习和活动中，我们将学习如何使用这三种方法。但是，必须注意还有其他更高级的模式。

您还可以通过将这些命令放置在**find（…）**之后，从 mongo shell 中完成相同的**sort**和**limit**功能；您应该熟悉 shell 中以前的查询：

```js
database.collection("movies").find(filter).limit(5).sort([['title', 1]]).next   (function(err, doc) {…}
```

## 练习 8.02：构建 Node.js 驱动程序查询

在本练习中，您将基于*练习 8.01**中的场景，创建与 Node.js 驱动程序*的连接，该驱动程序允许您连接到 mongo 服务器。如果您要提供一个 Node.js 应用程序，允许电影院员工查询和投票电影，那么您的脚本将需要使用给定的条件查询数据库，并以易于阅读的格式返回结果。对于此场景，必须为其获取结果的查询如下所示：

*在浪漫类中找到两部电影，每部电影只放映片名。*

您可以通过执行以下步骤在 Node.js 中完成此操作：

1.  创建一个名为**Exercise8.02.js**的新 JavaScript 文件。
2.  为了不必从头重写所有内容，请将**Exercise8.01.js**的内容复制到新脚本中。否则，请在新文件中重写连接代码。
3.  为了保持代码干净，创建新变量来存储**数据库名**和**集合名**。记住，因为这些不会在我们的脚本中改变，所以必须使用**const**关键字

    ```js
    const databaseName = "sample_mflix";
    const collectionName = "movies";
    ```

    将它们声明为常量
4.  现在，创建一个新的**常量**来存储我们的查询文档；您应该熟悉从前面的章节中创建这些内容：

    ```js
    const query = { genres: { $all: ["Romance"]} };
    ```

5.  With all your variables defined, create our database object:

    ```js
    const database = client.db(databaseName);
    ```

    现在，您可以使用以下语法发送查询。使用**each**模式，传入回调函数来处理每个文档。如果这看起来很奇怪，不要担心；您将在下一节中详细了解这一点。记住使用**limit**只返回两个文档，**项目**只输出**标题**，因为这是我们场景的要求：

    ```js
    database.collection(collectionName).find(query).limit(2).project({title:   1}).each(function(err, doc) {
        if(doc) {

        } else {
            client.close(); // Close our connection.
            return false;   // End the each loop.
        }
     });
    ```

6.  Inside your callback function, use **console.log** to output each of the documents that was returned by our query:

    ```js
    if(doc){
               console.log('Current doc');
               console.log(doc);
    }  
    ```

    您的最终代码应该如下所示：

    ```js
    const MongoClient = require('mongodb').MongoClient;
    const url = 'mongodb+srv://username:password@server-  abcdef.gcp.mongodb.net/test';
    const client = new MongoClient(url);
    const databaseName = "sample_mflix";
    const collectionName = "movies";
    const query = { genres: { $all: ["Romance"]} };
    // Open the connection using the .connect function.
    client.connect(function(err) {
        // Within the connection block, add a console.log to confirm the       connection
        console.log('Connected to MongoDB with NodeJS!');
        const database = client.db(databaseName);
        database.collection(collectionName).find(query).limit(2).project({title:      1}).each(function(err, doc) {
            if(doc) {
                console.log('Current doc');
                console.log(doc);
            } else {
                client.close(); // Close our connection.
                return false;   // End the each loop.
            }
         });
    })
    ```

7.  现在，使用**节点 Exercise8.02.js**运行脚本。您应该得到以下输出：

    ```js
    Connected to MongoDB with NodeJS!
    Our database connected alright!
    Current doc
    { _id: 573a1390f29313caabcd548c, title: 'The Birth of a Nation' }
    Current doc
    { _id: 573a1390f29313caabcd5b9a, title: "Hell's Hinges" }
    ```

在本练习中，您构建了一个 Node.js 程序，该程序对 MongoDB 执行查询，并在控制台中将结果返回给我们。虽然这是一个很小的步骤，我们可以在 Mango shell 中轻松地完成，但是这个脚本将为 MavigDB 的更高级和交互式的 No.js 应用程序奠定基础。

# Node.js 中的回调和错误处理

因此，我们成功地打开了与 MongoDB 的连接，并运行了一些简单的查询，但代码中可能有一些元素似乎不熟悉；例如，此处的语法为：

```js
.each(function(err, doc) {
        if(doc) {
            console.log('Current doc');
            console.log(doc);
        } else {
            client.close(); // Close our connection.
            return false;   // End the each loop.
        }
     });
```

这就是所谓的**回调**。它是一种创建按特定顺序执行的代码的方法。例如，在前面的代码片段中，我们指示**MongoClient**，一旦它完成了自己的内部逻辑，就应该在我们作为第二个参数传入的函数中执行代码。第二个参数称为回调。回调是作为参数传递给首先执行的另一个函数的额外函数（代码块）。

回调允许您指定仅在函数完成后执行的逻辑。我们必须在 Node.js 中使用回调，而不是简单地让语句有序，原因是 Node.js 是异步的，这意味着当我们调用**connect**等函数时，它不会阻止执行。将执行脚本中接下来的内容。这就是我们使用回调的原因：确保下一步等待连接完成。还有其他现代模式可以用来代替回调，例如**承诺**和**等待/异步**。然而，考虑到本书的范围，我们将在本章中只讨论回调，并学习如何处理从驱动程序返回的错误。

# Node.js 中的回调

回调通常在视觉上令人困惑，难以概念化；然而，从根本上说，它们非常简单。回调函数是作为第二个函数的参数提供的函数，它允许两个函数按顺序运行。

在不使用回调（或任何其他同步模式）的情况下，这两个函数将紧接着另一个函数开始执行。当使用驱动程序时，这会产生错误，因为第二个函数可能依赖于第一个函数在开始之前完成。例如，在建立连接之前，您无法查询数据。让我们看一下回调的细分：

![Figure 8.4: Breakdown of a callback ](img/B15507_08_04.jpg)

图 8.4：回调的细分

现在，将其与我们的**查找**查询代码进行比较：

![Figure 8.5: Breakdown of a MongoDB callback ](img/B15507_08_05.jpg)

图 8.5:MongoDB 回调的分解

如您所见，存在相同的结构，只是回调函数的参数不同。您可能想知道我们如何知道在特定回调中使用哪些参数。答案是传入回调函数的参数由我们提供回调函数的第一个函数决定。这也许是一个令人困惑的句子，但它的意思是：当将函数 fA 作为参数传递给第二个函数 fB 时，fA 的参数由 fB 提供。让我们再次检查我们的实际示例，以确保我们理解这一点：

```js
database.collection(collectionName).find(query).limit(2).project({title: 1}).each   (function(err, doc) {
        if(doc) {
            console.log('Current doc');
            console.log(doc);
        } else {
            client.close(); // Close our connection.
            return false;   // End the each loop.
        }
     });
```

因此，我们的回调函数**函数（err，doc）{…}**作为驱动程序函数**的参数提供给每个**。这意味着**每个**都会对结果集中的每个文档运行我们的回调函数，每次执行时都会传入**err**（错误）和**doc**（文档）参数。下面是相同的代码，但有一些日志来演示执行顺序：

```js
console.log('This will execute first.')
database.collection(collectionName).find(query).limit(2).project({title: 1}).each   (function(err, doc) {
console.log('This will execute last, once for each document in the result.')
        if(doc) {
        } else {
            client.close(); // Close our connection.
            return false;   // End the each loop.
        }
     });
console.log('This will execute second.');
```

如果我们使用**节点 3_Callbacks.js**运行此代码，我们可以在输出中看到执行顺序：

```js
Connected to MongoDB with NodeJS!
This will execute first.
This will execute second.
This will execute last, once for each doc.
This will execute last, once for each doc.
This will execute last, once for each doc.
```

回调有时是需要熟悉的复杂模式，并且越来越多地被更高级的 Node.js 模式所取代，例如**promises**和**async/await**。更好地熟悉这些模式的最好方法是使用它们，所以如果你还没有 100%地适应它们，不要担心。

## Node.js 中的基本错误处理

在我们检查回调时，您可能已经注意到有一个参数我们尚未描述：**err**。在 MongoDB 驱动程序中，大多数可以在 mongo shell 中返回错误的命令也可以在驱动程序中返回错误。回调时，**err**参数始终存在；但是，如果没有错误，**err**的值为**null**。这种在异步代码中捕获错误的“错误优先”模式是 NodeJS 的标准实践。

例如，假设您创建了一个将用户电话号码输入客户数据库的应用程序，两个不同的用户输入相同的电话号码。当您尝试运行 insert 时，MongoDB 将返回重复的密钥错误。此时，作为 Node.js 应用程序的创建者，您有责任正确处理该错误。要检查我们查询中的任何错误，我们可以检查**err**是否为**null**。您可以使用以下语法轻松地检查此问题：

```js
database.collection(collectionName).find(query).limit(2).project({title: 1}).each   (function(err, doc) {
        if(err) {
            console.log('Error in query.');
            console.log(err);
            client.close();
            return false;
        }
        else if(doc) {
            console.log('Current doc');
            console.log(doc);
        } else {
            client.close(); // Close our connection.
            return false;   // End the each loop.
        }
     });
```

您可能认识到，这与我们在使用**每个**时检查是否有更多文档时使用的语法相同。与我们检查查询错误的方式类似，我们客户机中的**connect**函数也向我们的**回调**函数提供了一个错误，在我们运行任何进一步的逻辑之前，应该检查该错误：

```js
// Open the connection using the .connect function.
client.connect(function(err) {
    if(err) {
        console.log('Error connecting!');
        console.log(err);
        client.close();
    } else {
        // Within the connection block, add a console.log to confirm the           connection
        console.log('Connected to MongoDB with NodeJS!');
        client.close(); // Close our connection at the end.
    }
})
```

笔记

建议使用回调来检查传入的参数，然后再尝试使用它们。在**find**命令的情况下，这意味着检查是否存在错误并检查文档是否已返回。在编写针对 MongoDB 的代码时，最好验证从数据库返回的所有内容，并记录错误以进行调试。

但我们不仅可以在回调中验证代码的准确性。我们还可以检查非回调函数，以确保一切正常，例如，当我们创建**数据库**对象时：

```js
    const database = client.db(databaseName);
    if(database) {
        console.log('Our database connected alright!');
    }
```

根据您试图使用 MongoDB 完成的任务，您的错误处理可能与前面的示例一样简单，或者您可能需要更高级的逻辑。但是，在本章的范围内，我们将只讨论基本的错误处理。

## 练习 8.03：Node.js 驱动程序的错误处理和回调

在*练习 8.02**构建 Node.js 驱动程序查询*中，您创建了一个成功连接到 MongoDB 服务器的脚本，并生成了一个查询。在本练习中，您将向代码中添加错误处理，这意味着如果出现任何错误，它将允许您识别或修复问题。您将通过修改查询以使其失败来测试此处理。您可以通过以下步骤在 Node.js 中完成此操作：

1.  创建一个名为**Exercise8.03.js**的新 JavaScript 文件。
2.  为了不必从头重写所有内容，请将**Exercise8.02.js**的内容复制到新脚本中。否则，请在新文件中重写连接和查询代码。
3.  在 connect 回调中，检查**err**参数。如果确实有错误，请确保使用**console.log**：

    ```js
    client.connect(function(err) {
        if(err) {
            console.log('Failed to connect.');
            console.log(err);
            return false;
        }
        // Within the connection block, add a console.log to confirm the       connection
        console.log('Connected to MongoDB with NodeJS!');
    ```

    输出
4.  在运行查询之前添加一些错误检查，以确保成功创建数据库对象。如果确实有错误，请使用**console.log**输出。使用**！**检查某物是否不存在的语法：

    ```js
        const database = client.db(databaseName);
        if(!database) {
            console.log('Database object doesn't exist!');
            return false;
        }
    ```

5.  In the **each** callback, check the **err** parameter to make sure each document was returned without error:

    ```js
        database.collection(collectionName).find(query).limit(2).project({title: 1}).each(function(err, doc) {
            if(err) {
                console.log('Query error.');
                console.log(err);
                client.close();
                return false;
            }
            if(doc) {
                console.log('Current doc');
                console.log(doc);
            } else {
                client.close(); // Close our connection.
                return false;   // End the each loop.
            }
         });
    ```

    此时，您的整个代码应该如下所示：

    ```js
    const MongoClient = require('mongodb').MongoClient;
    const url = 'mongodb+srv://username:password@server-  fawxo.gcp.mongodb.net/test?retryWrites=true&w=majority';
    const client = new MongoClient(url);
    const databaseName = "sample_mflix";
    const collectionName = "movies";
    const query = { genres: { $all: ["Romance"]} };
    // Open the connection using the .connect function.
    client.connect(function(err) {
        if(err) {
            console.log('Failed to connect.');
            console.log(err);
            return false;
        }
        // Within the connection block, add a console.log to confirm the       connection
        console.log('Connected to MongoDB with NodeJS!');
        const database = client.db(databaseName);
        if(!database) {
            console.log('Database object doesn't exist!');
            return false;
        }
        database.collection(collectionName).find(query).limit(2).project({title:      1}).each(function(err, doc) {
            if(err) {
                console.log('Query error.');
                console.log(err);
                client.close();
                return false;
            }
            if(doc) {
                console.log('Current doc');
                console.log(doc);
            } else {
                client.close(); // Close our connection.
                return false;   // End the each loop.
            }
         });
    })
    ```

6.  在添加错误之前，请使用节点**Exercise8.03.js**运行脚本。您应该得到以下输出：

    ```js
    Connected to MongoDB with NodeJS!
    Current doc
    { _id: 573a1390f29313caabcd548c, title: 'The Birth of a Nation' }
    Current doc
    { _id: 573a1390f29313caabcd5b9a, title: "Hell's Hinges" }
    ```

7.  修改查询以确保生成错误：

    ```js
    const query = { genres: { $thisIsNotAnOperator: ["Romance"]} };
    ```

8.  Run the script using node **Exercise8.03.js**. You should get the following output:

    ![Figure 8.6: Output after the script is run (truncated for brevity) ](img/B15507_08_06.jpg)

图 8.6：运行脚本后的输出（为简洁起见，截断）

在本练习中，您扩展了 Node.js 应用程序，以便它捕获并处理在 Node.js 环境中运行 MongoDB 查询时可能遇到的错误。这将允许您创建更健壮、容错和可扩展的应用程序。

# 高级查询

在上一节中，我们连接到 MongoDB 服务器，查询一些数据，输出数据，并处理遇到的任何错误。然而，如果应用程序或脚本只能执行读取操作，那么它的实用性就会受到限制。在本节中，我们将在 MongoDB 驱动程序中应用**写入**和**更新**操作。此外，我们将研究如何使用函数语法为最终应用程序创建可重用的代码块。

## 使用 Node.js 驱动程序插入数据

与 mongo shell 类似，我们可以使用**insertOne**或**insertMany**函数将数据写入我们的集合。对集合对象调用这些函数。我们需要传递给这些函数的唯一参数是**insertOne**中的单个文档，或者**insertMany**中的文档数组。下面是一段代码片段，其中包括如何使用带回调的**insertOne**和**insertMany**。现在，您应该能够认识到这是一个不完整的代码片段。要执行以下代码，您需要添加我们在本章前面了解的基本连接逻辑。到目前为止，这看起来应该很熟悉：

```js
    database.collection(collectionName).insertOne({Hello:      "World"}, function(err, result) {
        // Handle result.
    })
    database.collection(collectionName).insertMany([{Hello: "World"},       {Hello: "Mongo"}], function(err, result) {
        // Handle result.
    })
```

与**find**一样，我们将回调传递给这些函数以处理操作结果。Insert 操作将返回一个错误（可能是**null**）和一个结果，详细说明 Insert 操作是如何执行的。例如，如果我们在上一个练习的结果的基础上构建并记录一个**insertMany**操作的结果，这将产生以下输出：

```js
    database.collection(collectionName).insertOne({Hello: "World"},       function(err, result) {
        console.log(result.result);
   client.close();
    })
```

我们可以在输出中看到一个**结果**对象，如*图 8.7*。

笔记

我们只输出整个**结果**对象的一个子集，其中包含更多关于我们操作的信息。例如，我们正在记录**result.result**，它是整个**result**对象中的一个子文档。这只是本例的范围。在其他用例中，您可能需要有关操作结果的更多信息：

![Figure 8.7: Output showing a subset of the overall result object ](img/B15507_08_07.jpg)

图 8.7：显示整体结果对象子集的输出

## 使用 Node.js 驱动程序更新和删除数据

使用驱动程序更新和删除文档遵循与**插入**函数相同的模式，**收集**对象通过回调，检查错误，并分析操作结果。所有这些函数都将返回一个结果文档。但是，在这三种操作之间，结果文档中包含的格式和信息可能有所不同。让我们看一些例子。

下面是一些更新文档的示例代码（也构建在前面的连接代码之上）。我们可以使用**updateOne**或**updateMany**：

```js
    database.collection(collectionName).updateOne({Hello: "World"}, {$set: {Hello       : "Earth"}}, function(err, result) {
        console.log(result.modifiedCount);
        client.close();
    })
```

如果我们运行这段代码，我们得到的输出可能如下所示：

```js
Connected to MongoDB with NodeJS!
1
```

现在，让我们看一个删除文档的示例。与其他函数一样，我们可以使用**deleteOne**或**deleteMany**。请记住，此代码段是我们为*练习 8.03*、*错误处理和 Node.js 驱动程序*回调创建的较大代码的一部分：

```js
    database.collection(collectionName).deleteOne({Hello: "Earth"}, function(err, result) {
        console.log(result.deletedCount);
        client.close();
    })
```

如果我们运行这段代码，我们的输出如下：

```js
Connected to MongoDB with NodeJS!
1
```

正如您所看到的，所有这些操作都遵循类似的模式，并且在结构上与发送到 mongo shell 的相同命令非常接近。主要区别在于回调，在回调中，我们可以对操作结果运行自定义逻辑。

## 编写可重用函数

到目前为止，在我们的示例和练习中，我们始终执行单个操作并输出结果。但是，在更大、更复杂的应用程序中，您需要在同一程序中运行许多不同的操作，具体取决于上下文。例如，在应用程序中，您可能希望多次运行同一查询并比较相应的结果，或者希望根据第一个查询的输出修改第二个查询。

我们将在这里创建自己的函数。您已经编写了一些用作回调的函数，但在本例中，我们将编写可以随时调用的函数，无论是为了工具还是为了保持代码干净和独立。让我们看一个例子。

让我们通过下面的代码片段更好地理解这一点，它运行三个非常相似的查询。这些查询之间的唯一区别是每个查询中的单个参数（评级）：

```js
database.collection(collectionName).find({name: "Matthew"}).each(function(err,   doc) {});
database.collection(collectionName).find({name: "Mark"}).each(function(err, doc)   {});
database.collection(collectionName).find({name: "Luke"}).each(function(err, doc)   {})
```

让我们用一个函数来简化和清理这段代码。我们使用与变量相同的语法声明一个新函数。因为这个函数没有改变，所以我们可以将它声明为**const**。对于函数的值，我们可以使用我们在前面的示例中熟悉的回调语法（本章前面的*回调*部分中的示例）：

```js
const findByName = function(name) {

}
```

现在，让我们将逻辑添加到这个函数中，在花括号之间：

```js
const findByName = function(name) {
    database.collection(collectionName).find({name:       name}).each(function(err, doc) {})
}
```

但有些事情不太对劲。在创建数据库对象之前，我们正在引用该数据库对象。我们必须将该对象作为参数传递到此函数中，因此让我们调整函数以实现此目的：

```js
const findByName = function(name, database) {
    database.collection(collectionName).find({name: name}).each(function(err,       doc) {})
}
```

现在，我们可以将三个查询替换为三个函数调用：

```js
const findByName = function(name, database) {
    database.collection(collectionName).find({name: name}).each(function(err, doc       ) {})
}
findByName("Matthew", database);
findByName("Mark", database);
findByName("Luke", database);
```

在本章中，为了简单起见，我们将不太深入地创建模块化的功能代码。但是，如果您想进一步改进此代码，可以使用数组和循环的**来为每个值运行函数，而不必调用它三次。**

## 练习 8.04：使用 Node.js 驱动程序更新数据

考虑到*简介*部分中的场景，您已经从起点取得了相当大的进步。电影公司的最终应用程序需要能够通过运行更新操作为电影添加投票。您还没有完全准备好添加此逻辑。但是，为了证明您可以完成这一点，请编写一个脚本来更新数据库中的多个不同文档，并创建一个可重用函数来完成此操作。在本练习中，您需要更新**第 8 章【练习 4】集合中的以下名称。您将使用此唯一的集合来确保数据在更新期间不会因其他活动而损坏：**

*内德·斯塔克对格雷格·斯塔克，罗伯·斯塔克对鲍勃·斯塔克，布兰·斯塔克对布拉德·斯塔克。*

您可以通过执行以下步骤在 Node.js 中完成此操作：

1.  首先，确保存在要更新的正确文档。使用 mongo shell 直接连接到服务器，并执行以下代码段检查这些文档：

    ```js
    db.chapter8_Exercise4.find({ $or: [{name: "Ned Stark"}, {name: "Robb Stark"}, {name: "Bran Stark"}]});
    ```

2.  如果前面查询的结果为空，则使用此代码段添加要更新的文档：

    ```js
    db.chapter8_Exercise4.insert([{name: "Ned Stark"}, {name: "Bran Stark"}, {name: "Robb Stark"}]);
    ```

3.  现在，要创建脚本，请退出 mongo shell 连接并创建一个名为**Exercise8.04.js**的新 JavaScript 文件。为了不必从头重写所有内容，请将**Exercise8.03.js**的内容复制到新脚本中。否则，请在新文件中重写连接代码。如果您从*练习 8.03*、*错误处理和 Node.js 驱动程序*的回调中复制了代码，请删除查找查询的代码。
4.  将收藏从电影更改为**第 8 章【练习 4】**：

    ```js
    const collectionName = "chapter8_Exercise4";
    ```

5.  在脚本开始时，在连接之前，创建一个名为**updateName**的新函数。此函数将以数据库对象、客户端对象以及**旧名称**和**新名称**作为参数：

    ```js
    const updateName = function(client, database, oldName, newName) {
    }
    ```

6.  在**updateName**函数中，添加运行更新命令的代码，该命令将更新包含**oldName**名称字段的文档，并将值更新为**newName**：

    ```js
    const updateName = function(client, database, oldName, newName) {
        database.collection(collectionName).updateOne({name: oldName}, {$set: {name: newName}}, function(err, result) {
            if(err) {
                console.log('Error updating');
                console.log(err);
                client.close();
                return false;
            }
            console.log('Updated documents #:');
            console.log(result.modifiedCount);
            client.close();
        })
    };
    ```

7.  现在，在 connect 回调中，运行新函数三次，每次更新三个名称：

    ```js
        updateName(client, database, "Ned Stark", "Greg Stark");
        updateName(client, database, "Robb Stark", "Bob Stark");
        updateName(client, database, "Bran Stark", "Brad Stark");
    ```

8.  此时，您的整个代码应该如下所示：

    ```js
    const MongoClient = require('mongodb').MongoClient;
    const url = 'mongodb+srv://mike:password@myAtlas-fawxo.gcp.mongodb.net/test?retryWrites=true&w=majority';
    const client = new MongoClient(url);
    const databaseName = "sample_mflix";
    const collectionName = "chapter8_Exercise4";
    const updateName = function(client, database, oldName, newName) {
        database.collection(collectionName).updateOne({name: oldName}, {$set: {name: newName}}, function(err, result) {
            if(err) {
                console.log('Error updating');
                console.log(err);
                client.close();
                return false;
            }
            console.log('Updated documents #:');
            console.log(result.modifiedCount);
            client.close();
        })
    };
    // Open the connection using the .connect function.
    client.connect(function(err) {
        if(err) {
            console.log('Failed to connect.');
            console.log(err);
            return false;
        }
        // Within the connection block, add a console.log to confirm the connection
        console.log('Connected to MongoDB with NodeJS!');
        const database = client.db(databaseName);
        if(!database) {
            console.log('Database object doesn't exist!');
            return false;
        }

        updateName(client, database, "Ned Stark", "Greg Stark");
        updateName(client, database, "Robb Stark", "Bob Stark");
        updateName(client, database, "Bran Stark", "Brad Stark");
    })
    ```

9.  使用**节点 Exercise8.04.js**运行脚本。您应该得到以下输出：

    ```js
    Connected to MongoDB with NodeJS!
    Updated documents #:
    1
    Updated documents #:
    1
    Updated documents #:
    1
    ```

在过去的四节中，您已经学习了如何创建连接到 MongoDB 的 Node.js 脚本，在易于使用的函数中运行查询，以及处理我们可能遇到的任何错误。这是一个基础，在这个基础上，您可以使用 MangoDB 数据库构建许多脚本来执行复杂的逻辑。然而，到目前为止，在我们的示例中，我们的查询参数总是硬编码到我们的脚本中，这意味着我们的每个脚本只能满足特定的用例。

这并不理想。使用 Node.js 之类的驱动程序的最大优点之一是能够使用单个应用程序解决大量问题。为了扩大脚本的范围，我们将使用用户输入创建动态查询，能够解决用户的问题，而无需重写和分发新版本的程序。在本节中，我们将学习如何接受用户输入、处理用户输入并从中构建动态查询。

笔记

在大多数大型、生产就绪的应用程序中，用户输入将以**图形用户界面**（**GUI**的形式出现。这些 GUI 将简单的用户选择转换为复杂的相关查询。然而，构建 GUI 相当棘手，超出了本书的范围。

## 从命令行读取输入

在本节中，我们将从应用程序的命令行获取输入。幸运的是，Node.js 为我们提供了一些简单的方法来从命令行读取输入并在代码中使用它。Node.js 提供了一个名为**readline**的模块，允许我们请求用户输入，接受该输入，然后使用它。通过在文件顶部添加以下行，可以将**readline**加载到脚本中。在使用**readline**时，您必须始终创建一个接口：

```js
const readline = require('readline');
const interface = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
});
```

现在，我们可以要求用户提供一些输入。**readline**为我们提供了多种处理输入的方法。然而，目前最简单的方法是使用**疑问句**函数，如下例所示：

```js
interface.question('Hello, what is your name? ', (input) => {
    console.log(`Hello, ${input}`);
    interface.close();
  });
```

笔记

**${input}**语法允许我们在字符串中嵌入变量。使用此键时，请确保使用反勾号，**`**（如果您不确定在标准 QWERTY 键盘上的何处可以找到此键，则它与**1**键左侧的~符号共享一个键。）

如果我们运行此示例，我们将得到类似以下内容的输出：

```js
Chapter_8> node example.js 
Hello, what is your name? Michael
Hello, Michael
```

如果要创建更长的提示，最好使用**console.log**输出大部分输出，然后为**readline**提供一个更小的问题。例如，假设我们在请求用户输入之前发送了一条长消息。我们可以将其定义为一个变量，并在提问之前记录它：

```js
const question = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum?"
interface.question(question, (input) => {
    console.log(`Hello, ${input}`);
    interface.close();
  });
```

这样，跨多个输入修改和重用消息就很容易了。

笔记

Node.js 中有许多不同的库和模块用于处理输入。然而，为了简单起见，我们将在本章中使用**readline**。

## 创建互动循环

因此，我们有一个简单的方法向用户提问并接受他们的一些输入。但是，如果我们每次都要从命令行运行应用程序，那么我们的应用程序将不会非常有用。如果我们可以运行一次程序，并根据不同的输入执行多次运行，那么它将更加有用。

为了实现这一点，我们可以创建一个交互式循环，这意味着应用程序将不断请求输入，直到满足退出条件。为了确保我们保持循环，我们可以将提示符放在一个调用自身的函数中，该函数将在其块内继续运行代码，直到所述的退出条件变为**true**。这将为代码用户提供更好的体验。下面是一个使用前面提到的**读线**的交互式循环示例：

```js
const askName = function() {
    interface.question("Hello, what is your name?", (input) => {
        if(input === "exit") {
            return interface.close(); // Will kill the loop.
        }
        console.log(`Hello, ${input}`);
        askName();

      });
}
askName(); // First Run.
```

注意此处的退出条件：

```js
        if(input === "exit") {
            return interface.close(); // Will kill the loop.
        }
```

确保在任何循环中都有退出条件是至关重要的，因为这允许用户退出应用程序。否则，它们将永远卡在循环中，可能会消耗计算机的资源。

笔记

在代码中编写循环时，可能会意外创建一个没有退出条件的无限循环。如果发生这种情况，您可能必须杀死外壳或终端。您可以在 macOS 上尝试*Ctrl+C*或*Cmd+C*退出。

如果您运行前面的示例，您将能够在退出之前多次回答该问题；例如：

```js
Chapter_8> node examples.js 
Hello, what is your name?Mike
Hello, Mike
Hello, what is your name?John
Hello, John
Hello, what is your name?Ed
Hello, Ed
Hello, what is your name?exit
```

## 练习 8.05：处理 Node.js 中的输入

在本练习中，您将创建一个小的 Node.js 应用程序，允许您询问用户的姓名。您可以将其视为一个基本的登录系统。此应用程序应在交互式循环中运行；用户的选项如下所示：

*   **登录***询问并存储用户名*
*   **谁**（*输出用户名*
*   **退出***结束申请*

通过执行以下步骤创建此应用程序：

1.  创建一个名为**Exercise8.05.js**的新 JavaScript 文件。
2.  导入**读线**模块：

    ```js
    const readline = require('readline');
    const interface = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    ```

3.  定义选项和用户变量。
4.  现在，定义一个名为**登录**的新函数，该函数将用户作为参数。函数首先请求用户并将其存储在变量中：

    ```js
    const login = function() {
        interface.question("Hello, what is your name?", (name) => {
            user = name;
      prompt();
          });
    }
    ```

5.  创建一个名为**who**的新函数，该函数输出**用户**：

    ```js
    const who = function () {
        console.log(`User is ${user}`);
        prompt();
    }
    ```

6.  在选择不等于退出的条件下创建一个输入循环：

    ```js
    const prompt = function() {
        interface.question("login, who OR exit?", (input) => {
            if(input === "exit") {
                return interface.close(); // Will kill the loop.
            }   
            prompt();
          });
    }
    ```

7.  之后，使用 if 关键字检查他们的选择是否与“**登录**匹配”。如果找到匹配项，则运行**登录**功能：

    ```js
            if(input === "login") {
                login();
            }
    ```

8.  Then, use the if keyword to check whether their choice matches "**who**". If we find a match, then print out the **user** variable:

    ```js
            if(input === "who") {
                who();
            }
    ```

    您的最终代码应该如下所示：

    ```js
    const readline = require('readline');
    const interface = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    var choice;
    var user;
    var cinema;
    const login = function() {
        interface.question("Hello, what is your name?", (name) => {
            user = name;
            prompt();
          });
    }
    const who = function () {
        console.log(`User is ${user}`)
        prompt();
    }
    const prompt = function() {
        interface.question("login, who OR exit?", (input) => {
            if(input === "exit") {
                return interface.close(); // Will kill the loop.
            }   
            if(input === "login") {
                login();
            }
            if(input === "who") {
                who();
            }
          });
    }
    prompt();
    ```

9.  使用**节点 Exercise8.05.js**运行代码并输入一些输入。现在，您应该能够与应用程序交互。下面是一个例子：

    ```js
    Chapter_8> node .\Exercise8.06.js
    login, who OR exit?login
    Hello, what is your name?Michael
    login, who OR exit?who
    User is Michael
    login, who OR exit?exit
    ```

在本练习中，您使用 Node.js 创建了一个基本的交互式应用程序，用户可以从三个输入中进行选择并相应地输出结果。

## 活动 8.01：创建一个简单的 Node.js 应用程序

您已被一家电影院公司委托创建一个应用程序，该应用程序允许客户在选定的类别中列出收视率最高的电影。客户应该能够在指定的命令行列表中提供类别和响应。他们还需要提供要在“收藏夹”字段中捕获的他们最喜爱的电影的详细信息。最后，完成所有这些操作后，客户应该能够**退出**应用程序，如下所示：

*   **“列表”**：要求用户输入一个流派，然后查询该流派前五名电影的数据库，输出**ID**、**标题**和**收藏夹**字段。
*   **“收藏夹”**：要求用户提供电影 ID，然后使用收藏夹字段更新该电影。
*   **“退出”**：退出交互循环和应用程序。

此活动旨在创建一个小型 Node.js 应用程序，向用户公开一个交互式输入循环。在这个循环中，用户可以按类型查询数据库中的信息，也可以按 ID 更新记录。您需要确保还可以处理用户输入中可能出现的任何错误。

您可以通过多种方式完成此目标，但请记住我们在本章中学到的内容，并尝试创建简单易用的代码。

以下高级步骤将帮助您完成此任务：

1.  导入**readline**和 MongoDB 库。
2.  创建您的**读线**界面。
3.  声明您需要的任何变量。
4.  Create a function called list that will fetch the top five highest rated films for a given genre, returning the **title**, **favorite**, and **ID** fields.

    笔记

    您需要在此函数中请求类别。查看*练习 8.05*中的登录方法，*处理 Node.js*中的输入，了解更多信息。

5.  创建一个名为**收藏夹**的函数，该函数将按标题更新文档，并向文档中添加一个名为**收藏夹**的键，该键的值为**true**。（*提示：您需要使用与列表功能相同的方法在此函数中请求标题。*
6.  创建 MongoDB 连接、数据库和集合。
7.  根据用户的输入创建交互式 while 循环。如果您不确定如何执行此操作，请参考*练习 8.05*中的提示功能*处理 Node.js*中的输入。
8.  在交互循环中，使用 if 条件检查输入。如果找到有效输入，请运行相关函数。
9.  Remember, you will need to pass the database and client objects through to each of your functions, including any time you call **prompt()**. To test your output, run the following commands:

    **列表**

    **恐怖**

    **最爱**

    **列表**

    **出口**

    预期产出如下：

    笔记

    您可能会注意到标题**Nosferatu**在输出中出现了两次。如果你看一下**值，你会发现这实际上是两部同名的独立电影。在 MongoDB 中，可能有许多不同的文档在其字段中共享相同的值。**

    **![Figure 8.8: Final output (truncated for brevity) ](img/B15507_08_08.jpg)**

 **图 8.8：最终输出（为简洁起见截断）

笔记

此活动的解决方案可通过[此链接](14.html#_idTextAnchor475)找到。

# 总结

在本章中，我们介绍了使用 Node.js 驱动程序创建 MongoDB 驱动的应用程序所必需的基本概念。使用这些基础知识，可以创建大量脚本来对数据库执行查询和操作。我们甚至学会了处理错误和创建交互式应用程序。

尽管您可能不需要编写或阅读此类应用程序作为日常职责的一部分，但全面了解这些应用程序的构建方式可以让您对 MongoDB 开发以及您的同行如何与您的 MongoDB 数据交互有独特的见解。

但是，如果您希望增加您在 Node.js 驱动程序方面的专业知识，这只是一个开始。有许多不同的模式、库和最佳实践可用于针对 MongoDB 开发 Node.js 应用程序。这只是 Node.js 旅程的开始。

在下一章中，我们将深入探讨如何提高 MongoDB 交互的性能，并创建高效的索引来加速查询。我们将介绍的另一个有用功能是使用**explain**以及如何最好地解释其输出。**