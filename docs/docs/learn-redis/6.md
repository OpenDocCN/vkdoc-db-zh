# 六、网络应用中的 Redis

当前场景中的 Web 是当今世界交流的普遍平台。从简单的门户到大规模可扩展的电子商务、协作网站、银行、社交媒体、移动网络上的 web 应用程序等等，每个人都将 web 协议用作与外部世界交互的界面。我们通常所看到的 web 平台只是 web 操作下应用程序的一小部分，后端 web 应用程序（如供应链管理、订单管理、在线、离线分析等）也是 web 应用程序或使用 web 协议集成，例如 HTTP、SOAP、REST 等。

web 成功的原因之一是其有效的简单性、开放的标准和可操作的多种渠道。它的流行迫使人们和公司推出简单、经济高效、高性能、易于维护和开发的解决方案。这种新一代软件应该具有内在或外在的能力，以便能够很好地扩展和执行。

Redis 更像是一把瑞士军刀，它是多方面的，是我们在前几章中看到的那些功能的证明。在本章中，我们将为 web 域中使用的组件扩展和映射 Redis 的功能，并为构成任何 web 应用程序固有部分的组件创建一些概念证明。

为了更好地理解 Redis 的概念，让我们制作一个示例 web 应用程序，并将 Redis 用作数据存储。此示例 web 应用程序绝不是一个完整的端到端 web 应用程序，而是旨在强调 Redis 可以派上用场的领域。该解决方案本身在功能方面并不完整，但打算成为一个演示，实践者可以继续并扩展它。

**简单电子商务**，我们打算称之为演示网站，是一个由 Redis 支持的网站，没有网页，但通过简单的服务进行交流。其思想是公开简单的服务，而不是引入网页（包含 HTML、CSS 等）来将服务与表示层分离。随着我们越来越接近单页应用程序的时代，我们必须采取这样一种方法：驻留在客户机浏览器内存中的应用程序进行所有协调，而传统的 web 服务器通过其公开的服务为请求提供服务。这种机制的优点是开发和测试变得容易，因为每个服务都独立于其他服务，并且与 web 应用程序的表示方面没有紧密耦合。由于我们都曾经参与过 web 开发，我们可以理解当我们看到一个 bug 时，以及当我们花费大量时间调试问题时，我们所面临的挫折，无论问题是由于客户端代码还是它调用的业务方法引起的。随着单个页面应用程序功能的提升，这个问题可以在很大程度上得到解决，因为业务方法作为独立服务公开，并且可以与表示组件分开测试。单页应用程序的一个显著特征是，它将大量计算活动从服务器端转移到客户端（浏览器），从而为服务器带来更多的计算资源。

# 简单电子商务——由 Redis 支持的电子商务网站

与其他电子商务站点一样，此示例电子商务站点具有注册用户可以浏览、购买等的产品。该网站还根据用户的浏览和购买习惯推荐产品。同时，该网站提供网站中发生的活动的实时统计信息，并为您提供进行实时和软实时分析的功能。所以，让我们开始破解并构建这个网站，就像在任何设计中一样，让我们将需求划分为以下命令：

*   **会话和目录管理**：以下命令作为服务提供：
    *   **注册用户**：命令名为`register`；此命令将用户注册到系统。
    *   **查看我的数据**：命令名为`mydata`；此命令将允许用户查看其数据。
    *   **编辑我的数据**：命令名为`editmydata`；此命令将允许用户编辑其数据。
    *   **登录用户**：命令名为`login`；此命令将登录用户并为用户生成与服务器通信的会话 ID。
    *   **重新登录用户**：命令名为`relogin`；此命令将再次记录用户，但会话 ID 将保持不变。用户的所有会话或配置文件数据也将保持不变。
    *   **注销用户**：命令名为`logout`；此命令将注销用户并终止其会话或配置文件数据。
    *   **添加到购物车**：命令名为`add2cart`；此命令将项目添加到购物车。
    *   **查看我的购物车**：命令名为`showmycart`；此命令将显示购物车中的项目。
    *   **编辑我的购物车**：命令名为`editcart`；此命令将编辑购物车中的用户首选项。
    *   **购买产品**：命令名称为`buy`；此命令将在用户的购物车中购买物品。对于当前的应用程序，我们不会带您去某个商户的网站，而是为您生成一份收据样本。我们的想法是进行分析，因此，当有人购买产品时，我们会对该产品给予积分，这将有助于我们的推荐服务。购买的信用点为`10`。
    *   **委托产品**：命令名为`commission`；此命令将调试产品并在系统中创建其配置文件。
    *   **显示产品**：命令名为`display`；此命令将显示产品。
    *   **浏览产品**：命令名为`browse`；此命令将记录用户当前浏览的产品。我们的想法是，当有人浏览该产品时，我们会为该产品提供积分，这将有助于我们的推荐服务。浏览的信用点为`1`。
*   **在线分析**：以下命令在此项下：
    *   **推荐**：命令名为`recommendbyproduct`；此命令将根据用户正在浏览的受欢迎程度推荐与当前产品类似的其他产品。
    *   **用户统计**：命令名为`stats`；此命令将显示用户的统计信息。
    *   **分类显示**：命令名称为`displaytag`；此命令将显示类别下的产品。
    *   **按类别历史显示**：命令名称为`taghistory`；此命令将按类别显示历史记录。
    *   **取书**：命令名为`visittoday`；这将给出一天中唯一访客的总数。
    *   **购书**：命令名为`purchasestoday`；这将给出一天内购买该商品的唯一访客总数。

这个简单的电子商务网站的设计非常简单。要了解整个应用程序，请查看下图：

![Simple e-commerce – a Redis backed e-commerce site](img/0123OS_06_01.jpg)

简单的电子商务网站设计

本练习的先决条件如下：

*   **客户端**：任何带有`REST`插件或 HTTP 客户端插件的浏览器。我将使用 Chrome 浏览器和名为`POSTMAN`的`REST`客户端插件。如果你对任何其他插件都很满意，那就请便吧。如果我们用一个纯 Java 程序（例如 ApacheHTTP 客户机）替换这个客户机，那么应用程序将不会出现任何问题。这个简单的电子商务应用程序中的服务是基于`Get`的。在生产系统中，我们应该有`POST`，但出于显示目的，这里选择`Get`。
*   **服务器**：任何 web 应用服务器。我们将使用 Tomcat。您可以使用您选择的任何 web 应用程序服务器，但是应该相应地创建 servlet。如果您想使用 Node.js 之类的东西，那么代码将相应地更改，但设计理念将保持不变。
*   **数据存储**：这里的数据存储不用说 Redis。

在深入研究代码之前，了解导致我们使用 Redis 的状态的演变过程是很重要的。如前所述，此 web 应用程序所基于的两个类别如下所述：

*   会议和目录管理
*   在线分析

让我们花些时间来了解它们是如何在一段时间内进化的，以及 Redis 是如何进入画面的。此后，我们将了解此应用程序的代码。

# 会话管理

每个 web 应用程序都以这样或那样的方式进行会话。会话管理捕获可供用户和用户使用的用户活动信息。用户可以使用购物车或愿望列表的信息，后端系统也可以使用相同的信息来分析用户偏好，并将促销和活动管理方案传回给用户。这是电子商务平台中常见的用例之一。会话管理中存储的信息始终是最新的信息，最终用户期望其性能，或者换句话说，用户将其最近的内存外包给系统，并期望系统处理它。最终用户可能不知道幕后发生的细节和活动的程度，但希望存储在会话中的信息能够像大脑一样快速有效地被处理。

在某些情况下，用户的期望甚至超过了他的大脑所能处理的；无论是购物车购物，还是把东西放在愿望清单上，或者提醒他可能已经忘记的某项活动。换句话说，与任何其他数据相比，最终用户最接近该数据。他们记住这些数据，并期望系统与之匹配，这将导致用户更加个性化地参与系统或网站。

![Session management](img/0123OS_06_02.jpg)

用户及其与电子商务平台的交互

前面的图是表示用户如何与系统（网站）交互。当用户浏览一个网站时，他/她知道自己在寻找什么。假设在我们的例子中，这是他正在寻找的音乐，在搜索音乐后，用户会将音乐曲目放在购物车中。用户也可能对相同类型的其他音乐 CD 感兴趣，或者对*评论部分*中其他买家的评论感兴趣。此时，用户可能对在购物车中购买他/她的音乐 CD 感兴趣，或者将其保存在购物车中以便在不久的将来购买。用户在这里期望的一件事是，当他再次登录系统时，系统应该记住他放在购物车中的产品。

这里发生了两件事。首先，用户与系统交互，系统通过存储用户的选择、记录用户的活动等进行响应。其次，用户推送了他可能感兴趣的信息，从而为他提供了广泛的选择，并教育他人们对产品的评论，从而帮助他做出决定。在本节中，我们将更多地讨论用户存储信息的部分，并称之为会话管理。

会话数据具有很高的重要性，并停留在用户的脑海中，但这些数据的生命周期很短（直到产品交付或注意力转移到另一个产品）。这就是会话管理的用武之地，在本节中，我们将更深入地探讨 Redis 如何帮助我们解决这个高度关键的问题。

要处理会话数据，最早也是最简单的选择是使用应用服务器本身的内存。早在那时，web 应用程序的功能有限，提供的服务也有限。应用服务器内存的使用是当今的趋势。但是，随着网络变得越来越容易访问，人们开始在日常生活中更多地使用网络，网站迅速发展，为了生存，网络应用程序之间的竞争必须存在。这要求 web 应用程序拥有更多的计算和内存资源。

![Session management](img/0123OS_06_03.jpg)

使用内存扩展 web 应用程序以存储会话数据

常见的技术是复制数据并平衡系统负载，以便所有 web 服务器处于相同的状态，并且可以满足来自任何 web 应用程序的请求。这种技术存在一些问题，因为会话管理与 web 服务器紧密耦合，它提供的可伸缩性有限，当并发性增加时，这种模式就变成了反模式。这种技术的另一个限制是，随着会话管理中数据的增长，这种模式被证明是有问题的，因为会话数据存储在内存中，可以分配给会话管理的内存量受到业务逻辑内存需求的质疑。

下一个逻辑步骤是将会话管理与执行业务逻辑的 web 应用程序服务器分离。这一步是正确的，因为现在它提供了更多的可伸缩性，因为 web 服务器不需要执行会话管理，而会话管理需要经常与对等服务器同步状态。

![Session management](img/0123OS_06_04.jpg)

使用 RDBMS 扩展 web 应用程序以存储会话数据

这种方法虽然方向正确，但存在一些问题，主要是选择使用的数据存储。RDBMS 用于存储关系数据，在处理这些类型的数据时非常有效。另一方面，会话数据更像是键值对，不具有事务数据所期望的那种关系。在 RDBMS 中存储会话数据的问题是性能受到了影响，因为 RDBMS 从来没有为此类数据设计过，尽管扩展 web 应用程序服务器要容易得多。

这个演进过程的下一步是使用一个提供可伸缩性和性能的数据存储。显而易见的选择是使用缓存引擎，它将信息存储在内存中，这样性能会更快，可伸缩性也会保持良好，因为会话数据与 web 应用程序服务器分离。

![Session management](img/0123OS_06_05.jpg)

使用缓存作为前端在 RDBMS 上扩展 web 应用程序以存储会话数据

这种方法的问题在于功能需求和可维护性。从可维护性的角度来看，缓存引擎依赖 RDBMS 进行数据持久性，因为大多数缓存引擎没有磁盘持久性，并且依赖 RDBMS 进行故障管理。有些缓存引擎提供持久性机制，但最大的问题是从功能的角度来看，因为它们将所有内容存储为键值，其中值是字符串。程序负责将字符串中的数据转换为他们感兴趣的信息模式，然后取出值。例如，为用户配置文件存储的值，该用户配置文件在会话数据中存储了数百个属性。如果用户要取出几个属性，那么在这种情况下，用户必须获取整个数据集，构造对象，然后获取所需的属性。另一个问题是，很多时候，我们需要一段固定时间的会话数据，之后，数据的可用性就不存在了。在这些情况下，缓存引擎和 RDBMS 并没有被证明是有益的，因为它们没有一个内置的机制，即“生存时间”用于存储数据。为了实现这个特性，我们必须编写一个触发器来清除 RDBMS 中的数据，然后从缓存中清除数据。

在这些情况下，Redis 很方便，我们以想要的方式存储信息，因为它提供了保存值的数据结构。在会话管理的情况下，我们可以有一个映射，在它下面对属性进行逻辑分组。如果需要取出值，可以选择要更改的值或向其添加更多属性。此外，Redis 的性能方面也使其适合于会话管理。Redis 还具有名为**生存时间**（**TTL**的功能，用于在时间结束后清理数据。通过这种方式，我们可以根据需要为所需的键提供单独的 TTL，并且还可以在运行时更改 TTL。Redis 可用于具有可扩展和高性能的会话管理。

![Session management](img/0123OS_06_06.jpg)

使用缓存作为前端在 RDBMS 上扩展 web 应用程序以存储会话数据

# 目录管理

目录管理是关于网站渴望提供的产品和项目的信息。目录管理下存储的信息可以是产品的成本、尺寸、颜色等，也就是产品的元信息。与会话信息不同，此信息以读取为中心。但与会话数据一样，目录数据也经历了从 RDBMS 系统开始的演变，因为当时缺乏存储数据的选择，RDBMS 系统是自然选择。RDBMS 系统的问题在于它没有提供性能。此外，以固定模式为中心的系统增加了问题，因为产品的元信息随着产品本身的变化而变化。有些产品有颜色、长度、宽度和高度，而有些产品有作者、页数和 ISBN。创建模式以适应这一需求总是很麻烦，而且在某个时候我们遇到了这个问题。

![Catalogue management](img/0123OS_06_07.jpg)

以 RDBMS 为数据存储的目录管理

克服这个固定模式问题的自然进化过程是以 XML 格式存储信息，并将这些信息缓存在某个缓存引擎中。这种机制帮助设计师和架构师克服了固定模式和性能的问题。但是这种技术也有它自己的问题；XML 格式的数据在使用之前必须转换为编程语言对象。另一个问题是如果必须更改属性值，那么要么先在 XML 中更改该值，然后在 RDBMS 中更改，要么先在 RDBMS 中更改该值，然后在缓存中更改该值。这些技术在维护 RDBMS 和缓存引擎之间的一致状态方面存在问题，特别是当属性与产品成本相关时，需要特别注意。

![Catalogue management](img/0123OS_06_08.jpg)

处理缓存引擎和关系数据库管理系统之间的状态管理

Redis 再次方便地存储目录数据。Redis 是无模式的，作为一个数据存储提供数据结构，例如可以用于存储产品所需的任意多个属性的映射。除此之外，它还提供了在不使用整个数据集的情况下更改、添加和读取属性的功能。拥有 Redis 的另一个好处是，我们不需要进行*对象到数据*的转换，反之亦然，因为这样就不需要在系统中拥有数百个数据对象；从而使代码库更小，开发速度更快。

# 在线分析

在线分析或实时分析是一项相对较新的需求，正日益流行。在线分析背后的整体理念是为用户提供更丰富、更具吸引力的用户体验。在线分析的工作方式是实时收集、分析和处理数据。

在网络革命的早期，analytics 只有一个主要的利益相关者，那就是网站管理团队。他们通常在离线模式下收集数据并进行分析，然后将其应用于业务用途。仍然需要这种离线分析技术。然而，在当今世界，当一切都与社交媒体相连时，用户的观点、他/她的社交群体和他/她的观点都必须反映在他/她的购物体验中。例如，假设一个用户和他的社交团体正在积极谈论一些音乐或书籍。当用户登录到他最喜欢的电子商务网站时，该网站的主页上的“推荐”部分会显示此产品。这使得用户很有可能最终购买该产品。这种个性化程度对于网站的成功非常重要。

这种情况下发生的分析是软实时的，也就是说，当用户与他的社交群体交互时，并行数据被处理，上下文被创建，网站使用上下文为用户创建个性化的购物体验。

另一种分析是基于用户在网站上浏览产品时创建的上下文。这种上下文创建本质上是协作的，尽管用户可能不知道这一事实。搜索产品或购买产品的用户数量越多，产品就越受欢迎。这类分析的复杂性在于它的实时性和性能至关重要。

在某种程度上，如果我们将离线分析引擎与实时分析进行比较，区别在于，业务逻辑领域之外的分析引擎成为业务逻辑的一部分，实际上共享相同的计算资源。另一个区别是，在实时分析中，数据量相对较小，但从用户的购物角度来看，其上下文数据从商业角度来看非常重要。下图以简洁的方式解释了离线和在线（实时）分析之间的区别：

![Online analytics](img/0123OS_06_09.jpg)

web 应用程序中的离线和在线分析

现在，如果同样的实时是使用 RDBMS 这样的数据存储来完成的，那么问题将出现在性能上，因为这种处理将消耗大量的计算资源，而并行执行的其他业务用例可能因此受到冲击。诸如 Oracle 之类的 RDBMS 可以提供扩展能力，但它们有一个代价，那就是它们非常昂贵。

Redis 是一个非常好的数据存储，可用于在线分析。由于 Redis 基于内存，因此速度非常快，而且在 Redis 中实现可伸缩性要容易得多。除此之外，Redis 还提供了数据结构，如集合和排序集合，这对于分离和聚合数据以进行实时分析非常有帮助。

Redis 的另一个优势是它的开源和运行时资源需求非常少。此外，Redis 的并发调用处理能力令人印象深刻。

在我们将开发的示例应用程序中，我们将看到一些以推荐引擎的形式出现的实时分析，该引擎将根据其流行程度推荐产品。

## 实施——简单电子商务

让我们从一些代码开始，以清楚地了解如何在会话、目录管理和在线分析中使用 Redis。但在我们这样做之前，让我们确定将创建哪些存储桶来存储数据：

*   **Bucket name“<username>@userdata”**：此 Bucket 将存储用户的个人资料数据，如姓名、电子邮件、电话号码、地址等。从应用程序的角度来看，这个 bucket 将是用户的`sessionID`，用户将把这个 bucket 绑定到`"<sessionID>@sessiondata"`。这里使用的数据结构是 Map。
*   **Bucket name“<sessionID>@sessiondata”**：此 Bucket 将存储用户的 lastlogin、loginstatus 等会话数据。除了会话数据外，它还将存储用户名，因为这是将`"<username>@userdata"`bucket 绑定到此 bucket 的密钥。这里使用的数据结构是 Map。
*   **Bucket name“<sessionID>@browsinghistory”**：此 Bucket 根据用户的会话 ID 存储用户的浏览历史，此处使用的数据结构为排序集。
*   **Bucket name“<name>@purchasehistory”**：给出用户的购买历史。这里使用的数据结构是排序集。
*   **Bucket name“<sessionID>@shoppingcart”**：此 Bucket 将存储用户的购物车项目。这里使用的数据结构是 Map。
*   **Bucket name“sessionIdTracker”**：跟踪系统中的用户总数。这里使用的数据结构是位图。
*   **Bucket name“<productname>**：存储产品属性。由于无模式，它可以存储产品的任意数量的属性。这里使用的数据结构是 Map。
*   **桶名“<标签>”**：存储映射到此标签的产品。例如，`"Learning Redis"`可以在诸如 Redis、NoSQL、database 等标签下进行标记。这里使用的数据结构是排序集。
*   **Bucket name“<productname>@visit”**：存储唯一访客数。在生产系统中，可以每天进行此操作，以统计每天访问此产品的人数，并帮助计算每月访问该网站的人数。这里使用的数据结构是位图。
*   **Bucket name“<productname>@purchase”**：此字段将存储购买该产品的唯一访客数。与前一个桶一样，此桶可以每日生成，以提供一周或一个月的合计计数。这里使用的数据结构是位图。

现在我们已经掌握了数据库的运行方式，让我们来看看 servlet，它将接受来自浏览器的服务请求，并将 HTTP 响应发送回客户端。

在这个简单的电子商务网站中有两个 servlet。他们将接受所有命令，如下所示：

*   **UserApp servlet**：这将满足与用户相关的所有命令
*   **ProductApp servlet**：这将满足与用户相关的所有命令

我们必须记住的一点是，执行顺序并不取决于 servlet 或 servlet 中的命令的列出顺序。例如，除非我们在系统中提供了一些产品，否则注册或登录没有意义，或者除非我们浏览或购买了一些产品，否则查看推荐没有意义，因为这将为推荐创建图形数据。

让我们了解一下将在本章其余部分的代码列表中使用的所有实用程序类。所有此类课程的列表如下：

*   **命令**：这是将在应用程序中实现的所有命令的父类和抽象类：

    ```java
    package org.learningRedis.web;
    import org.learningRedis.web.util.Argument;
    public abstract class Commands {
      private Argument argument;
      public Commands(Argument argument) {
        this.argument = argument;
      }
      public abstract String execute();
      public Argument getArgument() {
        return argument;
      }
    }
    ```

*   **默认命令**：这是默认命令，如果 URL 中传递的命令未被应用程序识别，则该命令将生效：

    ```java
    package org.learningRedis.web;
    import org.learningRedis.web.util.Argument;
    public class DefaultCommand extends Commands {
      public DefaultCommand(Argument argument) {
        super(argument);
      }
      @Override
      public String execute() {
        return "Command Not Recognized !!";
      }
    }
    ```

*   **参数**：该类的主要目标是包装请求中的所有名称-值属性，并将其放在一个映射中，以后可以在程序中使用：

    ```java
    package org.learningRedis.web.util;
    import java.util.HashMap;
    import java.util.Map;
    public class Argument {
      Map<String, String> argumentMap = new HashMap<String, String>();
      public Argument(String args) {
        String[] arguments = args.split(":");
        for (String argument : arguments) {
          String key = argument.split("=")[0];
          String value = argument.split("=")[1];
          argumentMap.put(key, value);
        }
      }
      public String getValue(String key) {
        return argumentMap.get(key);
      }
      public Map<String, String> getAttributes() {
        return argumentMap;
      }
    }
    ```

现在，我们已经介绍了应用程序中的实用程序类，让我们来看看这些类，它们将有助于为应用程序提供一个形状。

## ProductApp

ProductApp servlet将包含关于产品管理的命令。ProductApp servlet 的代码如下所示：

```java
package org.learningRedis.web;
import java.io.IOException;
import java.io.PrintWriter;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.learningRedis.web.analytics.commands.PurchasesCommand;
import org.learningRedis.web.analytics.commands.VisitTodayCommand;
import org.learningRedis.web.productmgmt.commands.CommissionProductCommand;
import org.learningRedis.web.productmgmt.commands.DisplayTagCommand;
import org.learningRedis.web.productmgmt.commands.DisplayCommand;
import org.learningRedis.web.productmgmt.commands.TagHistoryCommand;
import org.learningRedis.web.productmgmt.commands.UpdateTagCommand;
import org.learningRedis.web.util.Argument;
public class ProductApp extends HttpServlet {
  public ProductApp() {
    super();
  }
  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String command = request.getParameter("command");
    Argument argument = new Argument(request.getParameter("args"));
    PrintWriter out = response.getWriter();
    switch (command.toLowerCase()) {
    case "commission":
      Commands commission = new CommissionProductCommand(argument);
      out.println(commission.execute());
      break;
    case "display":
      Commands display = new DisplayCommand(argument);
      out.println(display.execute());
      break;
    case "displaytag":
      Commands displaytag = new DisplayTagCommand(argument);
      out.println(displaytag.execute());
      break;
    case "updatetag":
      Commands updatetag = new UpdateTagCommand(argument);
      out.println(updatetag.execute());
      break;
    case "visitstoday":
      Commands visittoday = new VisitTodayCommand(argument);
      out.println(visittoday.execute());
      break;
    case "purchasestoday":
      Commands purchasestoday = new PurchasesTodayCommand (argument);
      out.println(purchasestoday.execute());
      break;
    case "taghistory":
      Commands taghistory = new TagHistoryCommand(argument);
      out.println(taghistory.execute());
      break;
    default:
      Commands defaultUC = new DefaultCommand(argument);
      out.println(defaultUC.execute());
      break;
    }
  }
}
```

现在我们已经准备好了第一个 servlet，让我们来看看我们为此实现的命令：

*   `CommisionProductCommand`: This will implement the `commission` command. The implementation of the command is as follows:

    ```java
    package org.learningRedis.web.productmgmt.commands;
    import java.util.Map;
    import org.learningRedis.web.Commands;
    import org.learningRedis.web.util.Argument;
    import org.learningRedis.web.util.ProductDBManager;
    public class CommissionProductCommand extends Commands {
        public CommissionProductCommand(Argument argument) {
        super(argument);
      }
      @Override
      public String execute() {
        System.out.println(this.getClass().getSimpleName() + ":  " + " Entering the execute function");
        Map<String, String> productAttributes = this.getArgument().getAttributes();
        boolean commisioning_result = ProductDBManager.singleton.commisionProduct(productAttributes);
        boolean tagging_result = ProductDBManager.singleton.enterTagEntries(productAttributes.get("name"),
            productAttributes.get("tags"));
        if (commisioning_result & tagging_result) {
          return "commisioning successful";
        } else {
          return "commisioning not successful";
        }
      }
    }
    ```

    测试 URL:`http://localhost:8080/simple-ecom/productApp?command=commission&args=name=Redisbook-1:cost=10:catagory=book:author=vinoo:tags=Redis@5,NoSql@3,database@2,technology@1`。

    Description:由于所有原因，这是应该调用的第一个命令，因为该命令将向系统提供产品。URL 中需要关注的两个部分是`command`，它等于`commission`，以及参数部分，即`args`。此处`args`包含书籍的属性，例如`name=Redisbook-1`。属性`tags`表示将与书籍关联的单词。这本书的标签是`Redis@5`、`NoSQl@3`、`database@2`和`technology@1`。这些标签与权重相关联，只要推荐引擎启动，权重就会发挥作用。每当用户浏览`Redisbook-1`时，他将看到更多关于 Redis 图书的推荐。在这里，用户将看到 5 本关于 Redis 的书，3 本关于 NoSQL 的书，依此类推。为了简化本应用程序，权重总和应为 10。

    ![ProductApp](img/0123OS_06_10.jpg)

    产品调试成功的屏幕截图

    为了创建测试数据，委托几本不同重量的测试书，几本具有相同的标签，还有几本具有稍微不同的标签。确保权重总和等于 10。

*   `Display command`: This will implement the `display` command. The implementation of the command is as follows:

    ```java
    package org.learningRedis.web.productmgmt.commands;
    import org.learningRedis.web.Commands;
    import org.learningRedis.web.util.Argument;
    import org.learningRedis.web.util.ProductDBManager;
    public class DisplayCommand extends Commands {
      public DisplayCommand(Argument argument) {
        super(argument);
      }
      @Override
      public String execute() {
        String display = ProductDBManager.singleton.getProductInfo(this.getArgument().getValue("name"));
        return display;
      }
    }
    ```

    测试 URL:`http://localhost:8080/simple-ecom/productApp?command=display&args=name=Redisbook-1`。

    说明：此程序将显示书籍的属性。URL 中需要重点关注的两个部分是等于display 的命令和参数部分，即 args。这里，args 包含一个名为 name 的属性。

    ![ProductApp](img/0123OS_06_11.jpg)

    成功显示产品属性的屏幕截图

*   `DisplayTagCommand`: This will implement the `browse` command. The implementation of the command is as follows:

    ```java
    package org.learningRedis.web.productmgmt.commands;
    import org.learningRedis.web.Commands;
    import org.learningRedis.web.util.Argument;
    import org.learningRedis.web.util.ProductDBManager;
    public class DisplayTagCommand extends Commands {
      public DisplayTagCommand(Argument argument) {
        super(argument);
      }
      @Override
      public String execute() {
        System.out.println(this.getClass().getSimpleName() + ":  " + " Entering the execute function");
        String tagName = this.getArgument().getValue("tagname");
        String details = ProductDBManager.singleton.getTagValues(tagName);
        return details;
      }
    }
    ```

    测试 URL:`http://localhost:8080/simple-com/productApp?command=displaytag&args=tagname=nosql`。

    说明：此程序将根据一本书的点击数显示书籍。URL 中需要关注的两个部分是`command`，它等于`displaytag`，以及参数部分，即`args`。此处`args`包含一个名为`tagname`的属性。因为我已经在系统中委托了一本书，所以输出如下图所示。当用户开始浏览产品时，请稍后访问此标签；当您发出相同的命令时，顺序将更改。

    ![ProductApp](img/0123OS_06_12.jpg)

    成功显示属于 NoSQL 标签的产品的屏幕截图

*   `UpdateTag`: This will implement the `UpdateTagCommand` command. The implementation of the command is as follows:

    ```java
    package org.learningRedis.web.productmgmt.commands;
    import org.learningRedis.web.Commands;
    import org.learningRedis.web.util.AnalyticsDBManager;
    import org.learningRedis.web.util.Argument;
    import org.learningRedis.web.util.ProductDBManager;
    public class UpdateTagCommand extends Commands {
      public UpdateTagCommand(Argument argument) {
        super(argument);
      }
      @Override
      public String execute() {
        System.out.println(this.getClass().getSimpleName() + ":  " + " Entering the execute function");
        String sessionid = this.getArgument().getValue("sessionid");
        String productname = this.getArgument().getValue("productname");
        String details = this.getArgument().getValue("details");
        String actionType = this.getArgument().getValue("action");
        switch (actionType.toLowerCase()) {
        case "browse":
          if (productname != null & ProductDBManager.singleton.keyExist(productname)) {
            AnalyticsDBManager.singleton.updateRatingInTag(productname, 1);
            AnalyticsDBManager.singleton.updateProductVisit(sessionid, productname);
          }
          break;
        case "buy":
          System.out.println("Buying the products in the shopping cart !! ");
          String[] products = details.split(",");
          for (String product : products) {
            if (product != null & !product.trim().equals("")) {
              AnalyticsDBManager.singleton.updateRatingInTag(product, 10);
              AnalyticsDBManager.singleton.updateProductPurchase(sessionid, product);
            }
          }
          break;
        default:
          System.out.println("The URL cannot be acted uppon  ");
          break;
        }
        return "";
      }
    }
    ```

    测试 URL:`http://localhost:8080/simple-ecom/productApp?command=updatetag&args=sessionid=<sessionID of the user>:productname=<product name which the user is browsing or has bought>:action=<browse or buy>`。

    Description:当用户浏览产品或购买产品时，调用此命令。此命令背后的思想是，当用户浏览产品或购买产品时，它会越来越受欢迎，因此，在同一标签中的其他产品中，该产品的受欢迎程度应成比例增加。因此，简而言之，它有助于计算其类别中最受欢迎的产品（标签）。要测试此命令，请确保创建一些虚拟用户，并让他们登录到系统，然后点击`browse`命令 URL 或`buy`命令 URL。

*   `VisitTodayCommand`: This will implement the `browse` command. The implementation of the command is as follows:

    ```java
    package org.learningRedis.web.analytics.commands;
    import org.learningRedis.web.Commands;
    import org.learningRedis.web.util.AnalyticsDBManager;
    import org.learningRedis.web.util.Argument;
    public class VisitTodayCommand extends Commands {
      public VisitTodayCommand(Argument argument) {
        super(argument);
      }
      @Override
      public String execute() {
        System.out.println(this.getClass().getSimpleName() + ":  " + "Entering the execute function");
        String productName = this.getArgument().getValue("productname");
        Integer visitCount = AnalyticsDBManager.singleton.getVisitToday(productName);
        System.out.println(this.getClass().getSimpleName() + ":  " + "Printing the result for execute function");
        System.out.println("Result = " + "Total Unique Visitors are: " + visitCount.toString());
        return "Total Unique Visitors are: " + visitCount.toString();
      }
    }
    ```

    测试 URL:`http://localhost:8080/simple-ecom/productApp?command=visitstoday&args=productname=Redisbook-1`。

    Description:如果我们想查看有多少唯一用户访问过产品，可以执行此命令。实现此用例的数据结构是位图。Redis 中的位图具有一致的性能，而与它所保存的数据无关。

    ![ProductApp](img/0123OS_06_13.jpg)

    显示产品 redisbook-1 一天的总浏览人数的屏幕截图

*   `PurchasesTodayCommand`: This will implement the `purchasestoday` command. The implementation of the command is as follows:

    ```java
    package org.learningRedis.web.analytics.commands;
    import org.learningRedis.web.Commands;
    import org.learningRedis.web.util.Argument;
    import org.learningRedis.web.util.ProductDBManager;
    public class PurchasesTodayCommand extends Commands {
      public PurchasesTodayCommand(Argument argument) {
        super(argument);
      }
      @Override
      public String execute() {
        System.out.println(this.getClass().getSimpleName() + ":  " + "Entering the execute function");
        String productName = this.getArgument().getValue("productname");
        Integer purchaseCount = ProductDBManager.singleton.getPurchaseToday(productName);
        System.out.println(this.getClass().getSimpleName() + ":  " + "Printing the result for execute function");
        System.out.println("Result = " + "Total Unique Customers are: " + purchaseCount.toString());
        return "Total Unique Customers are: " + purchaseCount.toString();
      }
    }
    ```

    测试 URL:`http://localhost:8080/simple-ecom/productApp?command=purchasestoday&args=productname=Redisbook-1`。

    Description:如果我们想查看有多少唯一用户购买了给定的产品，可以执行此命令。实现此用例的数据结构是位图。Redis 中的位图具有一致的性能，而与它所保存的数据无关。

    ![ProductApp](img/0123OS_06_14.jpg)

    显示产品 redisbook-1 一天内总买家数量的屏幕截图

*   `TagHistoryCommand`: This will implement the `browse` command. The implementation of the command is as follows:

    ```java
    package org.learningRedis.web.productmgmt.commands;
    import org.learningRedis.web.Commands;
    import org.learningRedis.web.util.AnalyticsDBManager;
    import org.learningRedis.web.util.Argument;
    public class TagHistoryCommand extends Commands {
      public TagHistoryCommand(Argument argument) {
        super(argument);
      }
      @Override
      public String execute() {
        String tagname = this.getArgument().getValue("tagname");
        String tagHistory = AnalyticsDBManager.singleton.getTagHistory(tagname);
        return tagHistory;
        }
        }
    ```

    测试 URL:`http://localhost:8080/simple-ecom/productApp?command=taghistory&args=tagname=Redis`。

    Description:如果我们想查看产品的标签历史记录，可以执行此命令。产品排名基于属于标签的单个产品累积的分数。在以下示例中，我们展示了标签`Redis`的排名：

    ![ProductApp](img/0123OS_06_15.jpg)

    显示标签 redis 的标签历史记录的屏幕截图

    测试 URL:`http://localhost:8080/simple-ecom/productApp?command=taghistory&args=tagname=nosql`。

    Description:如果我们想查看产品的标签历史记录，可以执行此命令。产品排名基于属于标签的单个产品累积的分数。在以下示例中，我们展示了标签`nosql`的排名，以展示差异：

    ![ProductApp](img/0123OS_06_16.jpg)

    显示标记 nosql 的标记历史记录的屏幕截图

## 用户应用

UserApp servlet将包含关于用户管理和用户分析的命令。UserApp servlet 的代码如下所示：

```java
package org.learningRedis.web;
import java.io.IOException;
import java.io.PrintWriter;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.learningRedis.web.analytics.commands.MyStatusCommand;
import org.learningRedis.web.analytics.commands.RecomendByProduct;
import org.learningRedis.web.sessionmgmt.commands.Add2CartCommand;
import org.learningRedis.web.sessionmgmt.commands.BrowseCommand;
import org.learningRedis.web.sessionmgmt.commands.BuyCommand;
import org.learningRedis.web.sessionmgmt.commands.EditCartCommand;
import org.learningRedis.web.sessionmgmt.commands.EditMyDataCommand;
import org.learningRedis.web.sessionmgmt.commands.LoginCommand;
import org.learningRedis.web.sessionmgmt.commands.LogoutCommand;
import org.learningRedis.web.sessionmgmt.commands.MyDataCommand;
import org.learningRedis.web.sessionmgmt.commands.MyPurchaseHistory;
import org.learningRedis.web.sessionmgmt.commands.RegistrationCommand;
import org.learningRedis.web.sessionmgmt.commands.ReloginCommand;
import org.learningRedis.web.sessionmgmt.commands.ShowMyCartCommand;
import org.learningRedis.web.util.Argument;
public class UserApp extends HttpServlet {
  private static final long serialVersionUID = 1L;
  public UserApp() {
    super();
  }
  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String command = request.getParameter("command");
    Argument argument = new Argument(request.getParameter("args"));
    PrintWriter out = response.getWriter();
    switch (command.toLowerCase()) {
    case "register":
      Commands register = new RegistrationCommand(argument);
      out.println(register.execute());
      break;
    case "login":
      Commands login = new LoginCommand(argument);
      out.println(login.execute());
      break;
    case "mydata":
      Commands mydata = new MyDataCommand(argument);
      out.println(mydata.execute());
      break;
    case "editmydata":
      Commands editMyData = new EditMyDataCommand(argument);
      out.println(editMyData.execute());
      break;
    case "recommendbyproduct":
      Commands recommendbyproduct = new RecomendByProductCommand (argument);
      String recommendbyproducts = recommendbyproduct.execute();
      out.println(recommendbyproducts);
      break;
    case "browse":
      Commands browse = new BrowseCommand(argument);
      String result = browse.execute();
      out.println(result);
      String productname = argument.getValue("browse");
      String sessionid = argument.getValue("sessionid");
      request.getRequestDispatcher(
          "/productApp?command=updatetag&args=sessionid=" + sessionid + ":productname=" + productname
              + ":action=browse").include(request, response);
      break;
    case "buy":
      Commands buy = new BuyCommand(argument);
      String[] details = buy.execute().split("#");
      out.println(details[0]);
      String sessionID = argument.getValue("sessionid");
      request.getRequestDispatcher(
          "/productApp?command=updatetag&args=sessionid=" + sessionID + ":action=buy:details=" + details[1])
          .include(request, response);
      break;
    case "stats":
      Commands stats = new MyStatusCommand(argument);
      out.println(stats.execute());
      break;
    case "add2cart":
      Commands add2cart = new Add2CartCommand(argument);
      out.println(add2cart.execute());
      break;
    case "showmycart":
      Commands showmycart = new ShowMyCartCommand(argument);
      out.println(showmycart.execute());
      break;
    case "editcart":
      Commands editCard = new EditCartCommand(argument);
      out.println(editCard.execute());
      break;
    case "relogin":
      Commands relogin = new ReloginCommand(argument);
      out.println(relogin.execute());
      break;
    case "logout":
      Commands logout = new LogoutCommand(argument);
      out.println(logout.execute());
      break;
    case "mypurchasehistory":
      Commands mypurchasehistory = new MyPurchaseHistoryCommand (argument);
      out.println(mypurchasehistory.execute());
      break;
    default:
      Commands defaultUC = new DefaultCommand(argument);
      out.println(defaultUC.execute());
      break;
    }
  }
}
```

现在我们有了第一个 servlet，让我们来看看我们为此实现的命令：

*   `RegistrationCommand`: This will implement the `register` command. The code for the command is as follows:

    ```java
    package org.learningRedis.web.sessionmgmt.commands;
    import org.learningRedis.web.Commands;
    import org.learningRedis.web.util.Argument;
    import org.learningRedis.web.util.UserDBManager;
    public class RegistrationCommand extends Commands {
      public RegistrationCommand(Argument argument) {
        super(argument);
      }
      public String execute() {
        System.out.println(this.getClass().getSimpleName() + ":  " + " Entering the execute function");
        String name = this.getArgument().getValue("name");
        if (!UserDBManager.singleton.doesUserExist(name)) {
          UserDBManager.singleton.createUser(this.getArgument().getAttributes());
        } else {
          return "user already registered in ";
        }
        return "successful registeration  -> " + name;
      }
    }
    ```

    测试 URL:`http://localhost:8080/simple-ecom/userApp?command=register&args=name=vinoo:password=******:address=test address`。

    说明：此命令将用户注册到系统中。URL 中需要关注的两个部分是`command`，它等于`register`，以及参数部分，即`args`。这表示键值对中的属性。下图表示注册成功时的成功场景。下一个逻辑步骤是登录用户。

    ![UserApp](img/0123OS_06_17.jpg)

    显示用户注册的屏幕截图

*   `LoginCommand`: This will implement the `login` command. The code for the command is as follows:

    ```java
    package org.learningRedis.web.sessionmgmt.commands;
    import java.util.HashMap;
    import java.util.Map;
    import org.learningRedis.web.Commands;
    import org.learningRedis.web.util.AnalyticsDBManager;
    import org.learningRedis.web.util.Argument;
    import org.learningRedis.web.util.ProductDBManager;
    import org.learningRedis.web.util.UserDBManager;
    public class LoginCommand extends Commands {
      public LoginCommand(Argument argument) {
        super(argument);
      }
      @Override
      public String execute() {
        System.out.println(this.getClass().getSimpleName() + ":  " + " Entering the execute function");
        String name = this.getArgument().getValue("name");
        String password = this.getArgument().getValue("password");
        if (UserDBManager.singleton.doesUserExist(name)) {
          if (UserDBManager.singleton.getUserPassword(name).equals(password)
              & UserDBManager.singleton.getUserSessionId(name).equals("null")) {
            String sessionID = ProductDBManager.getRandomSessionID();
            UserDBManager.singleton.login(sessionID, name);
            Map<String, String> map = new HashMap<String, String>();
            map.put("sessionID", sessionID);
            UserDBManager.singleton.setRegistrationMap(name, map);
            System.out.println("login map : " + map);
            AnalyticsDBManager.singleton.registerInSessionTracker(sessionID);
            return "Login successful \n" + name + " \n use the following session id : " + sessionID;
          } else if (UserDBManager.singleton.getUserPassword(name).equals(password)
              & !UserDBManager.singleton.getUserSessionId(name).equals("null")) {
            return " Login failed ...u r already logged in \n please logout to login again \n or try relogin command ";
          } else {
            return " Login failed ...invalid password ";
          }
        } else {
          return " please register before executing command for login ";
        }
      }
    }
    ```

    测试 URL:`http://localhost:8080/simple-ecom/userApp?command=login&args=name=vinoo:password=******`。

    说明：此命令将用户登录系统。URL 中需要关注的两个部分是`command`，它等于`login`，以及参数部分，即`args`。参数将包含名称和密码。需要重点关注的重要部分是，在执行时，该命令将返回会话 ID 代码。用户将执行的大多数命令都需要此会话 ID。因此，如果您正在运行此示例，请确保将此数字存储在文本板中以供以后使用。在生产系统中，这可以存储在浏览器或客户端的内存中。下图告诉我为我生成的会话 ID 是**26913441**。我将在我执行的其余示例中使用此选项：

    ![UserApp](img/0123OS_06_18.jpg)

    显示用户登录和用户会话 ID 的屏幕截图

*   `MyDataCommand`: This will implement the `mydata` command. The code for the command is as follows:

    ```java
    package org.learningRedis.web.sessionmgmt.commands;
    import java.util.Map;
    import org.learningRedis.web.Commands;
    import org.learningRedis.web.util.Argument;
    import org.learningRedis.web.util.UserDBManager;
    public class MyDataCommand extends Commands {
      public MyDataCommand(Argument argument) {
        super(argument);
      }
      @Override
      public String execute() {
        System.out.println(this.getClass().getSimpleName() + ":  " + " Entering the execute function");
        String sessionid = this.getArgument().getValue("sessionid");
        String name = UserDBManager.singleton.getUserName(sessionid);
        Map<String, String> map = UserDBManager.singleton.getRegistrationMap(name);
        return map.toString();
      }
    }
    ```

    测试 URL:`http://localhost:8080/simple-ecom/userApp?command=mydata&args=sessionid=26913441`。

    说明：此命令将显示来自系统的用户数据。URL 中需要关注的两个部分是`command`，它等于`mydata`，以及参数部分，即`args`。参数中只有会话 ID 作为 URL 中的键值对。下图显示了命令的结果。由于图中无法容纳某些属性，因此未显示这些属性。

    ![UserApp](img/0123OS_06_19.jpg)

    显示用户数据的屏幕截图

*   `EditMyDataCommand`: This will implement the `editmydata` command. The code for the command is as follows:

    ```java
    package org.learningRedis.web.sessionmgmt.commands;
    import java.util.Map;
    import org.learningRedis.web.Commands;
    import org.learningRedis.web.util.Argument;
    import org.learningRedis.web.util.UserDBManager;
    public class EditMyDataCommand extends Commands {
      public EditMyDataCommand(Argument argument) {
        super(argument);
      }
      @Override
      public String execute() {
        System.out.println(this.getClass().getSimpleName() + ":  " + " Entering the execute function");
        Map<String, String> editMap = this.getArgument().getAttributes();
        boolean result = UserDBManager.singleton.editRegistrationMap(editMap);
        if (result) {
          return "Edit is Done....";
        } else {
          return "Edit not Done.... please check sessionid and name combination";
        }
      }
    }
    ```

    测试 URL:`http://localhost:8080/simple-ecom/userApp?command=editmydata&args=name=vinoo:password=******:address=changed address:phone=9111111119:sessionid=26913441`。

    说明：此命令将显示来自系统的用户数据。URL 中需要关注的两个部分是`command`，它等于`mydata`，以及参数部分，即`args`。参数具有新的和已编辑的键值对。确保 URL 中的会话 ID 正确。下图是您应该在输出中看到的内容。现在您可以随时返回并执行上一个命令`mydata`，该命令将显示较新的值。

    ![UserApp](img/0123OS_06_20.jpg)

    成功编辑用户数据的屏幕截图

*   `BrowseCommand`: This will implement the `browse` command. The implementation of the command is as follows:

    ```java
    package org.learningRedis.web.sessionmgmt.commands;
    import org.learningRedis.web.Commands;
    import org.learningRedis.web.util.AnalyticsDBManager;
    import org.learningRedis.web.util.Argument;
    import org.learningRedis.web.util.ProductDBManager;
    public class BrowseCommand extends Commands {
      public BrowseCommand(Argument argument) {
        super(argument);
      }
      @Override
      public String execute() {
        System.out.println(this.getClass().getSimpleName() + ":  " + " Entering the execute function");
        String productname = this.getArgument().getValue("browse");
        if (ProductDBManager.singleton.keyExist(productname)) {
          AnalyticsDBManager.singleton.updateBrowsingHistory(this.getArgument().getValue("sessionid"), productname);
          StringBuffer stringBuffer = new StringBuffer();
          stringBuffer.append("You are browsing the following product = " + productname + "\n");
          stringBuffer.append(ProductDBManager.singleton.getProductInfo(productname));
          return stringBuffer.toString();
        } else {
          return "Error: The product you are trying to browse does not exist i.e. " + productname;
        }
      }
    }
    ```

    测试 URL:`http://localhost:8080/simple-ecom/userApp?command=browse&args=sessionid=26913441:browse=Redisbook-1`。

    说明：此命令将显示来自系统的产品数据。URL 中需要关注的两个部分是`command`，它等于`browse`，以及参数部分，即`args`。参数具有用户的会话 ID 和用户正在浏览的产品的名称。这里发生了几件事。用户可以看到产品的详细信息，并在后台向`updatetag`命令发送请求，以提高相应产品的受欢迎程度。在我们的案例中，产品为`Redisbook-1`。为了进行测试，请多次浏览您已调试到系统中的所有产品。

    ![UserApp](img/0123OS_06_21.jpg)

    当用户想要浏览产品并查看其详细信息时的屏幕截图

*   `RecommendByProductCommand`: This will implement the `recommendbyproduct` command. The code for the command is as follows:

    ```java
    package org.learningRedis.web.analytics.commands;
    import java.util.List;
    import java.util.Map;
    import java.util.Set;
    import org.learningRedis.web.Commands;
    import org.learningRedis.web.util.AnalyticsDBManager;
    import org.learningRedis.web.util.Argument;
    import org.learningRedis.web.util.ProductDBManager;
    public class RecomendByProductCommand extends Commands {
      int totalrecomendations = 10;
      public RecomendByProductCommand(Argument argument) {
        super(argument);
      }
      @Override
      public String execute() {
        System.out.println(this.getClass().getSimpleName() + ":  " + " Entering the execute function");
        StringBuffer buffer = new StringBuffer();
        String productname = this.getArgument().getValue("productname");
        buffer.append("If you are lookinging into " + productname + " you might also find the following \n");
        buffer.append("products interseting... \n");
        Map<String, Integer> tags = ProductDBManager.singleton.getProductTags(productname);
        // Lets get total sum of weights
        int totalweight = 0;
        Set<String> keys = tags.keySet();
        for (String key : keys) {
          totalweight = totalweight + tags.get(key);
        }
        for (String key : keys) {
          int slotfortag = Math.round(totalrecomendations * tags.get(key) / totalweight);
          List<String> productnames = AnalyticsDBManager.singleton.getTopProducts(slotfortag, key);
          for (String product : productnames) {
            if (!product.equals(productname)) {
              buffer.append("For tag = " + key + " the recomended product is " + product);
              buffer.append("\n");
            }
          }
        }
        System.out.println(this.getClass().getSimpleName() + ":  " + "Printing the result for execute function");
        System.out.println("Result = " + buffer.toString());
        return buffer.toString();
      }
    }
    ```

    测试 URL:`http://localhost:8080/simple-ecom/userApp?command=recommendbyproduct&args=sessionid=26913441:productname=Redisbook-1`。

    Description:此命令将根据正在浏览的产品推荐产品。URL 中需要关注的两个部分是`command`，它等于`recommendbyproduct`，以及参数部分，即`args`。参数具有用户和产品的会话 ID`Redisbook-1`。

    此命令将根据产品的购买和浏览历史，向用户推荐顶级产品。这将考虑到产品所属的类别以及产品展示需要考虑的重量。在某种程度上，这就是在线实时分析，当用户浏览一个产品时，它会起作用。在图中，`Redis`标签的结果最多，因为该标签的重量最大。在生产中，需要对共享相同标签的类似产品可能出现的重复结果进行一些过滤。这种过滤可以在客户端完成，从而节省服务器端的计算资源。

    ![UserApp](img/0123OS_06_22.jpg)

    用户希望浏览产品并查看其他推荐产品时的屏幕截图

*   `Add2CartCommand`: This will implement the `add2cart` command. The implementation of the command is as follows:

    ```java
    package org.learningRedis.web.sessionmgmt.commands;
    import java.util.HashMap;
    import java.util.Map;
    import org.learningRedis.web.Commands;
    import org.learningRedis.web.util.Argument;
    import org.learningRedis.web.util.ShoppingCartDBManager;
    import org.learningRedis.web.util.UserDBManager;
    public class Add2CartCommand extends Commands {
      public Add2CartCommand(Argument argument) {
        super(argument);
      }
      @Override
      public String execute() {
        System.out.println(this.getClass().getSimpleName() + ":  " + " Entering the execute function");
        String result = "did not update the shopping cart";
        String sessionid = this.getArgument().getValue("sessionid");
        String product = this.getArgument().getValue("product");
        String[] productList = product.split(",");
        Map<String, String> productQtyMap = new HashMap<String, String>();
        for (String _product : productList) {
          String[] nameQty = _product.split("@");
          productQtyMap.put(nameQty[0], nameQty[1]);
        }
        if (UserDBManager.singleton.doesSessionExist(sessionid)) {
          result = ShoppingCartDBManager.singleton.addToShoppingCart(sessionid, productQtyMap);
        }
        return "Result : " + result;
      }
    }
    ```

    测试 URL:`http://localhost:8080/simple-ecom/userApp?command=add2cart&args=sessionid=26913441:product=Redisbook-1@2,Redisbook-4@1`。

    说明：此命令将把产品及其数量放入购物车。URL 中需要关注的两个部分是`command`，它等于`add2cart`，以及参数部分，即`args`。参数包含两个键值对。第一个是会话 ID，第二个是产品名称和数量，用特殊字符`@`分隔。下图显示我已成功将产品添加到我的购物车中：

    ![UserApp](img/0123OS_06_23.jpg)

    用户希望将产品添加到购物车时的屏幕截图

*   `ShowMyCartCommand`: This will implement the `showmycart` command. The implementation of the command is as follows:

    ```java
    package org.learningRedis.web.sessionmgmt.commands;
    import java.util.Map;
    import java.util.Set;
    import org.learningRedis.web.Commands;
    import org.learningRedis.web.util.Argument;
    import org.learningRedis.web.util.ShoppingCartDBManager;
    public class ShowMyCartCommand extends Commands {
      public ShowMyCartCommand(Argument argument) {
        super(argument);
      }
      @Override
      public String execute() {
        System.out.println(this.getClass().getSimpleName() + ":  " + " Entering the execute function");
        String sessionid = this.getArgument().getValue("sessionid");
        Map<String, String> productMap = ShoppingCartDBManager.singleton.myCartInfo(sessionid);
        StringBuffer stringBuffer = new StringBuffer();
        if (!productMap.isEmpty()) {
          stringBuffer.append("Your shopping cart contains the following : ");
          stringBuffer.append("\n");
          Set<String> set = productMap.keySet();
          int i = 1;
          for (String str : set) {
            stringBuffer.append("[" + i + "] product name = " + str + " Qty = " + productMap.get(str) + "\n");
            i++;
          }
          return stringBuffer.toString();
        } else {
          return " your shopping cart is empty.";
        }
      }
    }
    ```

    测试 URL:`http://localhost:8080/simple-ecom/userApp?command=showmycart&args=sessionid=26913441`。

    说明：此命令将商品及其数量放入购物车。URL 中需要关注的两个部分是`command`，它等于`showmycart`，以及参数部分，即`args`。参数仅包含会话 ID。以下图为我的购物车：

    ![UserApp](img/0123OS_06_24.jpg)

    用户想要查看其购物车时的屏幕截图

*   `EditCartCommand`: This will implement the `editcart` command. The implementation of the command is as follows:

    ```java
    package org.learningRedis.web.sessionmgmt.commands;
    import java.util.HashMap;
    import java.util.Map;
    import org.learningRedis.web.Commands;
    import org.learningRedis.web.util.Argument;
    import org.learningRedis.web.util.ShoppingCartDBManager;
    import org.learningRedis.web.util.UserDBManager;
    public class EditCartCommand extends Commands {
      public EditCartCommand(Argument argument) {
        super(argument);
      }
      @Override
      public String execute() {
        System.out.println(this.getClass().getSimpleName() + ":  " + " Entering the execute function");
        String result = "did not edit the shopping cart";
        String sessionID = this.getArgument().getValue("sessionid");
        String product = this.getArgument().getValue("product");
        String[] productList = product.split(",");
        Map<String, String> productQtyMap = new HashMap<String, String>();
        for (String _product : productList) {
          String[] nameQty = _product.split("@");
          productQtyMap.put(nameQty[0], nameQty[1]);
        }
        if (UserDBManager.singleton.doesSessionExist(sessionID)) {
          result = ShoppingCartDBManager.singleton.editMyCart(sessionID, productQtyMap);
        }
        return "result : " + result;
      }
    }
    ```

    测试 URL:`http://localhost:8080/simple-ecom/userApp?command=editcart&args=sessionid=26913441:product=Redisbook-4@0,Redisbook-2@1`。

    说明：此命令将编辑购物车中的产品及其数量。URL 中需要重点关注的两个部分是`command`，它等于`editcart`，以及参数部分，即`args`。参数包含乘积的键值对及其新数量。如果数量标记为`0`，则产品将从购物车中移除。再次执行`showmycart`命令时，购物车应反映较新的值。下图显示了较新的值：

    ![UserApp](img/0123OS_06_25.jpg)

    用户编辑购物车后想要查看其购物车的屏幕截图

*   `BuyCommand`: This will implement the `browse` command. The implementation of the command is as follows:

    ```java
    package org.learningRedis.web.sessionmgmt.commands;
    import org.learningRedis.web.Commands;
    import org.learningRedis.web.util.Argument;
    import org.learningRedis.web.util.ShoppingCartDBManager;
    public class BuyCommand extends Commands {
      public BuyCommand(Argument argument) {
        super(argument);
      }
      @Override
      public String execute() {
        System.out.println(this.getClass().getSimpleName() + ":  " + " Entering the execute function");
        String sessionid = this.getArgument().getValue("sessionid");
        String shoppingdetails = ShoppingCartDBManager.singleton.buyItemsInTheShoppingCart(sessionid);
        return shoppingdetails;
      }
    }
    ```

    测试 URL:`http://localhost:8080/simple-ecom/userApp?command=buy&args=sessionid=26913441`。

    说明：此命令将在购物车中购买产品。由于这是一个演示网站，因此没有连接到支付网关，但使用此命令的目的是在购买时增加`hit`计数器。购买产品时，推荐引擎在浏览产品时比`1`增加`10`点数：

    ![UserApp](img/0123OS_06_26.jpg)

    虚拟采购

    此时，返回并重新访问`recommendbyproduct`命令将非常有趣。产品展示的顺序会发生变化，因为每次购买都会给产品的受欢迎程度打上`10`分。`recommendbyproduct`用于产品`Redisbook-1`。测试 URL 如下：`http://localhost:8080/simple-ecom/userApp?command=recommendbyproduct&args=sessionid=26913441:productname=Redisbook-1`。

    ![UserApp](img/0123OS_06_27.jpg)

    成功购买后重新排列的产品列表截图（在线分析）

*   `MyStatusCommand`: This will implement the `stats` command. The implementation of the command is as follows:

    ```java
    package org.learningRedis.web.analytics.commands;
    import java.util.Iterator;
    import java.util.Set;
    import org.learningRedis.web.Commands;
    import org.learningRedis.web.util.AnalyticsDBManager;
    import org.learningRedis.web.util.Argument;
    import org.learningRedis.web.util.UserDBManager;
    public class MyStatusCommand extends Commands {
      public MyStatusCommand(Argument argument) {
        super(argument);
      }
      @Override
      public String execute() {
        System.out.println(this.getClass().getSimpleName() + ":  " + "Entering the execute function");
        String sessionID = this.getArgument().getValue("sessionid");
        if (UserDBManager.singleton.doesSessionExist(sessionID)) {
          Set<String> browsingHistory = AnalyticsDBManager.singleton.getBrowsingHistory(sessionID);
          StringBuffer buffer = new StringBuffer();
          buffer.append(" View your browsing history where the one on top is the least visited product");
          buffer.append("\n and the product at the bottom is the most frequented product ");
          buffer.append("\n");
          Iterator<String> iterator = browsingHistory.iterator();
          int i = 1;
          while (iterator.hasNext()) {
            buffer.append("[" + i + "] " + iterator.next() + "\n");
            i++;
          }
          System.out.println(this.getClass().getSimpleName() + ":  " + "Printing the result for execute function");
          System.out.println("Result = " + buffer.toString());
          return buffer.toString();
        } else {
          return "history is not available";
        }
      }
    }
    ```

    测试 URL:`http://localhost:8080/simple-ecom/userApp?command=stats&args=sessionid=26913441`。

    说明：此命令将给出用户的浏览历史记录。在这里，结果将根据用户重新访问特定产品的频率列出。URL 中需要关注的两个部分是`command`，它等于`stats`，以及参数部分，即`args`。参数包含用户的会话 ID。下图为会话 ID 为**26913441**的用户浏览历史：

    ![UserApp](img/0123OS_06_28.jpg)

    查看用户浏览历史记录的屏幕截图

*   `MyPurchaseHistoryCommand`: This will implement the `mypurchasehistory` command. The implementation of the command is as follows:

    ```java
    package org.learningRedis.web.sessionmgmt.commands;
    import java.util.List;
    import org.learningRedis.web.Commands;
    import org.learningRedis.web.util.AnalyticsDBManager;
    import org.learningRedis.web.util.Argument;
    public class MyPurchaseHistoryCommand extends Commands {
      public MyPurchaseHistoryCommand(Argument argument) {
        super(argument);
      }
      @Override
      public String execute() {
        System.out.println(this.getClass().getSimpleName() + ":  " + " Entering the execute function");
        StringBuffer report = new StringBuffer();
        String sessionid = this.getArgument().getValue("sessionid");
        List<String> purchasehistory = AnalyticsDBManager.singleton.getMyPurchaseHistory(sessionid);
        report.append("Your purchase history is as follows : \n");
        int i = 0;
        for (String purchase : purchasehistory) {
          report.append("[" + i + "] You purchased " + purchase);
          report.append("\n");
          i++;
        }
        return report.toString();
      }
    }
    ```

    测试 URL:`http://localhost:8080/simple-ecom/userApp?command=mypurchasehistory&args=sessionid=26913441`。

    Description:此命令将给出用户的购买历史记录。在这里，结果将根据用户购买特定产品的日期列出。URL 中需要关注的两个部分是`command`，它等于`stats`，以及参数部分，即`args`。参数是用户的会话 ID：

    ![UserApp](img/0123OS_06_29.jpg)

    查看用户购买历史记录的屏幕截图

*   `ReloginCommand`: This will implement the `relogin` command. The implementation of the command is as follows:

    ```java
    package org.learningRedis.web.sessionmgmt.commands;
    import org.learningRedis.web.Commands;
    import org.learningRedis.web.util.Argument;
    import org.learningRedis.web.util.UserDBManager;
    public class ReloginCommand extends Commands {
      public ReloginCommand(Argument argument) {
        super(argument);
      }
      @Override
      public String execute() {
        System.out.println(this.getClass().getSimpleName() + ":  " + " Entering the execute function");
        String name = this.getArgument().getValue("name");
        String password = this.getArgument().getValue("password");
        if (UserDBManager.singleton.doesUserExist(name)) {
          if (UserDBManager.singleton.getUserPassword(name).equals(password)) {
            String sessionID = UserDBManager.singleton.getUserSessionId(name);
            return "ReLogin successful \n" + name + " \n use the following session id : " + sessionID;
          } else {
            return " ReLogin failed ...invalid password ";
          }
        } else {
          return " please register before executing command for login ";
        }
      }
    }
    ```

    测试 URL:`http://localhost:8080/simple-ecom/userApp?command=relogin&args=name=vinoo:password=******`。

    说明：此命令将再次检查该用户的用户和密码，并返回该用户关联的会话 ID。这个想法是建立一个会话，该会话可以存在于用户的许多购物和浏览会话中。

*   `LogoutCommand`: This will implement the `logout` command. The implementation of the command is as follows:

    ```java
    package org.learningRedis.web.sessionmgmt.commands;
    import org.learningRedis.web.Commands;
    import org.learningRedis.web.util.Argument;
    import org.learningRedis.web.util.UserDBManager;
    public class LogoutCommand extends Commands {
      public LogoutCommand(Argument argument) {
        super(argument);
      }
      @Override
      public String execute() {
        System.out.println(this.getClass().getSimpleName() + ":  " + " Entering the execute function");
        String sessionid = this.getArgument().getValue("sessionid");
        if (UserDBManager.singleton.expireSession(sessionid)) {
          return "logout was clean";
        } else {
          return "logout was not clean";
        }
      }
    }
    ```

    测试 URL:`http://localhost:8080/simple-ecom/userApp?command=logout&args=sessionid=26913441`。

    Description:此命令将用户从系统中注销，并根据会话 ID 删除用户的所有数据存储，如购买历史记录、购物车和浏览历史记录。

现在我们已经掌握了命令的用法，让我们来看看包，它将负责连接管理和 Redis 的其他功能调用。

## 再开发管理器

此类是该应用程序的主干；负责与数据库的连接，管理连接池。它还具有一些实用功能。下面的代码片段解释了该实现：

```java
package org.learningRedis.web.util;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import Redis.clients.jedis.Jedis;
import Redis.clients.jedis.JedisPool;
public class RedisDBManager {
  private static Date date = new Date();
  private static int minimum = 1;
  private static int maximum = 100000000;
  // going with the default pool.
  private static JedisPool connectionPool = new JedisPool("localhost", 6379);
  public Jedis getConnection() {
    return connectionPool.getResource();
  }
  public void returnConnection(Jedis jedis) {
    connectionPool.returnResource(jedis);
  }
  public static String getDate() {
    DateFormat dateFormat = new SimpleDateFormat("dd-MM-yyyy");
    String dateValue = dateFormat.format(date);
    return dateValue;
  }
  public static String getRandomSessionID() {
    int randomNum = minimum + (int) (Math.random() * maximum);
    return new Integer(randomNum).toString();
  }
}
```

## 产品经理

此类扩展了`RedisDBManager`类，负责对数据库进行与产品相关的功能调用。该类的实现如下所示：

```java
package org.learningRedis.web.util;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import Redis.clients.jedis.Jedis;
public class ProductDBManager extends RedisDBManager {
  private ProductDBManager() {
  }
  public static ProductDBManager singleton = new ProductDBManager();
  public boolean commisionProduct(Map<String, String> productAttributes) {
    Jedis jedis = this.getConnection();
    String productCreationResult = jedis.hmset(productAttributes.get("name"), productAttributes);
    if (productCreationResult.toLowerCase().equals("ok")) {
      this.returnConnection(jedis);
      return true;
    } else {
      this.returnConnection(jedis);
      return false;
    }
  }
  public boolean enterTagEntries(String name, String string) {
    Jedis jedis = this.getConnection();
    String[] tags = string.split(",");
    boolean boolResult = false;
    List<String> tagList = new ArrayList<String>();
    for (String tag : tags) {
      String[] tagAndRating = tag.split("@");
      tagList.add(tagAndRating[0]);
    }
    for (String tag : tagList) {
      long result = jedis.zadd(tag.toLowerCase(), 0, name);
      if (result == 0) {
        break;
      } else {
        boolResult = true;
      }
    }
    this.returnConnection(jedis);
    return boolResult;
  }
  public String getProductInfo(String name) {
    Jedis jedis = this.getConnection();
    Map<String, String> map = jedis.hgetAll(name);
    StringBuffer stringBuffer = new StringBuffer();
    stringBuffer.append("Following are the product attributes for  " + name);
    stringBuffer.append("\n");
    Set<String> keys = map.keySet();
    int i = 1;
    for (String key : keys) {
      stringBuffer.append("[" + i + "] . " + key + " value : " + map.get(key));
      stringBuffer.append("\n");
      i++;
    }
    this.returnConnection(jedis);
    return stringBuffer.toString();
  }
  public String getTagValues(String tagName) {
    Jedis jedis = this.getConnection();
    StringBuffer stringBuffer = new StringBuffer();
    Set<String> sortedTagList = jedis.zrange(tagName.toLowerCase(), 0, 10000);
    stringBuffer.append("The following products are listed as per the hit rate \n");
    int i = 1;
    for (String tagname : sortedTagList) {
      stringBuffer.append(" [" + i + "] " + tagname + "\n");
      i++;
    }
    this.returnConnection(jedis);
    return stringBuffer.toString();
  }
  public boolean keyExist(String keyName) {
    Jedis jedis = this.getConnection();
    boolean result = jedis.exists(keyName);
    this.returnConnection(jedis);
    return result;
  }
  public int getPurchaseToday(String productName) {
    Jedis jedis = this.getConnection();
    if (jedis.get(productName + "@purchase:" + getDate()) != null) {
      BitSet users = BitSet.valueOf(jedis.get(productName + "@purchase:" + getDate()).getBytes());
      this.returnConnection(jedis);
      return users.cardinality();
    } else {
      this.returnConnection(jedis);
      return 0;
    }
  }
  public Map<String, Integer> getProductTags(String productname) {
    Jedis jedis = this.getConnection();
    String producttags = jedis.hget(productname, "tags");
    Map<String, Integer> map = new HashMap<String, Integer>();
    String[] tagAndweights = producttags.split(",");
    for (String tagAndWeight : tagAndweights) {
      map.put(tagAndWeight.split("@")[0], new Integer(tagAndWeight.split("@")[1]));
    }
    this.returnConnection(jedis);
    return map;
  }
}
```

## 分析数据管理器

此类扩展了的`RedisDBManager`，并负责对数据库进行分析相关的函数调用。该类的实现如下所示：

```java
package org.learningRedis.web.util;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import Redis.clients.jedis.Jedis;
public class AnalyticsDBManager extends RedisDBManager {
  private AnalyticsDBManager() {
  }
  public static AnalyticsDBManager singleton = new AnalyticsDBManager();
  public void registerInSessionTracker(String sessionID) {
    Jedis jedis = this.getConnection();
    Long sessionvalue = new Long(sessionID);
    jedis.setbit("sessionIdTracker", sessionvalue, true);
    this.returnConnection(jedis);
  }
  public void updateBrowsingHistory(String sessionID, String productname) {
    Jedis jedis = this.getConnection();
    jedis.zincrby(sessionID + "@browsinghistory", 1.0, productname);
    this.returnConnection(jedis);
  }
  public Set<String> getBrowsingHistory(String sessionID) {
    Jedis jedis = this.getConnection();
    Set<String> range = jedis.zrange(sessionID + "@browsinghistory", 0, 1000000);
    this.returnConnection(jedis);
    return range;
  }
  public int getVisitToday(String productName) {
    Jedis jedis = this.getConnection();
    if (jedis.get(productName + "@visit:" + getDate()) != null) {
      BitSet users = BitSet.valueOf(jedis.get(productName + "@visit:" + getDate()).getBytes());
      this.returnConnection(jedis);
      return users.cardinality();
    } else {
      this.returnConnection(jedis);
      return 0;
    }
  }
  public void updateProductVisit(String sessionid, String productName) {
    Jedis jedis = this.getConnection();
    jedis.setbit(productName + "@visit:" + getDate(), new Long(sessionid), true);
    this.returnConnection(jedis);
  }
  public void updateProductPurchase(String sessionid, String productName) {
    Jedis jedis = this.getConnection();
    jedis.setbit(productName + "@purchase:" + getDate(), new Long(sessionid), true);
    this.returnConnection(jedis);
  }
  public void updateRatingInTag(String productname, double rating) {
    Jedis jedis = this.getConnection();
    String string = jedis.hget(productname, "tags");
    String[] tags = string.split(",");
    List<String> tagList = new ArrayList<String>();
    for (String tag : tags) {
      String[] tagAndRating = tag.split("@");
      tagList.add(tagAndRating[0]);
    }
    for (String tag : tagList) {
      jedis.zincrby(tag.toLowerCase(), rating, productname);
    }
    this.returnConnection(jedis);
  }
  public List<String> getMyPurchaseHistory(String sessionid) {
    Jedis jedis = this.getConnection();
    String name = jedis.hget(sessionid + "@sessiondata", "name");
    List<String> purchaseHistory = jedis.lrange(name + "@purchasehistory", 0, 100);
    this.returnConnection(jedis);
    return purchaseHistory;
  }
  public String getTagHistory(String tagname) {
    Jedis jedis = this.getConnection();
    Set<String> sortedProductList = jedis.zrange(tagname.toLowerCase(), 0, 10000);
    StringBuffer stringBuffer = new StringBuffer();
    stringBuffer.append("The following products are listed as per the hit rate \n");
    int i = 1;
    for (String productname : sortedProductList) {
      stringBuffer.append(" [" + i + "] " + productname + " and the score is "
          + jedis.zscore(tagname.toLowerCase(), productname) + "\n");
      i++;
    }
    this.returnConnection(jedis);
    return stringBuffer.toString();
  }
  public List<String> getTopProducts(int slotfortag, String tag) {
    Jedis jedis = this.getConnection();
    Set<String> sortedProductList = jedis.zrevrange(tag.toLowerCase(), 0, 100000000);
    List<String> topproducts = new ArrayList<String>();
    Iterator<String> iterator = sortedProductList.iterator();
    int index = 0;
    while (iterator.hasNext()) {
      if (index <= slotfortag) {
        topproducts.add(iterator.next());
        index++;
      } else {
        break;
      }
    }
    this.returnConnection(jedis);
    return topproducts;
  }
}
```

## 购物车管理员

这个类扩展了`RedisDBManager`类，负责对数据库进行购物车相关的函数调用。实施情况如下：

```java
package org.learningRedis.web.util;
import java.util.Map;
import java.util.Set;
import Redis.clients.jedis.Jedis;
public class ShoppingCartDBManager extends RedisDBManager {
  private ShoppingCartDBManager() {
  }
  public static ShoppingCartDBManager singleton = new ShoppingCartDBManager();
  public String addToShoppingCart(String sessionid, Map<String, String> productQtyMap) {
    Jedis jedis = this.getConnection();
    String result = jedis.hmset(sessionid + "@shoppingcart", productQtyMap);
    this.returnConnection(jedis);
    return result;
  }
  public Map<String, String> myCartInfo(String sessionid) {
    Jedis jedis = this.getConnection();
    Map<String, String> shoppingcart = jedis.hgetAll(sessionid + "@shoppingcart");
    this.returnConnection(jedis);
    return shoppingcart;
  }
  public String editMyCart(String sessionID, Map<String, String> productQtyMap) {
    Jedis jedis = this.getConnection();
    String result = "";
    if (jedis.exists(sessionID + "@shoppingcart")) {
      Set<String> keySet = productQtyMap.keySet();
      for (String key : keySet) {
        if (jedis.hexists(sessionID + "@shoppingcart", key)) {
          Integer intValue = new Integer(productQtyMap.get(key)).intValue();
          if (intValue == 0) {
            jedis.hdel(sessionID + "@shoppingcart", key);
          } else if (intValue > 0) {
            jedis.hset(sessionID + "@shoppingcart", key, productQtyMap.get(key));
          }
        }
      }
      result = "Updated the shopping cart for user";
    } else {
      result = "Could not update the shopping cart for the user !! ";
    }
    this.returnConnection(jedis);
    return result;
  }
  public String buyItemsInTheShoppingCart(String sessionid) {
    Jedis jedis = this.getConnection();
    Map<String, String> cartInfo = jedis.hgetAll(sessionid + "@shoppingcart");
    Set<String> procductNameList = cartInfo.keySet();
    StringBuffer stringBuffer = new StringBuffer();
    stringBuffer.append("RECEIPT: You have purchased the following \n");
    stringBuffer.append("-----------------------------------" + "\n");
    int i = 1;
    for (String productname : procductNameList) {
      String unitCost = jedis.hget(productname, "cost");
      int unitCostValue = new Integer(unitCost).intValue();
      String quantity = cartInfo.get(productname);
      int quantityValue = new Integer(quantity).intValue();
      stringBuffer.append("[" + i + "] Name of item : " + productname + " and quantity was : " + quantity
          + " the total cost is = " + quantityValue * unitCostValue + "\n");
      i++;
    }
    stringBuffer.append("-----------------------------------------");
    stringBuffer.append("#");
    for (String productname : procductNameList) {
      stringBuffer.append(productname);
      stringBuffer.append(",");
    }
    // Update the user purchase history:
    String name = jedis.hget(sessionid + "@sessiondata", "name");
    for (String productname : procductNameList) {
      jedis.lpush(name + "@purchasehistory", productname + " on " + getDate());
    }
    this.returnConnection(jedis);
    return stringBuffer.toString();
  }
}
```

## 用户 cartdmanager

此类扩展了的`RedisDBManager`，并负责对数据库进行与用户相关的函数调用。实施情况如下：

```java
package org.learningRedis.web.util;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import Redis.clients.jedis.Jedis;
public class UserDBManager extends RedisDBManager {
  private UserDBManager() {
  }
  public static UserDBManager singleton = new UserDBManager();
  public String getUserName(String sessionID) {
    Jedis jedis = this.getConnection();
    String name = jedis.hget(sessionID + "@sessiondata", "name");
    this.returnConnection(jedis);
    return name;
  }
  public void createUser(Map<String, String> attriuteMap) {
    Jedis jedis = this.getConnection();
    Map<String, String> map = attriuteMap;
    map.put("creation-time", new Date().toString());
    map.put("sessionID", "null");
    jedis.hmset(attriuteMap.get("name") + "@userdata", map);
    this.returnConnection(jedis);
  }
  public Map<String, String> getRegistrationMap(String name) {
    Jedis jedis = this.getConnection();
    Map<String, String> attributeMap = new HashMap<String, String>();
    attributeMap = jedis.hgetAll(name + "@userdata");
    this.returnConnection(jedis);
    return attributeMap;
  }
  public boolean doesUserExist(String name) {
    Jedis jedis = this.getConnection();
    String value = jedis.hget(name + "@userdata", "name");
    this.returnConnection(jedis);
    if (value == null) {
      return false;
    } else if (value != null & value.equals(name)) {
      return true;
    } else {
      return false;
    }
  }
  public void setRegistrationMap(String name, Map<String, String> attributeMap) {
    Jedis jedis = this.getConnection();
    jedis.hmset(name + "@userdata", attributeMap);
    this.returnConnection(jedis);
  }
  public String getUserPassword(String name) {
    Jedis jedis = this.getConnection();
    String password = jedis.hget(name + "@userdata", "password");
    this.returnConnection(jedis);
    return password;
  }
  public void login(String sessionID, String name) {
    Jedis jedis = this.getConnection();
    Map<String, String> loginMap = new HashMap<String, String>();
    loginMap.put("LastLogin", new Date().toString());
    loginMap.put("loginstatus", "LoggedIn");
    loginMap.put("sessionID", sessionID);
    loginMap.put("name", name);
    jedis.hmset(sessionID + "@sessiondata", loginMap);
    this.returnConnection(jedis);
  }
  public boolean editRegistrationMap(Map<String, String> editMap) {
    Jedis jedis = this.getConnection();
    if (jedis.hget(editMap.get("name") + "@userdata", "sessionID").equals(editMap.get("sessionid"))) {
      jedis.hmset(editMap.get("name") + "@userdata", editMap);
      this.returnConnection(jedis);
      return true;
    } else {
      this.returnConnection(jedis);
      return false;
    }
  }
  public String getUserSessionId(String name) {
    Jedis jedis = this.getConnection();
    String sessionID = jedis.hget(name + "@userdata", "sessionID");
    this.returnConnection(jedis);
    return sessionID;
  }
  public boolean expireSession(String sessionid) {
    // Get name from session data structure
    Jedis jedis = this.getConnection();
    String name = jedis.hget(sessionid + "@sessiondata", "name");
    // remove session id from userdata
    if (name != null) {
      Long sessionvalue = new Long(jedis.hget(name + "@userdata", "sessionID"));
      jedis.hset(name + "@userdata", "sessionID", "null");
      // remove session data : use TTL
      if (jedis.exists(sessionid + "@sessiondata")) {
        jedis.expire(sessionid + "@sessiondata", 1);
      }
      // remove browsing history : use TTL
      if (jedis.exists(sessionid + "@browsinghistory")) {
        jedis.expire(sessionid + "@browsinghistory", 1);
      }
      // remove shopping cart : use TTL
      if (jedis.exists(sessionid + "@shoppingcart")) {
        jedis.expire(sessionid + "@shoppingcart", 1);
      }
      // make the value at offset as '0'
      jedis.setbit("sessionIdTracker", sessionvalue, false);
      this.returnConnection(jedis);
      return true;
    } else {
      this.returnConnection(jedis);
      return false;
    }
  }
  public boolean doesSessionExist(String sessionid) {
    Jedis jedis = this.getConnection();
    if (jedis.hexists(sessionid + "@sessiondata", "name")) {
      this.returnConnection(jedis);
      return true;
    } else {
      this.returnConnection(jedis);
      return false;
    }
  }
}
```

# 总结

因此，在本章中，我们学习了如何以 Redis 为主干构建一个简单的电子商务网站。此外，我们还了解了 Redis 如何方便地进行在线分析。这个示例站点缺乏我们在前几章中了解到的可伸缩性能力。我敦促读者将该功能添加到这个代码库中作为练习，并从这个很棒的数据存储中获得乐趣。

在下一章中，我将介绍如何在业务应用程序中使用 Redis，并制作一些在所有业务应用程序中常用的应用程序。