# 三、JSON 文档

现在我们已经安装了 MySQL 服务器，我们可以开始学习更多关于什么是文档存储以及我们如何开始使用它。核心概念是 JavaScript 对象符号(JSON)文档。我们发现 MySQL 有两种方式处理 JSON 文档:一种纯粹的 NoSQL 文档存储机制，配有完整的开发者应用编程接口，以及一种非常酷的 JSON 与关系数据库的集成。

MySQL 文档存储库的起源在于几种技术，它们被结合在一起形成了文档存储库。特别是，Oracle 将键、值机制与新的数据类型、新的编程库和新的访问机制结合起来，创建了现在的文档存储。正如我们在第 [1](01.html) 章中了解到的，这不仅允许我们使用带有 NoSQL 接口的 MySQL，还允许我们构建混合解决方案，利用关系数据的稳定性和结构，同时增加 JSON 文档的灵活性。

在本章中，我们将了解 MySQL 如何支持 JSON 文档，包括如何添加、查找、更新和删除数据(通常分别称为创建、读取、更新和删除)。我们从你将在本书中遇到的概念和技术的更多信息开始。然后我们继续学习 MySQL 服务器中的 JSON 数据类型和 JSON 函数。尽管本章主要关注的是将 JSON 用于关系数据，但是要掌握 MySQL 文档存储 NoSQL 接口——X Developer API(X DevAPI ),需要有使用 JSON 的坚实基础。

让我们首先回顾一下在 MySQL 中使用文档存储和 JSON 时会遇到的概念和技术。

## 概念和技术:术语解释

正如我们在第 [1](01.html) 章中所了解到的，有几个新概念和新技术以及相关的术语可以用来学习如何使用 MySQL 中的文档存储。我们在第 1 章[中遇到了一些这样的术语，但是我们在 MySQL 的上下文中更详细地探讨它们。也就是说，我们看到这些概念和技术如何解释 JSON 数据类型和文档存储接口的组成。让我们从 JSON 使用的最基本的概念开始:键、价值机制。](01.html)

### 起源:关键，价值机制

正如世界上的大多数事物一样，没有什么东西是真正新的，因为它完全是原始的，没有之前存在的某种形式，并且通常是由以新方式应用的现有技术构建的。关键的价值机制是基础技术的典型例子。我使用术语“机制”,因为键的使用允许您访问值。

当我们说 key，value 时，我们的意思是存在一些标签(通常是一个字符串)构成了键，并且每个键都与一个值相关联。例如，`"name":"George"`是一个示例，其中 key ( `name`)具有一个值(`George`)。虽然键值存储中的值通常是短字符串，但值可以是复杂的:数字；字母数字；列表；或者甚至是嵌套的键值集。

Key，value 机制最出名的是易于编程使用，同时仍然保持可读性。也就是说，通过大量使用空格，一个复杂的嵌套键，值数据结构可以被人类读取。下面显示了一个以开发者格式化代码的方式格式化的示例。如您所见，很容易看出这组键值存储了什么:姓名、地址和电话号码。

```sql
{ "name": {
    "first":"George",
    "last":"Folger"
  },
  "phones": [
    {
      "work":"555-1212"
    },
    {
      "cell":"555-2121"
    }
  ],
  "address": {
    "street":"123 Main Street",
    "city":"melborne",
    "state":"California",
    "zip":"90125"
  }
}

```

回想一下第 [1](01.html) 章，我们看到了这些结构的一些例子。现在我们知道它们是如何以及为什么被建造的。

键、值机制(或存储)的一个例子是可扩展标记语言(XML)，它已经存在了一段时间。下面是一个使用上述数据的简单 XML 示例。它是 SQL `SELECT`查询的结果，输出(行)以 XML 格式显示。 [<sup>1</sup>](#Fn1) 注意 XML 是如何使用 HTML 这样的标签(因为它是从 HTML 派生出来的)以及数据的键值存储的。这里，键是`<row>`、`<field>`，值是开始和结束标记符号之间的内容(`<field> </field>`)。

```sql
<?xml version="1.0"?>
<resultset statement="select * from thermostat_model limit 1;" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <row>
    <field name="model_id">acme123</field>
    <field name="brand">Lennox</field>
  </row>
</resultset>

```

有些系统是围绕键、值机制(称为键、值或关系存储)设计的，比如语义网。简言之，语义网试图利用数据的关联来描述事物、事件等等。有时，术语关系存储或三重存储被用来描述所采用的存储系统的类型。语义 Web 中使用了几种形式的关键值机制，包括资源描述框架(RDF)、Web 本体语言(OWL)和 XML。

还有其他一些关键值机制的例子，但是与文档存储最相关的是 JSON。

### 数据

我在第 [1](01.html) 章对 JSON 做了简单描述。回想一下，JSON 是一种人类和机器可读的数据交换格式。它也是独立于平台的，这意味着不存在禁止它在几乎任何编程语言中使用的格式概念。此外，JSON 是一种在互联网上广泛使用的流行格式。

JSON 允许您以任何想要的方式描述数据，而不强制任何结构。事实上，您可以按照自己的意愿设置数据的格式(布局)。唯一真正的限制是描述符(花括号、方括号、引号、逗号等)的正确使用。)必须对齐，并且在某些情况下正确配对。当编程语言支持时，开发者可以通过键访问数据来轻松读取数据。更好的是，开发者不需要知道键是什么(但这很有帮助！)因为它们可以使用语言支持机制来获取键并对它们进行迭代。这样，像 XML 一样，数据是自描述的。

现在让我们看看文档库的另一个关键组件——从编程库开始的 NoSQL 接口。

### 应用界面

应用编程接口(API)，有时简称为库或编程库，是一组支持一个或多个功能的操作的类和方法。通过这些类和方法，这些功能允许程序员使用这些类和方法来执行各种任务。

例如，当我们在手机、平板电脑或电脑上使用任何带有图形用户界面的应用时，该应用是使用几种 API 之一构建的。图形用户界面本身是使用一个或多个 API 构建的，这些 API 封装了一组用于绘制窗口、创建按钮等的类和方法，所有这些都是图形用户界面设计为提供给开发者的。

在 MySQL 文档存储的情况下，我们使用 X DevAPI 通过一组类和方法来访问服务器，这些类和方法提供了到服务器的连接、概念的抽象(比如集合、表、SQL 操作)等等。正如我们之前了解到的，X DevAPI 也建立在其他一些技术之上，包括通过 X 插件实现的 X 协议。这些技术结合起来形成了 MySQL 服务器的 NoSQL 接口。

### NoSQL 接口

有几个有时相互矛盾的 NoSQL 定义(如果不是例子的话)。对于本书和 MySQL 来说，NoSQL 接口是一个不需要使用 SQL 语句来访问数据的 API。API 本身提供了到服务器的连接，以及创建、检索、更新和删除数据的类和方法。

例如，如果要获取符合特定标准的所有数据，必须首先创建到服务器的连接，请求访问包含数据的对象，然后获取数据。每个步骤都需要创建对象实例，并调用这些对象实例的方法来操作 API。

相比之下，用于与 MySQL 交互的正常机制是通过 SQL 接口，在该接口中，您必须使用严格格式化的 SQL 命令来形成与对象和数据的所有交互。您发出命令并读取结果。如果您想编写一个使用 SQL 接口的应用，比如说获取数据，您必须使用命令来搜索数据，然后将结果转换为内部编程结构，使数据看起来像是一个辅助组件，而不是解决方案的一个组成部分。

NoSQL 接口打破了这种模式，它允许您使用 API 来处理数据。更具体地说，您使用编程接口，而不是基于命令的接口。

此时，您可能想知道 MySQL 如何处理将 JSON 文档与关系数据结合使用的混合选项。基本上，MySQL 被设计成允许在关系数据中存储和检索 JSON 文档(通过 SQL 接口)。也就是说，服务器已经被修改来处理 JSON 文档。还有一组函数允许您对 JSON 数据做各种各样的事情，使得通过 SQL 接口使用 JSON 变得很容易。

然而，您也可以通过 NoSQL X DevAPI 使用 JSON 文档，或者通过 SQL 命令，或者使用 X DevAPI 的特殊类和方法作为纯文档存储。我们将在第 5 章中学习更多关于 X DevAPI 的知识。

### 文档存储

文档存储(也称为面向文档的数据库)是一个用于管理半结构化数据(即文档)的存储和检索系统。现代文档存储系统支持 XML 和 JSON 中的键、值结构。因此，文档存储系统有时被认为是关键值存储系统的一个子类。

文档存储系统也通常由实现为编程接口(API)的 NoSQL 接口来访问，该 API 允许开发者将文档的存储和检索合并到他们的程序中，而不需要第三方访问机制(API 实现访问机制)。事实上，描述数据的元数据嵌入在数据本身中。粗略地说，这意味着键和键的布局(排列或嵌套)形成元数据，并且元数据对于存储机制变得不透明。更具体地说，数据如何排列(文档如何形成或描述数据)并不反映在存储机制中，也不由存储机制管理。对半结构化数据的访问需要使用 NoSQL 接口访问为处理文档本身而设计的机制。

这两个特性:半结构化数据和 NoSQL 接口将文档存储与关系数据分开。关系数据需要不灵活的结构，迫使所有数据符合特定的结构。数据也以相同的结构分组在一起，通常很少考虑内容可能不同的数据。因此，我们通常不会看到通过传统关系数据机制访问文档存储。也就是说，直到现在。

使用文档存储有趣的一点是，学习如何使用文档存储并不需要成为 JavaScript 或 Python 专家。事实上，你要做的大部分事情并不需要掌握任何编程语言。也就是说，有很多如何做事的例子，所以你不需要学习所有关于这门语言的知识来开始。事实上，你可以很快找到你需要的东西，然后随着你的需求的成熟，学习更多的语言知识。

现在，让我们深入了解什么是 JSON 文档，以及如何在 MySQL 中使用它们。

## 介绍 JSON 文档

在 MySQL 5.7.8 和更高版本中，我们可以使用 JSON 数据类型将 JSON 文档存储在表的列中。回想一下第 [1](01.html) 章，虽然可以在文本或 BLOB 字段中嵌入 JSON，但有几个很好的理由不这样做，但最令人信服的理由是因为您必须将数据解析添加到您的程序中，从而使它变得更加复杂，并可能容易出错。JSON 数据类型以两种方式克服了这个问题。

*   验证:JSON 数据类型提供文档验证。也就是说，只有有效的 JSON 才能存储在 JSON 列中。
*   高效访问:当 JSON 文档存储在表中时，存储引擎将数据打包成一种特殊的优化二进制格式，允许服务器快速访问数据元素，而不是每次访问数据时都解析数据。

这为以结构化形式(关系数据)存储非结构化数据开辟了一条全新的途径。然而，Oracle 并没有止步于简单地向 MySQL 添加 JSON 数据类型。Oracle 还增加了一个复杂的编程接口，以及将文档作为集合存储在数据库中的概念。我们将在本书后面看到更多关于这些方面的内容。现在，让我们看看如何将 JSON 用于关系数据。

### JSON 格式规则

JSON 数据是由用某些符号括起来的字符串组成的。尽管我们已经讨论了与 JSON 相关的键、值机制，但 JSON 属性有两种类型:由逗号分隔的列表形成的数组和由一组键、值对形成的对象。您也可以嵌套 JSON 属性。例如，数组可以包含对象，对象键中的值可以包含数组或其他对象。JSON 数组和对象的组合称为 JSON 文档。

JSON 数组包含一个由逗号分隔并括在方括号(`[ ]`)中的值列表。例如，以下是有效的 JSON 数组。

```sql
["red", "green", "yellow", "blue"]
[1,2,3,4,5,6]
[true, false, false]

```

注意，我们用方括号开始和结束数组，并用逗号分隔值。虽然我没有使用空白，但是您可以使用空白，并且根据您的编程语言，您还可以使用换行符、制表符和回车符。例如，下面仍然是一个有效的 JSON 数组。

```sql
["red", 27, "yellow", 4.75, "blue", false]

```

JSON 对象是一组键/值对，其中每个键/值对都包含在左花括号和右花括号(`{ }`)中，并用逗号分隔。例如，以下是有效的 JSON 对象。注意，键地址有一个 JSON 对象作为它的值。

```sql
{"address": {
   "street": "123 First Street",
   "city": "Oxnard",
   "state": "CA",
   "zip": "90122"
}}

{"address": {
    "street":"4 Main Street",
    "city":"Melborne",
    "state":"California",
    "zip":"90125"
}}

{"address": {
    "street":"173 Caroline Ave",
    "city":"Montrose",
    "state":"Georgia",
    "zip":"31505"
}}

```

JSON 数组通常用于包含相关(嗯，有时)事物的列表，JSON 对象用于描述复杂的数据。JSON 数组和对象可以包含标量值，比如字符串或数字、`null`文字(就像在关系数据中一样)，或者布尔文字`true`和`false`。键必须总是字符串，并且通常用引号括起来。最后，JSON 值还可以包含时间信息(日期、时间或日期时间)。例如，下面显示了一个带有时间值的 JSON 数组。

```sql
["03:22:19.012000", "2016-02-03", "2016-02-03 03:22:19.012000"]

```

下一节描述了我们如何在 MySQL 中使用 JSON。在这种情况下，我们指的是关系数据，但是 JSON 文档的格式在文档存储中是相同的。

### 在 MySQL 中使用 JSON

在 MySQL 中使用时，JSON 文档被写成字符串。MySQL 解析 JSON 数据类型中使用的任何字符串来验证文档。如果文档无效——它不是一个格式正确的 JSON 文档——服务器将产生一个错误。您可以在任何合适的 SQL 语句中使用 JSON 文档。例如，你可以用在`INSERT`和`UPDATE`语句中，也可以用在像`WHERE`这样的子句中。

对一些人来说，正确格式化 JSON 文档可能有点困难，尤其是那些不习惯用编程或脚本语言格式化数据结构的人。最需要记住的是平衡你的引号，正确使用逗号，平衡所有的花括号和方括号。很简单，对吧？只有一件事会阻碍一些人:报价！

将键和值指定为字符串时，必须使用双引号字符(")，而不是单引号(')。因为 MySQL 期望 JSON 文档是字符串，所以可以在整个 JSON 文档中使用单引号，但不能在文档本身中使用单引号。幸运的是，MySQL 提供了许多特殊的函数，您可以在 JSON 文档中使用，其中一个是`JSON_VALID()`函数，它允许您检查 JSON 文档的有效性。如果文档有效，则返回 1，否则返回 0。下面显示了使用单引号验证键和值的 JSON 文档与使用双引号验证格式正确的 JSON 文档的结果。

Tip

如果您想将 MySQL Shell 用于 SQL 命令，请确保以 SQL 模式(`--sql`)启动，或者您可以在 Shell 启动后使用`\sql`命令切换到 SQL 模式。

```sql
MySQL  localhost:33060+ ssl  JS > \sql
Switching to SQL mode... Commands end with ;
MySQL  localhost:33060+ ssl  SQL > SELECT JSON_VALID("{'address': {'street': '123 First Street','city': 'Oxnard','state': 'CA','zip': '90122'}}");
+-------------------------------------------------------------------------+
| JSON_VALID("{'address': {'street': '123 First Street','city': 'Oxnard','state': 'CA','zip': '90122'}}") |
+-------------------------------------------------------------------------+
|                                                                       0 |
+-------------------------------------------------------------------------+
1 row in set (0.00 sec)

MySQL  localhost:33060+ ssl  SQL > SELECT JSON_VALID('{"address": {"street": "123 First Street","city": "Oxnard","state": "CA","zip": "90122"}}');
+-------------------------------------------------------------------------+
| JSON_VALID('{"address": {"street": "123 First Street","city": "Oxnard","state": "CA","zip": "90122"}}') |
+-------------------------------------------------------------------------+
|                                                                       1 |
+-------------------------------------------------------------------------+
1 row in set (0.00 sec)

```

请注意，带双引号的字符串有效，但带单引号的字符串无效。这是大多数人在使用 JSON 时首先遇到的问题。

让我们看看如何在 SQL 语句中使用 JSON 文档。假设我们想将前面列出的地址存储在一个表中。对于这个例子，我们保持简单，将数据插入一个非常简单的表中。清单 [3-1](#Par57) 显示了从创建一个测试表开始，然后插入前两个地址的练习的抄本。

Tip

您可以使用附加到 SQL 命令的`\G`命令以垂直格式显示结果，以便于阅读。

```sql
MySQL  localhost:33060+ ssl  Py > \sql
Switching to SQL mode... Commands end with ;
 MySQL  localhost:33060+ ssl  SQL > CREATE DATABASE `test`;
Query OK, 1 row affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > USE `test`;
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > CREATE TABLE `test`.`addresses` (`id` int(11) NOT NULL AUTO_INCREMENT, `address` json DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=latin1;
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > INSERT INTO `test`.`addresses` VALUES (NULL, '{"address": {"street": "123 First Street","city": "Oxnard","state": "CA","zip": "90122"}}');
Query OK, 1 row affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > INSERT INTO `test`.`addresses` VALUES (NULL, '{"address": {"street":"4 Main Street","city":"Melborne","state":"California","zip":"90125"}}');
Query OK, 1 row affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT * FROM `test`.`addresses` \G
*************************** 1\. row ***************************
     id: 1
address: {"address": {"zip": "90122", "city": "Oxnard", "state": "CA", "street": "123 First Street"}}
*************************** 2\. row ***************************
     id: 2
address: {"address": {"zip": "90125", "city": "Melborne", "state": "California", "street": "4 Main Street"}}
2 rows in set (0.00 sec) 

Listing 3-1Using JSON with SQL Statements

```

注意，在`CREATE`语句中，我们使用了数据类型 JSON。这通知 MySQL 在存储引擎中分配特殊的存储机制来处理 JSON。与一些报告相反，JSON 数据类型不仅仅是字符串的直接存储。相反，它是在内部组织的，以优化元素的检索。因此，正确格式化 JSON 非常重要。一个表中可以有多个 JSON 列。然而，一个表行中 JSON 文档的总和被限制为变量`max_allowed_packet`的值。

Note

JSON 列不能像表中的其他列(数据类型)一样有默认值。

现在，让我们看看如果在 SQL 语句中使用无效的 JSON 文档(字符串)会发生什么。下面显示了插入上一个示例中的最后一个地址的尝试，只是没有在关键字周围加上正确的引号。注意抛出的错误。

```sql
MySQL  localhost:33060+ ssl  SQL > INSERT INTO test.addresses VALUES (NULL, '{"address": {street:"173 Caroline Ave",city:"Monstrose",state:"Georgia",zip:31505}}');
ERROR: 3140: Invalid JSON text: "Missing a name for object member." at position 13 in value for column 'addresses.address'.

```

对于任何格式不正确的 JSON 文档，您都可能会看到这样或那样的错误。如果你想先测试你的 JSON，使用`JSON_VALID()`函数。然而，在构建 JSON 文档时，还有另外两个函数可能会有所帮助:`JSON_ARRAY()`和`JSON_OBJECT()`。

`JSON_ARRAY()`函数接受一个值列表，并返回一个有效的格式化 JSON 数组。下面显示了一个示例。注意，它返回了一个格式正确的 JSON 数组，带有正确的引号(双引号而不是单引号)和方括号。

```sql
MySQL  localhost:33060+ ssl  SQL > SELECT JSON_ARRAY(1, true, 'test', 2.4);
+----------------------------------+
| JSON_ARRAY(1, true, 'test', 2.4) |
+----------------------------------+
| [1, true, "test", 2.4]           |
+----------------------------------+
1 row in set (0.00 sec)

```

`JSON_OBJECT()`函数接受一个键、值对列表，并返回一个有效的 JSON 对象。下面显示了一个示例。注意，这里我在调用函数时使用了单引号。这只是一个令人困惑的例子。在这种情况下，函数的参数不是 JSON 文档；它们是普通的 SQL 字符串，可以使用单引号或双引号。

```sql
MySQL  localhost:33060+ ssl  SQL > SELECT JSON_OBJECT("street","4 Main Street","city","Melborne",'state','California','zip',90125);
+-------------------------------------------------------------------------+
| JSON_OBJECT("street","4 Main Street","city","Melborne",'state','California','zip',90125) |
+-------------------------------------------------------------------------+
| {"zip": 90125, "city": "Melborne", "state": "California", "street": "4 Main Street"}     |
+-------------------------------------------------------------------------+
1 row in set (0.00 sec)

```

再次注意，函数中引号的自动转换会导致。如果您需要动态构建 JSON，这可能会很有帮助。

构造 JSON 文档还有一个有用的函数:`JSON_TYPE()`函数。这个函数获取一个 JSON 文档，并将其解析成一个 JSON 值。如果值有效，它将返回该值的 JSON 类型，如果无效，它将抛出一个错误。下面显示了该函数与上述语句的用法。

```sql
MySQL  localhost:33060+ ssl  SQL > SELECT JSON_TYPE('[1, true, "test", 2.4]');
+-------------------------------------+
| JSON_TYPE('[1, true, "test", 2.4]') |
+-------------------------------------+
| ARRAY                               |
+-------------------------------------+
1 row in set (0.00 sec)

MySQL  localhost:33060+ ssl  SQL > SELECT JSON_TYPE('{"zip": 90125, "city": "Melborne", "state": "California", "street": "4 Main Street"}') \G
*************************** 1\. row ***************************
JSON_TYPE('{"zip": 90125, "city": "Melborne", "state": "California", "street": "4 Main Street"}'): OBJECT
1 row in set (0.00 sec)

```

MySQL 提供了更多的函数来处理 JSON 数据类型。我们将在后面的章节中看到更多关于这些的内容。

本节只描述了在 SQL 语句中使用 JSON 和 MySQL 的基础知识。事实上，JSON 文档的格式化也适用于文档存储。然而，有一项我们还没有谈到——如何访问 JSON 文档中的元素。

为了访问一个元素——通过它的键——我们使用一种叫做路径表达式的特殊符号。下面是一个简单的例子。注意`WHERE`子句。这显示了一个路径表达式，在该表达式中，我检查了`address`列是否包含用特殊符号`address->'$.address.city'`引用的 JSON 键‘city’。我们在“路径表达式”一节中可以看到更多关于路径表达式的细节。

```sql
MySQL  localhost:33060+ ssl  SQL > SELECT id, address->'$.address.city' FROM test.addresses WHERE address->'$.address.zip' = '90125';
+----+---------------------------+
| id | address->'$.address.city' |
+----+---------------------------+
|  2 | "Melborne"                |
+----+---------------------------+
1 row in set (0.00 sec)

```

### 路径表达式

如果您认为 JSON 文档可能是一组复杂的半结构化数据，并且在某个时候您需要访问文档中的某些元素，那么您可能还想知道如何从 JSON 文档中获得您想要的东西。幸运的是，有一种机制可以做到这一点，它被称为路径表达式。更具体地说，这是一种快捷表示法，您可以在 SQL 命令中(或在 X DevAPI 中)使用它来获取元素，而无需额外的编程或脚本。

正如您将看到的，这是一个非常具体的语法，虽然不是很有表现力(在英语中读起来不是很好)，但这种符号可以在不需要大量额外输入的情况下获得您需要的内容。路径表达式以包含在字符串中的美元符号(`$`)开始。但是这个符号必须有一个上下文。在 SQL 语句中使用路径表达式时，必须使用`JSON_EXTRACT(`函数，该函数允许您使用路径表达式从 JSON 文档中提取数据。这是因为，与 X DevAPI 类和方法不同，并非所有 SQL 语句都直接支持路径表达式(但正如我们将看到的，有些语句支持路径表达式)。例如，如果您想要数组中的第三项，您可以使用如下函数。

```sql
MySQL  localhost:33060+ ssl  SQL > SELECT JSON_EXTRACT('[1,2,3,4,5,6]', '$[2]');
+---------------------------------------+
| JSON_EXTRACT('[1,2,3,4,5,6]', '$[2]') |
+---------------------------------------+
| 3                                     |
+---------------------------------------+
1 row in set (0.00 sec)

```

注意，这是访问 JSON 数组中的数据。在这里，我们使用一个数组下标，并在索引周围加上方括号(元素从 0 开始)，就像在许多编程语言中使用数组一样。

Tip

SQL 接口中路径表达式的使用仅限于其中一个 JSON 函数，或者仅用于已被修改为接受路径表达式的特定子句，如`SELECT`列列表或`WHERE`、`HAVING`、`ORDER BY`或`GROUP BY`子句。

现在假设你想通过键访问一个元素。你也可以这样做。在这种情况下，我们使用美元符号后跟一个句点，然后是键名。下面显示了如何检索包含个人姓名和地址的 JSON 对象的姓氏。

```sql
MySQL  localhost:33060+ ssl  SQL > SELECT JSON_EXTRACT('{"name": {"first":"Billy-bob","last":"Throckmutton"},"address": {"street":"4 Main Street","city":"Melborne","state":"California","zip":"90125"}}', '$.name.first') AS Name;
+-------------+
| Name        |
+-------------+
| "Billy-bob" |
+-------------+
1 row in set (0.00 sec)

```

请注意，我必须使用两个级别的访问权限。也就是说，我想要名为 name 的对象中名为 first 的键的值。因此，我使用了`'$.name.first'`。这演示了如何使用路径表达式深入 JSON 文档。这也是为什么我们称之为路径表达式，因为我们形成表达式的方式给了我们到元素的“路径”。

现在我们已经看到了一些例子，让我们回顾一下路径表达式的完整语法；两者都在 SQL 和 NoSQL 接口中使用。除非另有说明，否则语法方面适用于两种接口。

再说一次，路径表达式以美元符号开始，后面可以有几种叫做选择器的语法形式，允许我们请求文档的一部分。这些选择器包括:

*   一个句点后跟一个键名，引用该键的值。如果不带引号的名称无效(要求引号是有效的标识符，如带空格的键名)，则必须在双引号内指定键名。
*   使用带有整数索引(`[n]`)的方括号来选择数组中的元素。索引从 0 开始。
*   路径可以包含通配符*或**，如下所示。
    *   `.[*]`计算 JSON 对象中所有成员的值。
    *   `[*]`计算 JSON 数组中所有元素的值。
    *   诸如前缀`**`后缀的序列评估以命名前缀开始并以命名后缀结束的所有路径。
*   可以使用句点作为分隔符来嵌套路径。在这种情况下，句点之后的路径在父路径上下文的上下文中进行评估。例如，`$.name.first`将名为`first`的键的搜索限制在`name` JSON 对象中。

如果路径表达式被评估为假或者无法定位数据项，服务器将返回`null`。例如，下面返回`null`，因为数组中只有 6 项。你能看出为什么吗？记住，计数从 0 开始。对于那些不熟悉使用路径表达式(或者编程语言中的数组)的人来说，这是一个常见的错误。

```sql
MySQL  localhost:33060+ ssl  SQL > SELECT JSON_EXTRACT('[1,2,3,4,5,6]', '$[6]');
+---------------------------------------+
| JSON_EXTRACT('[1,2,3,4,5,6]', '$[6]') |
+---------------------------------------+
| NULL                                  |
+---------------------------------------+
1 row in set (0.00 sec)

```

但是等等，路径表达式还有一个更好的选择。我们可以走捷径！也就是说，当按列访问 SQL 语句中的数据时，可以使用破折号和大于号(`->`)来代替`JSON_EXTRACT()`函数。这有多酷？使用`->`操作有时被称为内嵌路径表达式。例如，我们可以编写上面的例子，从一个表中查找 JSON 数组中的第三项，如下所示。

```sql
 MySQL  localhost:33060+ ssl  SQL > USE test;
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > CREATE TABLE ex1 (id int AUTO_INCREMENT PRIMARY KEY, recorded_data JSON);
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > INSERT INTO test.ex1 VALUES (NULL, JSON_ARRAY(1,2,3,4,5,6));
Query OK, 1 row affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > INSERT INTO test.ex1 VALUES (NULL, JSON_ARRAY(7,8,9));
Query OK, 1 row affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT * FROM test.ex1 WHERE recorded_data->'$[2]' = 3;
+----+--------------------+
| id | recorded_data      |
+----+--------------------+
|  1 | [1, 2, 3, 4, 5, 6] |
+----+--------------------+
1 row in set (0.00 sec)

```

注意，我只是使用了列名`recorded_data`，并在末尾添加了`->`，然后列出了路径表达式。太棒了！

这种捷径还有一种形式。如果`->`操作(`JSON_EXTRACT`)的结果是一个带引号的字符串，我们可以使用`->>`符号(称为内嵌路径操作符)来检索不带引号的值。这在处理数值时很有帮助。下面给出了两个例子。一个例子是`->`操作，同样的例子还有`->>`操作。

```sql
 MySQL  localhost:33060+ ssl  SQL > INSERT INTO test.ex1 VALUES (NULL, '{"name":"will","age":"43"}');
Query OK, 1 row affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > INSERT INTO test.ex1 VALUES (NULL, '{"name":"joseph","age":"11"}');
Query OK, 1 row affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT * FROM test.ex1 WHERE recorded_data->>'$.age' = 43;
+----+-------------------------------+
| id | recorded_data                 |
+----+-------------------------------+
|  3 | {"age": "43", "name": "will"} |
+----+-------------------------------+
1 row in set (0.00 sec)

MySQL  localhost:33060+ ssl  SQL > SELECT * FROM test.ex1 WHERE recorded_data->'$.age' = 43;
Empty set (0.00 sec)

```

请注意，recorded_data 值(年龄和姓名)存储为一个字符串。但是如果数据存储为整数会怎么样呢？观察。

```sql
 MySQL  localhost:33060+ ssl  SQL > INSERT INTO test.ex1 VALUES (NULL, '{"name":"amy","age":22}');
Query OK, 1 row affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT * FROM test.ex1 WHERE recorded_data->'$.age' = 22;
+----+----------------------------+
| id | recorded_data              |
+----+----------------------------+
|  5 | {"age": 22, "name": "amy"} |
+----+----------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT * FROM test.ex1 WHERE recorded_data->>'$.age' = 22;
+----+----------------------------+
| id | recorded_data              |
+----+----------------------------+
|  5 | {"age": 22, "name": "amy"} |
+----+----------------------------+
1 row in set (0.00 sec)

```

啊哈！因此，当值必须不加引号时，`->>`操作最有用。如果它们已经被取消引用(比如一个整数)，那么`->>`操作将返回与`->`操作相同的结果。

现在，让我们再看几个路径表达式的例子。清单 [3-2](#Par102) 展示了几个例子，没有解释。花几分钟时间浏览这些内容，并检查它所操作的数据，这样您就可以看到每个内容是如何工作的。只要有一点想象力，您就可以深入到单个数据元素！

```sql
 MySQL  localhost:33060+ ssl  SQL > INSERT INTO test.ex1 VALUES (NULL, '{"name": {"last": "Throckmutton", "first": "Billy-bob"}, "address": {"zip": "90125", "city": "Melborne", "state": "California", "street": "4 Main Street"}}');
Query OK, 1 row affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT recorded_data FROM test.ex1 WHERE recorded_data->'$.name' IS NOT NULL \G
*************************** 1\. row ***************************
recorded_data: {"age": "43", "name": "will"}
*************************** 2\. row ***************************
recorded_data: {"age": "11", "name": "joseph"}
*************************** 3\. row ***************************
recorded_data: {"age": 22, "name": "amy"}
*************************** 4\. row ***************************
recorded_data: {"name": {"last": "Throckmutton", "first": "Billy-bob"}, "address": {"zip": "90125", "city": "Melborne", "state": "California", "street": "4 Main Street"}}
4 rows in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT recorded_data->'$.name' FROM test.ex1 WHERE recorded_data->'$.name' IS NOT NULL;
+------------------------------------------------+
| recorded_data->'$.name'                        |
+------------------------------------------------+
| "will"                                         |
| "joseph"                                       |
| "amy"                                          |
| {"last": "Throckmutton", "first": "Billy-bob"} |
+------------------------------------------------+
4 rows in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT recorded_data->'$.name.first' as first, recorded_data->'$.name.last' as last FROM test.ex1 WHERE recorded_data->'$.name.first' IS NOT NULL;
+-------------+----------------+
| first       | last           |
+-------------+----------------+
| "Billy-bob" | "Throckmutton" |
+-------------+----------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > INSERT INTO test.ex1 VALUES (NULL, '{"phones": [{"work": "555-1212"}, {"cell": "555-2121"}]}');
Query OK, 1 row affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT recorded_data->>'$.phones' FROM test.ex1 WHERE recorded_data->>'$.phones' IS NOT NULL;
+----------------------------------------------+
| recorded_data->>'$.phones'                   |
+----------------------------------------------+
| [{"work": "555-1212"}, {"cell": "555-2121"}] |
+----------------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT recorded_data->'$.phones[1]' FROM test.ex1 WHERE recorded_data->>'$.phones' IS NOT NULL;
+------------------------------+
| recorded_data->'$.phones[1]' |
+------------------------------+
| {"cell": "555-2121"}         |
+------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT recorded_data->'$.phones[1].cell' FROM test.ex1 WHERE recorded_data->>'$.phones' IS NOT NULL;
+-----------------------------------+
| recorded_data->'$.phones[1].cell' |
+-----------------------------------+
| "555-2121"                        |
+-----------------------------------+
1 row in set (0.00 sec)
Listing 3-2Examples of Path Expressions

```

注意，我在 WHERE 子句中使用了路径表达式来检查结果是否不为空。这是在表格中选择包含您在文档中寻找的元素的行的一个好技巧。也就是说，您只需要包含特定数据元素的行(通过路径表达式)。

然而，快捷方式(内联路径表达式)的使用并不能直接替代 JSON_EXTRACT()函数。下面总结了这些限制。

*   数据源:在 SQL 语句中使用时，内联路径表达式仅使用指定的字段(列)。该函数可以使用任何 JSON 类型的值。
*   路径表达式字符串:内联路径表达式必须使用普通字符串；该函数可以使用任何字符串类型的值。
*   表达式的数量:内联路径表达式只能对单个字段(列)使用一个路径表达式。该函数可以对一个 JSON 文档使用多个路径表达式。

Tip

有关路径表达式的更多信息，请参见在线 MySQL 参考手册中的“JSON 数据类型”一节。

现在让我们看看可以用来处理 JSON 文档的各种 JSON 函数。

### JSON 函数

在 MySQL 中使用 JSON 有几个函数。我在这一节中描述了许多可用的功能。虽然我们不会探究每个函数的细微差别，但是我们会看到处理 JSON 文档时更常用的函数。让我们以可用功能列表的形式开始概述。表 [3-1](#Tab1) 列出了 MySQL 8.0.11 中可用的 JSON 函数。

表 3-1

JSON Functions in MySQL

<colgroup><col align="left"> <col align="left"></colgroup> 
| 功能 | 描述和使用 |
| :-- | :-- |
| `JSON_ARRAY()` | 计算一列值，并返回包含这些值的 JSON 数组 |
| `JSON_ARRAYAGG()` | 将结果集聚合为一个 JSON 数组，其元素由行组成 |
| `JSON_ARRAY_APPEND()` | 将值追加到 JSON 文档中指定数组的末尾，并返回结果 |
| `JSON_ARRAY_INSERT()` | 更新一个 JSON 文档，在文档中插入一个数组并返回修改后的文档 |
| `JSON_CONTAINS()` | 返回 0 或 1 以指示特定值是否包含在目标 JSON 文档中，或者，如果给定了路径参数，则返回目标文档中的特定路径 |
| `JSON_CONTAINS_PATH()` | 返回 0 或 1，以指示 JSON 文档是否包含给定路径中的数据 |
| `JSON_DEPTH()` | 返回 JSON 文档的最大深度 |
| `JSON_EXTRACT()` | 从 JSON 文档中返回数据，这些数据是从与路径参数匹配的文档部分中选择的 |
| `JSON_INSERT()` | 将数据插入 JSON 文档并返回结果 |
| `JSON_KEYS()` | 以 JSON 数组的形式返回 JSON 对象顶层值的键，或者，如果给定了路径参数，则返回所选路径的顶层键 |
| `JSON_LENGTH()` | 返回 JSON 文档的长度，或者，如果给定了路径参数，则返回由路径标识的文档中的值的长度 |
| `JSON_MERGE()` | 合并两个或多个 JSON 文档并返回合并结果 |
| `JSON_MERGE_PATCH()` | 合并两个或多个 JSON 文档，替换重复键的值 |
| `JSON_MERGE_PRESERVE()` | 合并两个或多个 JSON 文档，保存重复键的值 |
| `JSON_OBJECT()` | 评估键/值对列表，并返回包含这些对的 JSON 对象 |
| `JSON_OBJECTAGG()` | 接受两个列名或表达式作为参数，第一个用作键，第二个用作值，并返回包含键/值对的 JSON 对象 |
| `JSON_PRETTY()` | 打印出更美观的 JSON 文档布局 |
| `JSON_QUOTE()` | 通过用双引号字符将字符串括起来并转义内部引号和其他字符，将字符串作为 JSON 值引用，然后将结果作为 utf8mb4 字符串返回 |
| `JSON_REMOVE()` | 从 JSON 文档中移除数据并返回结果 |
| `JSON_REPLACE()` | 替换 JSON 文档中的现有值并返回结果 |
| `JSON_SEARCH()` | 返回 JSON 文档中给定字符串的路径 |
| `JSON_SET()` | 在 JSON 文档中插入或更新数据，并返回结果 |
| `JSON_STORAGE_FREE()` | 显示部分更新后 JSON 列中剩余的空间量 |
| `JSON_STORAGE_SIZE()` | 显示 JSON 值使用的存储 |
| `JSON_TABLE()` | 从 JSON 文档中提取数据，并将其作为关系表返回 |
| `JSON_TYPE()` | 返回表示 JSON 值类型的 utf8mb4 字符串 |
| `JSON_UNQUOTE()` | 从 JSON 值中删除引号，并将结果作为 utf8mb4 字符串返回 |
| `JSON_VALID()` | 返回 0 或 1 以指示值是否是有效的 JSON 文档 |

Note

在 8.0.3 版本中不推荐使用`JSON_MERGE()`函数(在 5.7.22 版本中也是如此)。

掌握这些函数对于使用文档存储并不重要，但是在开发混合解决方案(在 SQL 语句中使用 JSON)时会有很大帮助。

这些功能可以根据它们的使用方式进行分类。我们将看到对添加数据有用的函数，检索(搜索)数据的函数，等等。下面用简单的例子说明如何使用这些功能。

大多数函数将 JSON 文档作为第一个参数，将路径表达式和值作为第二个和第三个参数。路径表达式必须对文档有效，并且不得包含通配符`*`或`**`。这些函数也返回结果，因此您可以在 SQL 语句中使用它们。

#### 创建 JSON 数据

创建 JSON 数据有几个有用的函数。我们已经看到了两个重要的功能；`JSON_ARRAY()`构建 JSON 数组类型，而`JSON_OBJECT()`构建 JSON 对象类型。本节讨论一些其他函数，这些函数可以用来帮助创建 JSON 文档，包括在 JSON 数组中聚合、追加和插入数据的函数。

`JSON_ARRAYAGG()`函数用于从几行中创建一个 JSON 文档数组。当您想要汇总数据或合并多行数据时，它会很有帮助。该函数接受一个列名，并将行中的 JSON 数据组合到一个新数组中。清单 [3-3](#Par117) 展示了使用该函数的例子。这个示例获取表中的行，并将它们组合起来形成一个新的 JSON 对象数组。

```sql
 MySQL  localhost:33060+ ssl  SQL > CREATE TABLE test.favorites (id int AUTO_INCREMENT PRIMARY KEY, preferences JSON);
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > INSERT INTO test.favorites VALUES (NULL, '{"color": "red"}');
Query OK, 1 row affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > INSERT INTO test.favorites VALUES (NULL, '{"color": "blue"}');
Query OK, 1 row affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > INSERT INTO test.favorites VALUES (NULL, '{"color": "purple"}');
Query OK, 1 row affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT * FROM test.favorites;
+----+---------------------+
| id | preferences         |
+----+---------------------+
|  1 | {"color": "red"}    |
|  2 | {"color": "blue"}   |
|  3 | {"color": "purple"} |
+----+---------------------+
3 rows in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_ARRAYAGG(preferences) FROM test.favorites;
+------------------------------------------------------------+
| JSON_ARRAYAGG(preferences)                                 |
+------------------------------------------------------------+
| [{"color": "red"}, {"color": "blue"}, {"color": "purple"}] |
+------------------------------------------------------------+
1 row in set (0.00 sec)
Listing 3-3Using the JSON_ARRAYARG Function

```

`JSON_ARRAY_APPEND()`是一个有趣的函数，它允许您将数据附加到 JSON 数组的末尾或紧接在给定路径表达式之后。该函数将 JSON 数组、路径表达式和要插入的值(包括 JSON 文档)作为参数。清单 [3-4](#Par119) 展示了几个例子。

```sql
 MySQL  localhost:33060+ ssl  SQL > SET @base = '["apple","pear",{"grape":"red"},"strawberry"]';
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_ARRAY_APPEND(@base, '$', "banana");
+-------------------------------------------------------------+
| JSON_ARRAY_APPEND(@base, '$', "banana")                     |
+-------------------------------------------------------------+
| ["apple", "pear", {"grape": "red"}, "strawberry", "banana"] |
+-------------------------------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_ARRAY_APPEND(@base, '$[2].grape', "green");
+--------------------------------------------------------------+
| JSON_ARRAY_APPEND(@base, '$[2].grape', "green")              |
+--------------------------------------------------------------+
| ["apple", "pear", {"grape": ["red", "green"]}, "strawberry"] |
+--------------------------------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SET @base = '{"grape":"red"}';
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_ARRAY_APPEND(@base, '$', '{"grape":"red"}');
+--------------------------------------------------+
| JSON_ARRAY_APPEND(@base, '$', '{"grape":"red"}') |
+--------------------------------------------------+
| [{"grape": "red"}, "{\"grape\":\"red\"}"]        |
+--------------------------------------------------+
1 row in set (0.00 sec)
Listing 3-4Using the JSON_ARRAY_APPEND Function

```

请注意，第一个示例只是在数组末尾添加了一个新值。第二个示例将第三个索引中 JSON 对象的键值更改为一个数组，并添加一个新值。这是这个函数的一个有趣的副产品。在第三个例子中，我们再次看到了这一点，我们将一个基本的 JSON 对象更改为一个 JSON 对象的 JSON 数组。

`JSON_ARRAY_INSERT()`函数类似，只是它在路径表达式前插入值。该函数将 JSON 数组、路径表达式和要插入的值(包括 JSON 文档)作为参数。当包含多个路径表达式和值对时，当函数计算第一个路径表达式和值并将下一个对应用于结果时，效果是累积的，依此类推。清单 [3-5](#Par122) 展示了一些使用新函数的例子，这些例子与前面的例子相似。请注意，插入数据的位置在路径表达式之前。

```sql
 MySQL  localhost:33060+ ssl  SQL > SET @base = '["apple","pear",{"grape":["red","green"]},"strawberry"]';
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_ARRAY_INSERT(@base, '$[0]', "banana");
+------------------------------------------------------------------------+
| JSON_ARRAY_INSERT(@base, '$[0]', "banana")                             |
+------------------------------------------------------------------------+
| ["banana", "apple", "pear", {"grape": ["red", "green"]}, "strawberry"] |
+------------------------------------------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_ARRAY_INSERT(@base, '$[2].grape[0]', "white");
+-----------------------------------------------------------------------+
| JSON_ARRAY_INSERT(@base, '$[2].grape[0]', "white")                    |
+-----------------------------------------------------------------------+
| ["apple", "pear", {"grape": ["white", "red", "green"]}, "strawberry"] |
+-----------------------------------------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SET @base = '[{"grape":"red"}]';
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_ARRAY_INSERT(@base, '$[0]', '{"grape":"red"}');
+-----------------------------------------------------+
| JSON_ARRAY_INSERT(@base, '$[0]', '{"grape":"red"}') |
+-----------------------------------------------------+
| ["{\"grape\":\"red\"}", {"grape": "red"}]           |
+-----------------------------------------------------+
1 row in set (0.00 sec)
Listing 3-5Using the JSON_ARRAY_INSERT Function

```

`JSON_INSERT()`函数被设计成获取一个 JSON 文档，并在指定的路径表达式中插入一个或多个值。也就是说，您可以一次传递成对的路径表达式和值。但是有一个问题。在这种情况下，路径表达式不能计算为文档中的元素。与最后一个函数一样，当包含多个路径表达式时，当该函数对第一个路径表达式求值并将下一个路径表达式应用于结果时，效果是累积的，依此类推。清单 [3-6](#Par124) 显示了一个例子。注意，没有插入第三个路径表达式和值，因为路径表达式`$[0]`的计算结果是第一个元素`apple`。

```sql
 MySQL  localhost:33060+ ssl  SQL > SET @base = '["apple","pear",{"grape":["red","green"]},"strawberry"]';
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_INSERT(@base, '$[9]', "banana", '$[2].grape[3]', "white", '$[0]', "orange");
+-------------------------------------------------------------------------+
| JSON_INSERT(@base, '$[9]', "banana", '$[2].grape[3]', "white", '$[0]', "orange") |
+-------------------------------------------------------------------------+
| ["apple", "pear", {"grape": ["red", "green", "white"]}, "strawberry", "banana"]  |
+-------------------------------------------------------------------------+
1 row in set (0.00 sec) 

Listing 3-6Using the JSON_INSERT Function

```

`JSON_MERGE_PATCH()`和 JSON_MERGE_PRESERVE()函数被设计成获取两个或更多 JSON 文档并组合它们。`JSON_MERGE_PATH()`函数替换重复键的值，而`JSON_MERGE_PRESERVE()`函数保留重复键的值。和前面的函数一样，您可以包含任意多的 JSON 文档。请注意我是如何使用这个函数从前面的例子中构建示例 JSON 文档的。清单 [3-7](#Par126) 展示了一个使用这些方法的例子。

```sql
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_MERGE_PATCH('["apple","pear"]', '{"grape":["red","green"]}', '["strawberry"]');
+-------------------------------------------------------------------------+
| JSON_MERGE_PATCH('["apple","pear"]', '{"grape":["red","green"]}', '["strawberry"]') |
+-------------------------------------------------------------------------+
| ["strawberry"]                                                          |
+-------------------------------------------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_MERGE_PRESERVE('{"grape":["red","green"]}', '{"grape":["white"]}');
+-------------------------------------------------------------------------+
| JSON_MERGE_PRESERVE('{"grape":["red","green"]}', '{"grape":["white"]}') |
+-------------------------------------------------------------------------+
| {"grape": ["red", "green", "white"]}                                    |
+-------------------------------------------------------------------------+
1 row in set (0.00 sec)
Listing 3-7Using the JSON_MERGE_
PATCH

and JSON_MERGE_PRESERVE Functions

```

如果向任何 JSON 函数传递了无效的参数、无效的 JSON 文档，或者路径表达式没有找到元素，则一些函数会返回 null，而其他函数可能会返回原始的 JSON 文档。清单 [3-8](#Par128) 显示了一个例子。在这种情况下，位置 8 没有元素，因为数组只有 4 个元素。

```sql
 MySQL  localhost:33060+ ssl  SQL > SET @base = '["apple","pear",{"grape":"red"},"strawberry"]';
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_ARRAY_APPEND(@base, '$[7]', "flesh");
+---------------------------------------------------+
| JSON_ARRAY_APPEND(@base, '$[7]', "flesh")         |
+---------------------------------------------------+
| ["apple", "pear", {"grape": "red"}, "strawberry"] |
+---------------------------------------------------+
1 row in set (0.00 sec)
Listing 3-8Using the JSON_ARRAY_APPEND Function

```

现在让我们看看可以用来修改 JSON 数据的函数。

#### 修改 JSON 数据

修改 JSON 数据有几个有用的函数。本节讨论了通过删除、替换和更新 JSON 文档中的元素来帮助修改 JSON 文档的函数。

`JSON_REMOVE()`函数用于删除匹配路径表达式的元素。您必须提供要操作的 JSON 文档以及一个或多个路径表达式，结果将是删除了元素的 JSON 文档。当包含多个路径表达式时，当函数计算第一个路径表达式并将下一个路径表达式应用于结果时，效果是累积的，依此类推。清单 [3-9](#Par132) 显示了一个例子。注意，我必须想象中间结果会是什么——也就是说，我使用了三次`$[0]`,因为函数两次删除了第一个元素，留下 JSON 对象作为第一个元素。

```sql
 MySQL  localhost:33060+ ssl  SQL > SET @base = '["apple","pear",{"grape":["red","white"]},"strawberry"]';
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_REMOVE(@base, '$[0]', '$[0]', '$[0].grape[1]');
+-----------------------------------------------------+
| JSON_REMOVE(@base, '$[0]', '$[0]', '$[0].grape[1]') |
+-----------------------------------------------------+
| [{"grape": ["red"]}, "strawberry"]                  |
+-----------------------------------------------------+
1 row in set (0.00 sec)
Listing 3-9Using the JSON_REMOVE Function (Single)

```

这可能需要一点时间来适应，但您可以多次使用该函数或嵌套使用，如清单 [3-10](#Par134) 中的示例所示。

```sql
 MySQL  localhost:33060+ ssl  SQL > SET @base = '["apple","pear",{"grape":["red","white"]},"strawberry"]';
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SET @base = JSON_REMOVE(@base, '$[0]');
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SET @base = JSON_REMOVE(@base, '$[0]');
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_REMOVE(@base, '$[0].grape[1]');
+-------------------------------------+
| JSON_REMOVE(@base, '$[0].grape[1]') |
+-------------------------------------+
| [{"grape": ["red"]}, "strawberry"]  |
+-------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SET @base = '["apple","pear",{"grape":["red","white"]},"strawberry"]';
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_REMOVE(JSON_REMOVE(JSON_REMOVE(@base, '$[0]'), '$[0]'), '$[0].grape[1]');
+-------------------------------------------------------------------------+
| JSON_REMOVE(JSON_REMOVE(JSON_REMOVE(@base, '$[0]'), '$[0]'), '$[0].grape[1]') |
+-------------------------------------------------------------------------+
| [{"grape": ["red"]}, "strawberry"]                                      |
+-------------------------------------------------------------------------+
1 row in set (0.00 sec)
Listing 3-10Using the JSON_REMOVE Function (Nested)

```

`JSON_REPLACE()`函数接受一个 JSON 文档和一对路径表达式和值，用新值替换匹配路径表达式的元素。同样，结果是累积的，并按从左到右的顺序工作。这个函数也有一个问题。它会忽略任何新值或评估为新值的路径表达式。清单 [3-11](#Par136) 显示了一个例子。注意，第三对没有被删除，因为没有第十个元素。

```sql
 MySQL  localhost:33060+ ssl  SQL > SET @base = '["apple","pear",{"grape":["red","white"]},"strawberry"]';
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_REPLACE(@base, '$[0]', "orange", '$[2].grape[0]', "green", '$[9]', "waffles");
+-------------------------------------------------------------------------+
| JSON_REPLACE(@base, '$[0]', "orange", '$[2].grape[0]', "green", '$[9]', "waffles") |
+-------------------------------------------------------------------------+
| ["orange", "pear", {"grape": ["green", "white"]}, "strawberry"]         |
+-------------------------------------------------------------------------+
1 row in set (0.00 sec)
Listing 3-11Using the JSON_REPLACE Function

```

`JSON_SET()`函数用于修改 JSON 文档元素。与其他函数一样，您传递一个 JSON 文档作为第一个参数，然后传递一对或多对要替换的路径表达式和值。但是，该函数还会插入文档中不存在的任何元素(找不到路径表达式)。清单 [3-12](#Par138) 显示了一个例子。注意，最后一个元素并不存在，所以它将它添加到文档中。

```sql
 MySQL  localhost:33060+ ssl  SQL > SET @base = '["apple","pear",{"grape":["red","white"]},"strawberry"]';
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_SET(@base, '$[0]', "orange", '$[2].grape[1]', "green", '$[9]', "123");
+-------------------------------------------------------------------------+
| JSON_SET(@base, '$[0]', "orange", '$[2].grape[1]', "green", '$[9]', "123") |
+-------------------------------------------------------------------------+
| ["orange", "pear", {"grape": ["red", "green"]}, "strawberry", "123"]    |
+-------------------------------------------------------------------------+
1 row in set (0.00 sec) 

Listing 3-12Using the JSON_SET Function

```

Ignore or Not Ignore, Which Does What?

JSON 函数的一个问题是，有些函数会对现有的值进行操作，有些函数会忽略现有的值，有些函数会添加尚不存在的值，等等。如果你不熟悉所有的功能，它会变得令人困惑。下面总结了那些最容易混淆的函数之间的差异。

*   `JSON_INSERT()`:添加新值，但不替换现有值
*   `JSON_REMOVE()`:删除文档中存在的元素，忽略不存在的元素
*   `JSON_REPLACE()`:替换现有值，忽略新值
*   `JSON_SET()`:替换存在路径的值，增加不存在路径的值

如果您想使用这些函数，请务必用示例数据检查它们，直到您理解这些条件。

现在让我们看看可以用来在文档中查找元素的 JSON 函数。

#### 搜索 JSON 数据

处理 SQL 和 JSON 数据的另一个重要操作是在 JSON 文档中搜索数据。我们在前面的章节中发现了如何用特殊符号(路径表达式)引用文档中的数据，我们还知道了可以用 JSON 函数来搜索数据。事实上，我们在上一节中看到了这两个概念一起使用。在这一节中，我们将回顾 JSON 数据搜索机制，因为您可能会比其他任何函数更多地使用这些函数，尤其是在查询中。

有四个 JSON 函数允许您搜索 JSON 文档。与前面的函数一样，这些函数使用一个或多个参数对 JSON 文档进行操作。我称它们为搜索函数，不是因为它们允许您在数据库或表格中搜索 JSON 数据，而是因为它们允许您在 JSON 文档中查找东西。这些函数包括检查文档中是否存在值或元素、路径表达式是否有效(使用它可以找到一些东西)以及从文档中检索信息的函数。

`JSON_CONTAINS()`函数有两个选项:您可以使用它来返回一个值是否存在于文档中的任何地方，或者是否存在使用路径表达式的值(路径表达式是一个可选参数)。该函数返回 0 或 1，其中 0 表示未找到该值。如果文档参数不是有效的 JSON 文档，路径参数不是有效的路径表达式，或者包含*或**通配符，则会出现错误。还有一个问题。传入的值必须是有效的 JSON 字符串或文档。清单 3-13 展示了使用该函数搜索 JSON 文档的几个例子。

```sql
 MySQL  localhost:33060+ ssl  SQL > SET @base = '{"grapes":["red","white","green"],"berries":["strawberry","raspberry","boysenberry","blackberrry"]}';
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_CONTAINS(@base,'["red","white","green"]');
+------------------------------------------------+
| JSON_CONTAINS(@base,'["red","white","green"]') |
+------------------------------------------------+
|                                              0 |
+------------------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_CONTAINS(@base,'{"grapes":["red","white","green"]}');
+-----------------------------------------------------------+
| JSON_CONTAINS(@base,'{"grapes":["red","white","green"]}') |
+-----------------------------------------------------------+
|                                                         1 |
+-----------------------------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_CONTAINS(@base,'["red","white","green"]','$.grapes');
+-----------------------------------------------------------+
| JSON_CONTAINS(@base,'["red","white","green"]','$.grapes') |
+-----------------------------------------------------------+
|                                                         1 |
+-----------------------------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_CONTAINS(@base,'"blackberry"','$.berries');
+-------------------------------------------------+
| JSON_CONTAINS(@base,'"blackberry"','$.berries') |
+-------------------------------------------------+
|                                               0 |
+-------------------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_CONTAINS(@base,'blackberry','$.berries');
ERROR: 3141: Invalid JSON text in argument 2 to function json_contains: "Invalid value." at position 0.
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_CONTAINS(@base,'"red"','$.grapes');
+-----------------------------------------+
| JSON_CONTAINS(@base,'"red"','$.grapes') |
+-----------------------------------------+
|                                       1 |
+-----------------------------------------+
1 row in set (0.00 sec)
Listing 3-13Using the JSON_CONTAINS Function

```

正如你所看到的，这是一个非常有用的函数，但是要正确使用它需要一点小心。也就是说，您必须确保该值是有效的字符串。在所有的例子中，除了一个例子，我在 JSON 文档中搜索 JSON 文档(这使得搜索嵌套数据更容易)，或者使用路径表达式搜索单个值。记住，函数搜索的是值，而不是键。

请注意倒数第二个示例:这将返回一个错误，因为该值不是有效的 JSON 字符串。您必须用双引号将它括起来，如下例所示。

`JSON_CONTAINS_PATH()`函数使用的参数策略略有不同。该函数搜索 JSON 文档以查看路径表达式是否存在，但它也允许您查找第一个或所有的匹配项。它还可以采用多个路径，并根据您作为第二个参数传递的值，将它们作为“或”或“与”条件进行评估，如下所示:

*   如果您传递`one`，如果至少找到一个路径表达式，函数将返回 1(OR)。
*   如果传递`all`，只有找到所有路径表达式，函数才会返回 1(AND)。

该函数返回 0 或 1，以指示 JSON 文档在给定的一个或多个路径中是否包含数据。请注意，如果任何路径表达式或文档为 null，它可能会返回 null。如果 JSON 文档或任何路径表达式无效，或者第二个参数不是`one`或`all`，则会出现错误。清单 [3-14](#Par156) 显示了使用该功能的几个例子。

```sql
 MySQL  localhost:33060+ ssl  SQL > SET @base = '{"grapes":["red","white","green"],"berries":["strawberry","raspberry","boysenberry","blackberrry"],"numbers":["1","2","3","4","5"]}';
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_CONTAINS_PATH(@base,'one','$');
+-------------------------------------+
| JSON_CONTAINS_PATH(@base,'one','$') |
+-------------------------------------+
|                                   1 |
+-------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_CONTAINS_PATH(@base,'all','$');
+-------------------------------------+
| JSON_CONTAINS_PATH(@base,'all','$') |
+-------------------------------------+
|                                   1 |
+-------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_CONTAINS_PATH(@base,'all','$.grapes','$.berries');
+--------------------------------------------------------+
| JSON_CONTAINS_PATH(@base,'all','$.grapes','$.berries') |
+--------------------------------------------------------+
|                                                      1 |
+--------------------------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_CONTAINS_PATH(@base,'all','$.grapes','$.berries','$.numbers');
+--------------------------------------------------------------------+
| JSON_CONTAINS_PATH(@base,'all','$.grapes','$.berries','$.numbers') |
+--------------------------------------------------------------------+
|                                                                  1 |
+--------------------------------------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_CONTAINS_PATH(@base,'all','$.grapes','$.berries','$.num');
+----------------------------------------------------------------+
| JSON_CONTAINS_PATH(@base,'all','$.grapes','$.berries','$.num') |
+----------------------------------------------------------------+
|                                                              0 |
+----------------------------------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_CONTAINS_PATH(@base,'one','$.grapes','$.berries','$.num');
+----------------------------------------------------------------+
| JSON_CONTAINS_PATH(@base,'one','$.grapes','$.berries','$.num') |
+----------------------------------------------------------------+
|                                                              1 |
+----------------------------------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_CONTAINS_PATH(@base,'one','$.grapes');
+--------------------------------------------+
| JSON_CONTAINS_PATH(@base,'one','$.grapes') |
+--------------------------------------------+
|                                          1 |
+--------------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_CONTAINS_PATH(@base,'all','$.grape');
+-------------------------------------------+

| JSON_CONTAINS_PATH(@base,'all','$.grape') |
+-------------------------------------------+
|                                         0 |
+-------------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_CONTAINS_PATH(@base,'one','$.berries');
+---------------------------------------------+
| JSON_CONTAINS_PATH(@base,'one','$.berries') |
+---------------------------------------------+
|                                           1 |
+---------------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_CONTAINS_PATH(@base,'all','$.berries');
+---------------------------------------------+
| JSON_CONTAINS_PATH(@base,'all','$.berries') |
+---------------------------------------------+
|                                           1 |
+---------------------------------------------+
1 row in set (0.00 sec)
Listing 3-14Using the JSON_CONTAINS_PATH Function

```

花些时间浏览这些例子，这样你就能明白它们是如何工作的。注意，在前两个命令中，我使用了一个美元符号的路径表达式。这只是整个文档的路径表达式，所以它自然存在。还要注意最后两个例子中使用`one`或`all`的区别。

`JSON_EXTRACT()`功能是最常用的功能之一。它允许您使用一个或多个路径表达式从 JSON 文档中提取值、JSON 数组、JSON 对象等等。我们已经看到了几个例子。Recall 函数返回 JSON 文档中与路径表达式匹配的部分。清单 3-15 展示了更多使用复杂路径表达式的例子。

```sql
 MySQL  localhost:33060+ ssl  SQL > SET@base = '{"grapes":["red","white","green"],"berries":["strawberry","raspberry","boysenberry","blackberrry"],"numbers":["1","2","3","4","5"]}';
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_EXTRACT(@base,'$');
+-------------------------------------------------------------------------+
| JSON_EXTRACT(@base,'$')                                                            
+-------------------------------------------------------------------------+
| {"grapes": ["red", "white", "green"], "berries": ["strawberry", "raspberry", "boysenberry", "blackberry"], "numbers": ["1", "2", "3", "4", "5"]} |
+-------------------------------------------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_EXTRACT(@base,'$.grapes');
+--------------------------------+
| JSON_EXTRACT(@base,'$.grapes') |
+--------------------------------+
| ["red", "white", "green"]      |
+--------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_EXTRACT(@base,'$.grapes[*]');
+-----------------------------------+
| JSON_EXTRACT(@base,'$.grapes[*]') |
+-----------------------------------+
| ["red", "white", "green"]         |
+-----------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_EXTRACT(@base,'$.grapes[1]');
+-----------------------------------+
| JSON_EXTRACT(@base,'$.grapes[1]') |
+-----------------------------------+
| "white"                           |
+-----------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_EXTRACT(@base,'$.grapes[4]');
+-----------------------------------+
| JSON_EXTRACT(@base,'$.grapes[4]') |
+-----------------------------------+
| NULL                              |
+-----------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_EXTRACT(@base,'$.berries');
+-----------------------------------------------------------+
| JSON_EXTRACT(@base,'$.berries')                           |
+-----------------------------------------------------------+
| ["strawberry", "raspberry", "boysenberry", "blackberry"] |
+-----------------------------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_EXTRACT(@base,'$.berries[2]');
+------------------------------------+
| JSON_EXTRACT(@base,'$.berries[2]') |
+------------------------------------+
| "boysenberry"                      |
+------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_EXTRACT(@base,'$.berries[2]','$.berries[3]');
+---------------------------------------------------+
| JSON_EXTRACT(@base,'$.berries[2]','$.berries[3]') |
+---------------------------------------------------+
| ["boysenberry", "blackberry"]                    |
+---------------------------------------------------+
1 row in set (0.00 sec)
Listing 3-15Using the JSON_EXTRACT Function

```

注意当我们使用一元符号时会发生什么。该函数返回整个文档。此外，请注意当我们使用路径表达式时会发生什么，尽管它的语法是有效的，但它不会计算出文档中的元素(参见第五个命令)。

注意最后一个例子，我们传入了两个路径表达式。然后注意它如何返回一个 JSON 数组，而之前只有一个路径表达式的例子返回一个 JSON 字符串值。这是该函数的一个更棘手的方面。只要您记得它返回一个有效的 JSON 字符串、数组或对象，您就可以毫无问题地使用该函数。

`JSON_SEARCH()`函数很有趣，因为它与`JSON_EXTRACT()`函数相反。更具体地说，它接受一个或多个值，如果在文档中找到这些值，则返回这些值的路径表达式。这使得验证路径表达式或动态构建路径表达式变得更加容易。

与`JSON_CONTAINS_PATH()`函数一样，`JSON_SEARCH()`函数也允许您根据作为第二个参数传递的值来查找返回路径表达式的第一个或所有匹配项，如下所示:

*   如果通过`one`，函数将返回第一个匹配。
*   如果通过`all`，函数将返回所有匹配。

但是这里也有一个技巧。该函数接受第三个参数，该参数构成一个特殊的搜索字符串，在 SQL 语句中充当 LIKE 运算符。也就是说，搜索字符串参数可以像 LIKE 运算符一样使用%和 _ 字符。请注意，要将%或 _ 用作文字，必须在它前面加上\(转义)字符。

该函数返回 0 或 1，以指示 JSON 文档是否包含这些值。请注意，如果任何路径表达式或文档为 null，它可能会返回 null。如果 JSON 文档或任何路径表达式无效，或者第二个参数不是`one`或`all`，则会出现错误。清单 [3-16](#Par168) 显示了使用该功能的几个例子。

```sql
 MySQL  localhost:33060+ ssl  SQL > SET @base = '{"grapes":["red","white","green"],"berries":["strawberry","raspberry","boysenberry","blackberrry"],"numbers":["1","2","3","4","5"]}';
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_SEARCH(@base,'all','red');
+--------------------------------+
| JSON_SEARCH(@base,'all','red') |
+--------------------------------+
| "$.grapes[0]"                  |
+--------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_SEARCH(@base,'all','gr____');
+-----------------------------------+
| JSON_SEARCH(@base,'all','gr____') |
+-----------------------------------+
| NULL                              |
+-----------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_SEARCH(@base,'one','%berry');
+-----------------------------------+
| JSON_SEARCH(@base,'one','%berry') |
+-----------------------------------+
| "$.berries[0]"                    |
+-----------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_SEARCH(@base,'all','%berry');
+--------------------------------------------------+
| JSON_SEARCH(@base,'all','%berry')                |
+--------------------------------------------------+
| ["$.berries[0]", "$.berries[1]", "$.berries[2]"] |
+--------------------------------------------------+
1 row in set (0.00 sec)
Listing 3-16Using the JSON_SEARCH Function

```

现在我们来看最后一组 JSON 函数；这些工具本质上是实用的，允许您获得关于 JSON 文档的信息，并执行简单的操作来帮助处理 JSON 文档。

#### 效用函数

最后，有几个函数可以返回关于 JSON 文档的信息，帮助添加或删除引号，甚至查找文档中的键。我们已经看到了几个实用程序`JSON_TYPE()`和`JSON_VALID()`函数。以下是在使用 JSON 文档时可能会发现有用的其他实用函数。

`JSON_DEPTH()`函数返回 JSON 文档的最大深度。如果文档是空数组、对象或标量值，则为。该函数返回深度 1。仅包含深度为 1 的元素的数组或仅包含深度为 1 的成员值的非空对象返回深度为 2 的值。清单 [3-17](#Par172) 展示了几个例子。

```sql
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_DEPTH('8');
+-----------------+
| JSON_DEPTH('8') |
+-----------------+
|               1 |
+-----------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_DEPTH('[]');
+------------------+
| JSON_DEPTH('[]') |
+------------------+
|                1 |
+------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_DEPTH('{}');
+------------------+
| JSON_DEPTH('{}') |
+------------------+
|                1 |
+------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_DEPTH('[12,3,4,5,6]');
+----------------------------+
| JSON_DEPTH('[12,3,4,5,6]') |
+----------------------------+
|                          2 |
+----------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_DEPTH('[[], {}]');
+------------------------+
| JSON_DEPTH('[[], {}]') |
+------------------------+
|                      2 |
+------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SET @base = '{"grapes":["red","white","green"],"berries":["strawberry","raspberry","boysenberry","blackberrry"],"numbers":["1","2","3","4","5"]}';
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_DEPTH(@base);
+-------------------+
| JSON_DEPTH(@base) |
+-------------------+
|                 3 |
+-------------------+
1 row in set (0.00 sec) 

 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_DEPTH(JSON_EXTRACT(@base, '$.grapes'));
+---------------------------------------------+
| JSON_DEPTH(JSON_EXTRACT(@base, '$.grapes')) |
+---------------------------------------------+
|                                           2 |
+---------------------------------------------+
1 row in set (0.00 sec)
Listing 3-17Using the JSON_DEPTH Function

```

`JSON_KEYS()`函数用于以 JSON 数组的形式从 JSON 对象的顶层值返回一个键列表。该函数还允许您传递路径表达式，这将产生所选路径表达式值的顶级键列表。如果 json_doc 参数不是有效的 json 文档，或者 path 参数不是有效的路径表达式，或者包含*或**通配符，则会出现错误。如果所选对象为空，则结果数组为空。

有一个限制。如果顶层值有嵌套的 JSON 对象，则返回的数组不包括这些嵌套对象的键。清单 [3-18](#Par175) 显示了使用该功能的几个例子。

```sql
 MySQL  localhost:33060+ ssl  SQL > SET @base = '{"grapes":["red","white","green"],"berries":["strawberry","raspberry","boysenberry","blackberrry"],"numbers":["1","2","3","4","5"]}';
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_KEYS(@base);
+----------------------------------+
| JSON_KEYS(@base)                 |
+----------------------------------+
| ["grapes", "berries", "numbers"] |
+----------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_KEYS(@base,'$');
+----------------------------------+
| JSON_KEYS(@base,'$')             |
+----------------------------------+
| ["grapes", "berries", "numbers"] |
+----------------------------------+
1 row in set (0.00 sec) 

 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_KEYS('{"z":123,"x":{"albedo":50}}');
+------------------------------------------+
| JSON_KEYS('{"z":123,"x":{"albedo":50}}') |
+------------------------------------------+
| ["x", "z"]                               |
+------------------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_KEYS('{"z":123,"x":{"albedo":50}}', '$.x');
+-------------------------------------------------+
| JSON_KEYS('{"z":123,"x":{"albedo":50}}', '$.x') |
+-------------------------------------------------+
| ["albedo"]                                      |
+-------------------------------------------------+
1 row in set (0.00 sec)
Listing 3-18Using the JSON_KEYS Function

```

`JSON_LENGTH()`函数返回传递的 JSON 文档的长度。它还允许您传入路径表达式，如果提供了路径表达式，将返回与路径表达式匹配的值的长度。如果 json_doc 参数不是有效的 json 文档，或者 path 参数不是有效的路径表达式，或者包含*或**通配符，则会出现错误。但是，返回值有几个约束，如下所示:

*   标量的长度为 1。
*   数组的长度等于数组元素的数量。
*   对象的长度等于对象成员的数量。

然而，有一个令人惊讶的限制:返回的长度不包括嵌套数组或对象的长度。因此，使用嵌套文档的路径表达式时，必须小心使用该函数。

清单 [3-19](#Par182) 显示了使用该函数的几个例子。

```sql
 MySQL  localhost:33060+ ssl  SQL > SET @base = '{"grapes":["red","white","green"],"berries":["strawberry","raspberry","boysenberry","blackberrry"],"numbers":["1","2","3","4","5"]}';
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_LENGTH(@base,'$');
+------------------------+
| JSON_LENGTH(@base,'$') |
+------------------------+
|                      3 |
+------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_LENGTH(@base,'$.grapes');
+-------------------------------+
| JSON_LENGTH(@base,'$.grapes') |
+-------------------------------+
|                             3 |
+-------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_LENGTH(@base,'$.grapes[1]');
+----------------------------------+
| JSON_LENGTH(@base,'$.grapes[1]') |
+----------------------------------+
|                                1 |
+----------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_LENGTH(@base,'$.grapes[4]');
+----------------------------------+
| JSON_LENGTH(@base,'$.grapes[4]') |
+----------------------------------+
|                             NULL |
+----------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_LENGTH(@base,'$.berries');
+--------------------------------+
| JSON_LENGTH(@base,'$.berries') |
+--------------------------------+
|                              4 |
+--------------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_LENGTH(@base,'$.numbers');
+--------------------------------+
| JSON_LENGTH(@base,'$.numbers') |
+--------------------------------+
|                              5 |
+--------------------------------+
1 row in set (0.00 sec)
Listing 3-19Using the JSON_LENGTH Function

```

注意，第四个命令返回 null，因为路径表达式虽然是有效的语法，但并不等于值或嵌套的 JSON 数组或对象。

`JSON_QUOTE()`函数是一个方便的函数，可以帮助你在适当的地方添加引号。也就是说，该函数通过用双引号字符将字符串括起来并转义内部引号和其他字符来将字符串作为 JSON 字符串引用，并返回结果。注意，这个函数并不对 JSON 文档进行操作，而是只对一个字符串进行操作。

您可以使用这个函数生成一个有效的 JSON 字符串文字，以包含在 JSON 文档中。清单 [3-20](#Par186) 展示了几个使用函数引用 JSON 字符串的简短例子。

```sql
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_QUOTE("test");
+--------------------+
| JSON_QUOTE("test") |
+--------------------+
| "test"             |
+--------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_QUOTE('[true]');
+----------------------+
| JSON_QUOTE('[true]') |
+----------------------+
| "[true]"             |
+----------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_QUOTE('90125');
+---------------------+
| JSON_QUOTE('90125') |
+---------------------+
| "90125"             |
+---------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl SQL > SELECT JSON_QUOTE('["red","white","green"]');
+---------------------------------------+
| JSON_QUOTE('["red","white","green"]') |
+---------------------------------------+
| "[\"red\",\"white\",\"green\"]"       |
+---------------------------------------+
1 row in set (0.00 sec)
Listing 3-20Using the JSON_QUOTE Function

```

请注意，在最后一个示例中，函数添加了转义符(\)，因为传递的字符串包含引号。为什么会这样？记住，这个函数接受一个字符串，而不是一个 JSON 数组作为参数。

`JSON_UNQUOTE()`功能与`JSON_QUOTE()`功能相反。`JSON_UNQUOTE()`函数删除引号中的 JSON 值，并将结果作为 utf8mb4 字符串返回。该函数旨在识别但不改变标记序列，如下所示:

*   `\"`:双引号(")字符
*   `\b`:退格字符
*   `\f`:换页符
*   `\n`:换行符
*   `\r`:回车符
*   `\t`:制表符
*   `\\`:反斜杠(\)字符

清单 [3-21](#Par197) 显示了使用该函数的例子。

```sql
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_UNQUOTE("test 123");
+--------------------------+
| JSON_UNQUOTE("test 123") |
+--------------------------+
| test 123                 |
+--------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_UNQUOTE('"true"');
+------------------------+
| JSON_UNQUOTE('"true"') |
+------------------------+
| true                   |
+------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_UNQUOTE('\"true\"');
+--------------------------+
| JSON_UNQUOTE('\"true\"') |
+--------------------------+
| true                     |
+--------------------------+
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_UNQUOTE('9\t0\t125\\');
+-----------------------------+
| JSON_UNQUOTE('9\t0\t125\\') |
+-----------------------------+
| 9 0 125\                    |
+-----------------------------+
1 row in set (0.00 sec) 

Listing 3-21Using the JSON_UNQUOTE Function

```

JSON_PRETTY()函数格式化 JSON 文档以便于查看。您可以用它来生成一个输出发送给用户，或者让 JSON 在 shell 中看起来更好一些。清单 [3-22](#Par199) 显示了一个没有函数的例子和一个有函数的例子。请注意，使用 JSON_PRETTY()时阅读起来要容易得多。

```sql
 MySQL  localhost:33060+ ssl  SQL > SET @base = '{"name": {"last": "Throckmutton", "first": "Billy-bob"}, "address": {"zip": "90125", "city": "Melborne", "state": "California", "street": "4 Main Street"}}';
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT @base \G
*************************** 1\. row ***************************
@base: {"name": {"last": "Throckmutton", "first": "Billy-bob"}, "address": {"zip": "90125", "city": "Melborne", "state": "California", "street": "4 Main Street"}}
1 row in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT JSON_PRETTY(@base) \G
*************************** 1\. row ***************************
JSON_PRETTY(@base): {
  "name": {
    "last": "Throckmutton",
    "first": "Billy-bob"
  },
  "address": {
    "zip": "90125",
    "city": "Melborne",
    "state": "California",
    "street": "4 Main Street"
  }
}
1 row in set (0.00 sec)
Listing 3-22Using the JSON_PRETTY Function

```

还有检查尺寸的功能；`JSON_STORAGE_FREE()`和`JSON_STORAGE_SIZE()`。第一个在部分更新后使用，第二个用于获取 JSON 文档的二进制表示的大小。有关这些函数的更多细节，请参见在线 MySQL 参考手册，因为它们是新的，除了在非常特殊的情况下需要考虑大小之外，并不常用。

最后，在 8.0.4 版本中发布了一个新函数，有趣的是它被命名为 JSON_TABLE()。这个函数获取一个 JSON 文档并返回一个表格数据列表。基本上，这个函数不是以 JSON 的形式返回输出，而是以结果集的形式返回行。因此，您可以在应用中需要更多传统行的地方使用这个函数。

这个函数有一些特殊的语法。它将 JSON 文档(数组)、表达式路径和列定义作为参数。后两者没有用逗号隔开(奇怪)。这种安排使得这个函数有点难以使用，但是一旦你看到一个工作示例，它就更容易理解了。所以，让我们开始吧。清单 [3-23](#Par203) 演示了如何使用该功能。

```sql
MySQL  localhost:33060+  SQL > set @phones = '[{"name":"Bill Smith","phone":"8013321033"},{"name":"Folley Finn","phone":"9991112222"},{"name":"Carrie Tonnesth","phone":"6498881212"}]';
Query OK, 0 rows affected (0.00 sec)

MySQL  localhost:33060+  SQL > SELECT * FROM JSON_TABLE(@phones, "$[*]" COLUMNS(name char(20) PATH '$.name', phone char(16) PATH '$.phone')) as phone_list;
 +-----------------+------------+
| name            | phone      |
+-----------------+------------+
| Bill Smith      | 8013321033 |
| Folley Finn     | 9991112222 |
| Carrie Tonnesth | 6498881212 |
+-----------------+------------+
3 rows in set (0.00 sec)

Listing 3-23Using the JSON_TABLE Function

```

注意，为了简单起见，我们使用了一个包含姓名和电话号码的 JSON 数组。该函数就像一个表一样使用，所以我们将它添加到一个`SELECT`语句的`FROM`子句中。参数是 JSON 文档，然后是路径和列定义。使用的表达式路径只是从数组中检索整个元素。如果您只想选择文档的一部分进行操作，可以在这里使用各种路径表达式。接下来是列定义，您应该对此很熟悉——就像表的列定义一样。不同之处在于我们在末尾添加了一个带有关键字`PATH`的路径表达式。这只是在 JSON 文档中定位值。

可以想象，您可以形成复杂的定义，深入到您想要的元素。这个函数的需求和用例可能会增加，因为它是最近才添加的，但是如果您需要将 JSON 文档转换成结果集，这个函数可以实现这些结果，尽管需要一些创造性和路径表达式。

有关`JSON_TABLE()`函数的更多信息，请参见在线 MySQL 参考手册中标题为“JSON 表函数”的部分。

Tip

有关 JSON 函数的更多信息，请参见在线 MySQL 参考手册。JSON 函数根据使用情况与其他函数一起列出。我建议在文档中搜索您想要了解更多信息的函数，或者使用名为“函数索引”的索引，该索引按字母顺序列出了所有函数。

现在我们对 JSON 有了更多的了解,“结合 SQL 和 JSON——索引 JSON 数据”一节提供了一些在 SQL 语句中使用 JSON 的高级主题。

## 结合 SQL 和 JSON——索引 JSON 数据

NoSQL 的一个定义是“不仅仅是 SQL ”,当您考虑可以将 JSON 文档用于关系数据时，这个名字适用于 MySQL。正如我们在描述 JSON 函数的例子中看到的，您可以向表中添加 JSON 列，并在字段中存储 JSON 数据。

但是，MySQL 不是将 JSON 文档存储为字符串，而是使用一种特殊的内部结构来存储 JSON 文档，这种结构允许 MySQL 从行数据中快速访问、查找和提取 JSON 文档元素。注意，这并不意味着 MySQL 可以索引 JSON 数据。事实上，JSON 数据列不能被索引。至少，不是直接的。在这一节中，我们将看到如何索引 JSON 数据，以帮助优化对包含 JSON 文档的行的数据元素的搜索。

What About Converting Text To Json?

如果您有一个在文本或 BLOB 字段中存储了半结构化数据的数据库，您可能想考虑将数据转换成 JSON 文档。我们在本章中看到的 JSON 函数是成功转换数据的关键，比如`JSON_ARRAY()`、`JSON_OBJECT()`和`JSON_VALID()`。我将在第 9 章中详细讨论这个话题，包括如何转换现有数据的建议和例子。您可能还想查看各种关于将数据转换成 JSON 的博客——只是类似于“转换成 JSON”的 google 短语尽管大多数博客都是基于 Java 的，但是您可以使用它们来获得如何转换您自己的数据的想法。

有些人可能认为禁止对 JSON 列进行索引的限制是一个疏忽，但事实并非如此。考虑这样一个事实，JSON 文档是半结构化数据，不需要符合任何特定的布局。也就是说，一行可能包含一个 JSON 文档，该文档不仅有不同的键，而且可能以不同的顺序排列文档。

尽管这不一定是索引的绊脚石，尽管使用了特殊的内部机制来访问文档中的数据，但是直接索引 JSON 文档会很麻烦，并且性能可能很差。然而，并没有失去一切。MySQL 5.7 引入了一个新特性，称为生成列(有时称为虚拟列)。

生成的列是由`CREATE`或`ALTER TABLE`语句定义的动态解析列。有两种类型的虚拟列:按需生成的列(称为虚拟生成列)，它们不使用任何额外的存储；以及可以存储在行中的那些生成的列。虚拟生成的列使用`VIRTUAL`选项，存储生成的列使用`CREATE`或`ALTER TABLE`语句中的`STORED`选项。

那么这是如何工作的呢？我们创建生成的列来从 JSON 文档中提取数据，然后使用该列来创建索引。因此，索引可用于更快地查找行。也就是说，如果您想要执行分组、排序，或者想要搜索基于 JSON 数据的行的子集，您可以为优化器创建索引，以便更快地检索数据。

让我们看一个例子。下面显示了我创建的用于在 JSON 列中存储信息的表。

```sql
CREATE TABLE `test`.`thermostats` (
  `model_number` char(20) NOT NULL,
  `manufacturer` char(30) DEFAULT NULL,
  `capabilities` json DEFAULT NULL,
  PRIMARY KEY (`model_number`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
INSERT INTO `test`.`thermostats` VALUES ('AB-90125-C1', 'Jasper', '{"rpm": 1500, "color": "beige", "modes": ["ac"], "voltage": 110, "capability": "auto fan"}');
INSERT INTO `test`.`thermostats` VALUES ('ODX-123','Genie','{"rpm": 3000, "color": "white", "modes": ["ac", "furnace"], "voltage": 220, "capability": "fan"}');

```

注意，这个表有一个 JSON 字段和一个型号字符字段，这也是主键。假设这些行包含 JSON 数据，如下所示。

```sql
 MySQL  localhost:33060+ ssl  SQL > SELECT * FROM `test`.`thermostats` LIMIT 2 \G
*************************** 1\. row ***************************
model_number: AB-90125-C1
manufacturer: Jasper
capabilities: {"rpm": 1500, "color": "beige", "modes": ["ac"], "voltage": 110, "capability": "auto fan"}
*************************** 2\. row ***************************
model_number: ODX-123
manufacturer: Genie
capabilities: {"rpm": 3000, "color": "white", "modes": ["ac", "furnace"], "voltage": 220, "capability": "fan"}
2 rows in set (0.00 sec)

```

现在假设我们想执行查询，通过 JSON 文档中的一个或多个数据元素来选择行。例如，假设我们希望运行查询来定位风扇以 110 伏运行的行。如果表包含几十万甚至几千万行，并且没有索引，那么优化器必须读取所有行(表扫描)。但是，如果数据上有索引，优化器只需要生成虚拟生成的列，这可能更有效。

为了减轻潜在的性能问题，我们可以使用 voltage 元素在表上添加一个虚拟生成的列。下面显示了我们可以用来添加虚拟生成列的`ALTER TABLE`语句。

```sql
ALTER TABLE `test`.`thermostats` ADD COLUMN voltage INT GENERATED ALWAYS AS (capabilities->'$.voltage') VIRTUAL;
ALTER TABLE `test`.`thermostats` ADD INDEX volts (voltage);

```

Note

如果不使用该选项，生成的列是虚拟生成的列。

如果需要，也可以重新创建表，但这需要重新加载数据。但是，我在下面展示了新的`CREATE TABLE`语句，这样您就可以看到如何在创建时在表上创建一个虚拟生成的列。

```sql
CREATE TABLE `test`.`thermostats` (
  `model_number` char(20) NOT NULL,
  `manufacturer` char(30) DEFAULT NULL,
  `capabilities` json DEFAULT NULL,
  `voltage` int(11) GENERATED ALWAYS AS (json_extract(`capabilities`,'$.voltage')) VIRTUAL,
  PRIMARY KEY (`model_number`),
  KEY `volts` (`voltage`)

) ENGINE=InnoDB DEFAULT CHARSET=latin1;

```

注意，我在`ALTER TABLE`语句中使用了快捷键`->`，但是`CREATE TABLE`语句使用了`JSON_EXTRACT()`函数。

如果您想知道添加虚拟生成的列和索引是否有所不同，清单 [3-24](#Par228) 展示了优化器在添加列之前和之后如何运行查询。

```sql
 MySQL  localhost:33060+ ssl  SQL > DROP TABLE IF EXISTS `test`.`thermostats`;
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > CREATE TABLE `test`.`thermostats` (`model_number` char(20) NOT NULL,`manufacturer` char(30) DEFAULT NULL,`capabilities` json DEFAULT NULL,PRIMARY KEY (`model_number`)) ENGINE=InnoDB DEFAULT CHARSET=latin1;
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > INSERT INTO `test`.`thermostats` VALUES ('ODX-123','Genie','{"rpm": 3000, "color": "white", "modes": ["ac", "furnace"], "voltage": 220, "capability": "fan"}');
Query OK, 1 row affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > INSERT INTO `test`.`thermostats` VALUES ('AB-90125-C1', 'Jasper', '{"rpm": 1500, "color": "beige", "modes": ["ac"], "voltage": 110, "capability": "auto fan"}');
Query OK, 1 row affected (0.00 sec)

# Query without virtual generated

column

.

 MySQL  localhost:33060+ ssl  SQL > EXPLAIN SELECT * FROM thermostats WHERE capabilities->'$.voltage' = 110 \G
*************************** 1\. row ***************************
           id: 1
  select_type: SIMPLE
        table: thermostats
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 23302
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
Note (code 1003): /* select#1 */ select `test`.`thermostats`.`model_number` AS `model_number`,`test`.`thermostats`.`manufacturer` AS `manufacturer`,`test`.`thermostats`.`capabilities` AS `capabilities` from `test`.`thermostats` where (json_extract(`test`.`thermostats`.`capabilities`,'$.voltage') = 110)
 MySQL  localhost:33060+ ssl  SQL > ALTER TABLE `test`.`thermostats` ADD COLUMN color char(20) GENERATED ALWAYS AS (capabilities->'$.color') VIRTUAL;
Query OK, 0 rows affected (0.00 sec)

# Query with virtual generated column.

 MySQL  localhost:33060+ ssl  SQL > DROP TABLE `test`.`thermostats`;
Query OK, 0 rows affected (0.00 sec)

 MySQL  localhost:33060+ ssl  SQL > CREATE TABLE `thermostats` (`model_number` char(20) NOT NULL, `manufacturer` char(30) DEFAULT NULL, `capabilities` json DEFAULT NULL, `voltage` int(11) GENERATED ALWAYS AS (json_extract(`capabilities`,'$.voltage')) VIRTUAL, PRIMARY KEY (`model_number`), KEY `volts` (`voltage`)) ENGINE=InnoDB DEFAULT CHARSET=latin1;
Query OK, 0 rows affected (0.00 sec)

 MySQL  localhost:33060+ ssl  SQL > EXPLAIN SELECT * FROM thermostats WHERE capabilities->'$.voltage' = 110 \G
*************************** 1\. row ***************************
           id: 1
  select_type: SIMPLE
        table: thermostats
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1102
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
Note (code 1003): /* select#1 */ select `test`.`thermostats`.`model_number` AS `model_number`,`test`.`thermostats`.`manufacturer` AS `manufacturer`,`test`.`thermostats`.`capabilities` AS `capabilities`,`test`.`thermostats`.`color` AS `color` from `test`.`thermostats` where (json_extract(`test`.`thermostats`.`capabilities`,'$.voltage') = 110)

Listing 3-24Optimizer EXPLAIN Results for Query

```

注意，第一个`EXPLAIN`显示没有使用索引(no `key`，`key_len`)，而第二个显示使用了索引。rows 结果显示了将读取多少行(估计)来进行比较。很明显，添加生成的列和索引可以帮助我们优化关系表中 JSON 数据的查询。酷毙了。

然而，有一件事这个例子没有涉及到。如果 JSON 数据元素是一个字符串，您必须使用`JSON_UNQUOTE()`函数从字符串中删除引号。假设我们想要为颜色数据元素添加一个生成的列。如果我们添加带有`ALTER TABLE`语句的列和索引，而不删除引号，我们将得到一些不寻常的结果，如清单 [3-25](#Par231) 所示。

```sql
 MySQL  localhost:33060+ ssl  SQL > DROP TABLE IF EXISTS `test`.`thermostats`;
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > CREATE TABLE `test`.`thermostats` (`model_number` char(20) NOT NULL,`manufacturer` char(30) DEFAULT NULL,`capabilities` json DEFAULT NULL,PRIMARY KEY (`model_number`)) ENGINE=InnoDB DEFAULT CHARSET=latin1;
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > INSERT INTO `test`.`thermostats` VALUES ('ODX-123','Genie','{"rpm": 3000, "color": "white", "modes": ["ac", "furnace"], "voltage": 220, "capability": "fan"}');
Query OK, 1 row affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > INSERT INTO `test`.`thermostats` VALUES ('AB-90125-C1', 'Jasper', '{"rpm": 1500, "color": "beige", "modes": ["ac"], "voltage": 110, "capability": "auto fan"}');
Query OK, 1 row affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > ALTER TABLE `test`.`thermostats` ADD COLUMN color char(20) GENERATED ALWAYS AS (capabilities->'$.color') VIRTUAL;
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT model_number, color FROM thermostats WHERE color = "beige";                          
Empty set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT model_number, color FROM thermostats LIMIT 2;                                                
+--------------+---------+
| model_number | color   |
+--------------+---------+
| AB-90125-C1  | "beige" |
| ODX-123      | "white" |
+--------------+---------+
2 rows in set (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > ALTER TABLE thermostats DROP COLUMN color;
Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > ALTER TABLE thermostats ADD COLUMN color char(20) GENERATED ALWAYS AS (JSON_UNQUOTE(capabilities->'$.color')) VIRTUAL; 

Query OK, 0 rows affected (0.00 sec)
 MySQL  localhost:33060+ ssl  SQL > SELECT model_number, color FROM thermostats WHERE color = 'beige' LIMIT 1;   
+--------------+-------+
| model_number | color |
+--------------+-------+
| AB-90125-C1  | beige |
+--------------+-------+
1 row in set (0.00 sec)
Listing 3-25Removing Quotes for Generated Columns on JSON Strings

```

注意，在第一个`SELECT`语句中，没有返回任何内容。这是因为虚拟生成的列使用了带引号的 JSON 字符串。当混合 SQL 和 JSON 数据时，这通常是混淆的来源。注意，在第二个`SELECT`语句中，我们看到应该有几行被返回。还要注意，在我删除该列并用`JSON_UNQUOTE()`函数再次添加它之后，`SELECT`返回正确的数据。

我们通常使用虚拟生成的列，这样我们就不会在行中存储任何额外的东西。这部分是因为我们可能不经常使用 JSON 数据上的索引，可能不需要维护它，但更重要的是因为对如何使用/定义存储的生成列有限制。下面总结了这些限制。

*   该表必须定义一个主键。
*   您必须使用全文索引或 RTREE 索引(而不是默认的 BTREE)。

但是，如果您有很多行，或者经常使用 JSON 数据上的索引，或者 JSON 数据上有多个索引，那么您可能希望考虑使用存储生成的列，因为在频繁访问复杂或深度嵌套的数据时，虚拟生成的列可能会计算量很大。

Tip

有关虚拟列的更多信息，请参见在线 MySQL 参考手册( [`https://dev.mysql.com/doc/refman/8.0/en/`](https://dev.mysql.com/doc/refman/8.0/en/) )中的“创建表和生成的列”或“更改表和生成的列”一节。

## 摘要

MySQL 增加了 JSON 数据类型，这为我们如何使用 MySQL 带来了一个范式转变。第一次，我们可以在关系数据(表)中存储半结构化数据。这不仅为我们提供了前所未有的灵活性，还意味着我们可以利用现代编程技术来访问我们应用中的数据，而无需付出巨大努力和增加复杂性。JSON 是一种众所周知的格式，在许多应用中广泛使用。

理解 JSON 数据类型是理解文档存储的关键。这是因为 JSON 数据类型虽然是为处理关系数据而设计的，但却形成了我们在文档存储中存储数据的模式——在 JSON 文档中！我们将在后面的章节中看到更多关于文档存储的内容。

在本章中，我们更详细地探讨了 JSON 数据类型。我们看到了如何通过 MySQL 中提供的大量内置 JSON 函数来处理关系表中的 JSON 数据的例子。JSON 数据类型是允许用户开发跨越 SQL 和 NoSQL 应用的混合解决方案的关键。

在第 4 章中，我将更详细地探索 MySQL Shell，包括介绍如何使用 MySQL Shell 开发您的应用。

Footnotes [1](#Fn1_source)

旧的 MySQL 客户端可以使用- xml 命令行选项来完成这项工作。

  [2](#Fn2_source)

参见 [`https://www.w3.org/RDF/Metalog/docs/sw-easy`](https://www.w3.org/RDF/Metalog/docs/sw-easy) `.`

  [3](#Fn3_source)

但这当然会有帮助。