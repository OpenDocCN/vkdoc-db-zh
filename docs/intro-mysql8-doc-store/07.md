# 七、X 协议

X 协议代表了 MySQL 中第一个与现有的客户机/服务器协议的重大偏离。X 协议被设计成可扩展的，最大化安全性，并确保良好的性能。当 X 协议被设计时，这三个类别都是必须具备的特性和需求的首要条件。

尽管 X 协议主要被包装(实现它)的客户端(如 X 插件和数据库连接器)隐藏在一个抽象层之后，但如果您计划使用 X 协议实现自己的应用，了解它的工作方式是很重要的。我们将在第 8 章[和第 9 章](08.html)[中介绍。即使您从未打算开发 MySQL 客户端，仔细研究 X 协议也会发现并进一步强调 MySQL 8 中技术飞跃的一个例子。](09.html)

在这一章中，我们将探索 X 协议并发现它是如何工作的。我们还将了解如何通过数据库连接器开始使用 X 协议。我们看到了一些通过连接器/Python 库用 Python 编写小脚本与 X 协议交互的例子。让我们从 X 协议及其起源的详细概述开始。

Note

我提出了许多我们在前面章节中发现的概念，为了简洁起见，我只在需要清楚的地方重复了一些信息。

## 概观

如果您曾经编写过从头开始设计的通信协议，或者如果您不得不编写代码来实现通信协议，那么您会意识到以毫不动摇的精度处理数据交换的复杂性和严格要求。当从一个系统到另一个系统交换消息时，根本没有“足够好”的质量。发送到另一个系统或从另一个系统接收的数据必须按照约定的格式进行安排，包括数据对齐(先进行什么)和数据表示方式(编码)。如果做得不好，可能会导致灾难。

较老的客户机/服务器 MySQL 协议是从头开始设计的通信协议的一个很好的例子。虽然它已经使用了几十年，只有相对较小的变化，但有一段时间它限制了 MySQL 工程师。由于旧的客户机/服务器协议不可扩展，他们在尝试实现新功能时反复挣扎。

然而，在协议的发展过程中，添加新功能并不是唯一需要处理的问题。对于 MySQL 中的客户机/服务器协议，安全性是一个主要问题。尽管 SSL 扩展被添加到协议中，但默认情况下并不强制实施安全性。也就是说，除了登录密码的交换之外，客户端/服务器消息不需要加密。因此，如果没有启用 SSL 或其他形式的加密，有人就有可能发现发送到服务器或从服务器接收的数据。

性能是为特定的、有限的命令和消息集设计的现有协议可能受到影响的另一个方面。也就是说，更新的技术已经表明，如果使用类似流水线的技术来设计协议交换，则有可能实现更好的性能。

将这些特性添加到现有的客户机/服务器协议中是不可行的。更具体地说，工程师们知道，要扩展客户机/服务器协议，每个系统(客户机、应用、服务器等)。)必须被更新或修改以与新的扩展一起工作。这很严重，因为你不能指望 MySQL 的每个用户都突然更新他们的 MySQL 工具、定制应用、脚本等的每个版本，以符合协议的新扩展。由于这个原因和许多类似的原因，在过去，改变客户机/服务器协议是被禁止的，并且仅限于那些确保现有客户机尽管改变也能继续工作的改变。

尽管有这样的要求，在客户机/服务器协议的发展过程中还是有一些小的变化。最近一次发生在 5.7 版本开发发行期间，涉及 Ok 消息的返回。但即使是这种微小的变化也是为了确保向后兼容性。迄今为止，客户机/服务器协议继续支持 Ok 前和 Ok 后的消息协议更改。这是长期通信协议的祸根:总是不得不以牺牲进步为代价来保持某种程度的向后兼容性。

当工程师们开始设计 MySQL 中现在的文档存储库，包括新的 MySQL Shell、X Plugin 和 X DevAPI 时，很明显是时候实现一个可以增强新特性的新协议了。更具体地说，很明显，现有的客户机/服务器协议不足以满足 MySQL 8 特性和产品的所有目标。因此，我们需要一个新的协议，它被称为 X 协议，以遵循新的命名约定。 [<sup>1</sup>](#Fn1)

X 协议已经集成到大多数 MySQL 产品套件中，包括以下产品。我提供了一个链接，可以下载列出的每一个产品。注意，这里包含了几个数据库连接器(使用客户机/服务器协议或 X 协议与 MySQL 服务器交互的特定语言的库)。未来寻找更多实现 X 协议的产品。

*   x 插件:集成在 MySQL 服务器中( [https:// `dev.mysql.com/downloads/mysql/`](https://dev.mysql.com/downloads/mysql/) )
*   shell:8 . 0 . 4 或更高版本( [`https://dev.mysql.com/downloads/shell/`](https://dev.mysql.com/downloads/shell/) )
*   连接器/J:8 . 0 . 8 及以后版本( [`https://dev.mysql.com/downloads/connector/j/`](https://dev.mysql.com/downloads/connector/j/) )
*   连接器/网络:8.0.8 及以后版本`(` [`https://dev.mysql.com/downloads/connector/net/`](https://dev.mysql.com/downloads/connector/net/) )
*   connector/node . js:8 . 0 . 8 及更高版本( [`https://dev.mysql.com/downloads/connector/nodejs/`](https://dev.mysql.com/downloads/connector/nodejs/) )
*   连接器/Python:8 . 0 . 5 及更高版本( [`https://dev.mysql.com/downloads/connector/python/`](https://dev.mysql.com/downloads/connector/python/) )

Note

连接器产品通常缩写为 C/J、C/Net、C/Node.js 和 C/Py。

在后面的章节中，我们将会看到一个连接器/Python 连接器如何实现和公开 X 协议的例子。现在让我们看看开发和实现 X 协议的目标和动机。

### X 协议的目标

如上所述，X 协议旨在解决的三个主要领域(称为设计约束或简称目标)包括可扩展性、安全性和性能。接下来的几个部分展示了 X 协议的三个主要设计约束的一些驱动力。

Tip

如果你想看一些用于设计 X 协议的实际工程文档，请看 [`http://dev.mysql.com/worklog/task/?id=8639`](http://dev.mysql.com/worklog/task/?id=8639) 项目的工作日志 [<sup>2</sup>](#Fn2) 。

What About the Client/Server Protocol?

你可能想知道 X 协议是否只适用于所有的 X。也就是说，它不适用于旧的协议。答案是 X 协议也支持客户机/服务器协议。这就是 MySQL Shell 不需要使用中间库就可以连接到旧服务器的方式。更具体地说，X 协议包括一个使用旧的客户机/服务器协议进行通信的选项。

#### 展开性

当软件被称为具有可扩展性的目标时，它意味着软件必须能够被修改以添加新的特性，而不需要大的返工或重组。尽管组织可能对返工的含义有稍微不同的定义或示例，但在客户端/服务器协议的情况下，它是不可扩展的，因为在不对代码进行重大更改的情况下，扩展协议以包括新消息、命令和数据的空间非常小，并且可能与旧产品不兼容。

工程师们希望确保新协议从一开始就考虑到可扩展性。在这种情况下，可扩展性包括添加功能和特性的能力，而不会导致现有产品失败或返工以适应变化。

X 协议需要可扩展性的一些领域包括能够添加新的消息、添加新的特性(例如，确保协议支持诸如流水线之类的东西以减少往返行程)、允许添加新的认证机制、改变或添加新的加密和压缩设施等等。

#### 安全性

在这个物联网的现代世界中，随着现代文明人口的快速增长，系统越来越安全变得越来越重要。也就是说，提供最佳选项来保护数据和用户免受意外或故意的利用。

Tip

有关物联网和 MySQL 的更多信息，请参见我的书《物联网的 MySQL》，查尔斯·贝尔(Apress 2016) [`https://www.apress.com/us/book/9781484212943`](https://www.apress.com/us/book/9781484212943) 。

甲骨文的工程师非常重视安全性。事实上，它是几乎所有设计、评审和质量控制机制的关键方面。在甲骨文公司，安全性至关重要。因此，当开发新协议时，安全机制比客户机/服务器协议有了很大的改进。特别地，X 协议中的安全缺省仅使用可信的、经过验证的标准，例如传输层安全(TLS) [<sup>3</sup>](#Fn3) 和简单认证和安全层(SASL)。 [<sup>4</sup>](#Fn4)

#### 表演

与安全性一样，性能是 Oracle 用来评估产品质量的另一个关键领域。在这种情况下，性能必须使系统能够适当地执行其任务，而没有不必要的等待时间、延迟或长时间运行的任务。与安全性不同，性能通常是以主观和轶事的方式进行评估的。也就是说，新版本的运行速度不能慢于以前的版本。

在 X 协议的情况下，通过使用可靠的基础技术和利用诸如流水线之类的特性来确保性能目标，流水线允许一次传递多个消息，减少往返次数(往返于服务器和客户端)，并且在发送多个命令时不等待来自服务器的响应，从而不占用客户端来等待响应。

在下一节中，我们将通过研究设计的基础来了解 X 协议的基础。

### x 协议和协议缓冲区

MySQL 工程师想要克服的最大问题之一是从头开始开发协议机制的各个方面需要很长的时间。特别是，工程师们希望利用成熟的、记录良好的、卓越的技术。毕竟，创建一个可扩展的、安全的、高性能的通信协议的问题已经被许多人解决了，并取得了不同程度的成功。

虽然对几种选择进行了评估和讨论，但重要的是该技术必须是成熟的和开源的。此外，该技术必须支持快速实施，很少或没有第三方依赖性，独立于语言和平台，[](#Fn5)并且不需要重新装备开发工具和流程来使用它。

被选中的技术叫做谷歌的协议缓冲区( [`https://developers.google.com/protocol-buffers/`](https://developers.google.com/protocol-buffers/) )。Google Protocol Buffers 被亲切地命名为 protobuf，它是一个可扩展的、独立于语言和平台的机制，用于序列化结构化数据。它是为速度、紧凑和简单而设计的。Protobuf 允许您快速轻松地定义消息交换协议。在这方面，protobuf 与 XML 和其他变体有点类似。Protobuf 可用于多种语言，包括 C++、C#、Go、Java 和 Python。最新版本的 protobuf(版本 3)支持其他语言，比如 Ruby。

然而，这种意义上的语言支持意味着有一个编译器选项可以将 protobuf 定义文件翻译成该语言可以使用的特定于语言的代码。例如，要在 C++中使用 protobuf，您必须将 protobuf 定义文件从它们的本机 protobuf 定义编译成可由 C++编译器读取和编译的文件。

Protobuf 本质上是一种组织数据的方法，这样就可以用结构化的方式定义数据(称为消息)。也就是说，我们可以定义如何表示数据的精确集合。这允许你以约定的结构发送和接收数据。这听起来可能没什么大不了的，除非考虑到可扩展性方面，即使有消息的新版本，旧消息仍然有效。大多数语言都支持结构化数据机制，但具有不同程度的类型严格性。然而，这些很少是可扩展的，对结构的任何改变都会导致格式不兼容(大多数情况下)。Protobuf 旨在允许您扩展数据组织，而无需重新构建。

为了理解 protobuf 的强大，我们来看一个简短的例子。在这种情况下，我们将使用前面章节中联系人的 rolodex 示例的变体。我们需要两条消息(数据结构)；存储联系人姓名和电话号码的方法(每个联系人可能不止一个)，以及存储所有联系人的消息。正如您将看到的，这允许我们编写一些非常简单的代码来读写数据。

Note

虽然完整的 protobuf 教程已经超出了本书的范围，但是下面还是会给你一个 protobuf 的鸟瞰图。然而，如果您需要了解更多关于 protobuf 的信息，Google 已经提供了大量的文档。

#### 安装 Protobuf 编译器

我们需要安装两件东西。我们必须安装 protobuf 编译器和 protobuf 库。

可以从 [`https://github.com/google/protobuf/releases/tag/v3.0.0`](https://github.com/google/protobuf/releases/tag/v3.0.0) 下载 protobuf 编译器。向下滚动到页面底部，下载与您的平台匹配的文件。大多数都是压缩文件的形式，你可以下载和解压缩。对于大多数平台，不需要安装。您可以从下载的 bin 文件夹中运行 protobuf 编译器(名为`protoc`)。例如，我为 macOS 下载了名为`protoc-3.0.2-osx-x86_64.zip`的文件，因此可以作为`./protoc-3.0.2-osx-x86_64/bin/protoc`运行 protobuf 编译器。或者，你可以在你的路径中放置`protoc`的位置。

有几种方法可以安装 protobuf 库。有关如何安装 protobuf 的说明，请参见 [`https://github.com/google/protobuf/#protobuf-runtime-installation`](https://github.com/google/protobuf/#protobuf-runtime-installation) 中针对您的语言的运行时安装说明。对于 Linux 和 macOS 平台，可以使用 PyPi (pip)安装 protobuf 库，如下所示。请注意，如果您使用提升的权限(例如 sudo)安装 pip，您可能需要指定 sudo 来安装 protobuf。

```sql
$ pip install protobuf
Collecting protobuf
  Downloading protobuf-3.5.1-py2.py3-none-any.whl (388kB)
    100% |█████████████████████| 389kB 1.0MB/s
Requirement already satisfied: setuptools in /System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python (from protobuf)
Requirement already satisfied: six>=1.9 in /Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/six-1.10.0-py2.7.egg (from protobuf)
Installing collected packages: protobuf
Successfully installed protobuf-3.5.1

```

Note

您还必须在系统上安装 Python。请参见 [`https://www.python.org/`](https://www.python.org/) 在您的系统上下载并安装 Python。本章中的示例脚本是为 Python 版编写的，并可在 Python 版中正确执行。如果您使用的是 Python 3.0 或更高版本，您可能需要对代码进行微小的更改。

#### Protobuf 示例

让我们先来看看 protobuf 定义文件。Protobuf 文件以扩展名`.proto`命名。我们将把我们的 protobuf 定义文件命名为`contacts.proto`。清单 [7-1](#Par53) 显示了 protobuf 文件`contacts.proto`的内容。将这个文件放在一个文件夹中，因为我们将添加额外的文件来编译和测试 protobuf 定义。这是您将在其他文档中看到的标准示例模式——一个数据项定义后跟一个包含数据项的数组(或列表)。

```sql
syntax = "proto2";

message Contact {
  required string first = 1;
  required int32 id = 2;
  optional string last = 3;

  message PhoneNumber {
    required string number = 1;
  }

  repeated PhoneNumber phones = 5;
}

message Contacts {
  repeated Contact list = 1;
}

Listing 7-1Contacts Protobuf Definition

```

这里我们看到的代码看起来很像 C++。这不是偶然的，之所以选择它是因为几种语言使用相似的语法，这让大多数开发者都很熟悉。我们看到的第一行是 protobuf 编译器使用该语言版本 2(版本 3 是当前版本)的指令。MySQL 也使用版本 2。

在名为`Contact`的第一条消息中，我们定义了两个必填字段，一个 id 和一个名字。`Id`是一个整数，`first`名是一个字符串。我们还可以为`last`名称定义一个可选字段。在该消息中还有另一条名为`PhoneNumber`的消息，它存储了电话`number`的必填字段。但是，因为这是一条消息，所以我们添加了另一个名为`phones`的字段来存储 0 个或多个电话号码。也就是说，重复声明表明它可以包含 0 个或多个消息。注意每个数据项的`= N`。这是一个必需的标签，必须是唯一的。大多数人只是用一个从 1 开始的数字。最后，我们看到一个名为`Contacts`的消息，我们存储了 0 个或多个名为`list`的联系人。

要使用新的 protobuf 定义，我们必须编译它。对于这个例子，我将编译它以用于 Python。要使用的命令如下。这会生成一个名为`contacts_pb2.py`的文件，我们可以在 Python 脚本中导入它。我们用选项`--python_out`告诉编译器两件事:1)我们要为 Python 编译；以及 2)我们希望编译器的输出出现在当前文件夹(。).您将看不到该命令的任何附加输出—它都被写入文件。确保您的路径上有协议可执行文件的位置，或者使用如下所示的位置(路径)直接调用它。

```sql
$ protoc-3.0.2-osx-x86_64/bin/protoc --python_out=. contacts.proto

```

回想一下，protobuf 支持几种语言。下面列出了编译时支持的语言和使用的正确选项(`<out dir>`是结果源文件的输出目录)。如您所见，有几个选项涵盖了当今使用的大多数编程语言。如果要用另一种编程语言实现此示例，请使用下面显示的适用于您的编程语言的选项。

*   C++: `--cpp_out=<out_dir>`
*   C# `--csharp_out=<out_dir>`
*   Java: `--java_out=<out_dir>`
*   Java Nano `--javanano_out=<out_dir>`
*   JavaScript: `--js_out=<out_dir>`
*   目标 C: `--objc_out=<out_dir>`
*   Python: `--python_out=<out_dir>`
*   露比:`--ruby_out=<out_dir>`

contacts_pb2.py 文件的内容不是很有趣。其实挺复杂的。更有趣的是我们如何使用新协议。因为这是用于存储联系人的数据结构，所以让我们编写一个脚本，使用新消息将几个联系人写入一个文件。清单 [7-2](#Par68) 显示了一个简单的 Python 脚本，用于将两个联系人写入一个二进制文件。为什么是二进制？因为 protobuf 的设计允许我们在保留类型化(二进制)数据的同时快速轻松地序列化数据。和书中前面的例子一样，如果你不了解 Python，也不用太担心。这是一种非常简单的脚本语言(详见本章后面的边栏)。

```sql
import contacts_pb2

# Open the file
f = open("my_contacts", "wb")

# Create a contacts class instance

contacts = contacts_pb2.Contacts()

# Create a new contact message

new_contact = contacts.list.add()

new_contact.id = 90125
new_contact.first = "Andrew"

# Add phone numbers

phone_number = new_contact.phones.add()

phone_number.number = '212-555-1212'

phone_number = new_contact.phones.add()

phone_number.number = '212-555-1213'

# Create a new contact message

new_contact = contacts.list.add()

new_contact.id = 90126
new_contact.first = "William"
new_contact.last = "Edwards"

# Add phone numbers

phone_number = new_contact.phones.add()

phone_number.number = '301-555-1111'

phone_number = new_contact.phones.add()

phone_number.number = '301-555-3333'

# Write the data

f.write(contacts.SerializeToString())

# Close the file
f.close()

Listing 7-2Writing Contacts to a File (Protobuf Example)

```

我在这里使用了内联编码风格，而不是循环，向您展示了如何使用 protobuf 中的`add()`方法添加新消息。但是，首先要注意，我们必须导入用 protobuf 编译器(`contacts_pbs2`)创建的文件。然后我们为 protobuf 编译器生成的`Contacts`类创建一个实例。回想一下，这是一个类型为`Contact`的数组(列表)。当调用`add()`方法时，我们得到一个`Contact`结构的实例，我们可以使用字段名给它赋值。因此，我设置了 id、名字，然后通过引用名为`phones`的嵌套消息创建一个新的电话号码结构并填充它来添加电话号码。请注意，每次想要添加新消息时，都必须调用`add()`。最后，我使用`SerializeToString()`方法序列化我在内存中构建的所有消息，并将其写入名为`my_contacts`的文件。花一些时间通读代码，直到你理解它是如何工作的。

Tip

不要太担心次要的细节或改进代码的方法。我包含了示例代码来演示 protobuf，而不是使用 Python 来演示。我们将在后面的章节中看到更多关于 Python 的内容。

如果您想运行代码，创建一个名为`write_contacts.py`的文件，输入代码，保存它，然后用下面的命令执行它。这里您也看不到任何输出，因为它创建了文件`my_contacts`。

```sql
$ python ./write_contacts.py

```

如果您想知道这些数据在文件中是什么样子，下面显示了文件 my_contacts 的十六进制转储。注意，它确实是一个二进制文件。

```sql
$ hexdump -C my_contacts
00000000  0a 2c 0a 06 41 6e 64 72 65 77 10 8d c0 05 2a 0e |.,..Andrew....*.|
00000010  0a 0c 32 31 32 2d 35 35 35 2d 31 32 31 32 2a 0e |..212-555-1212*.|
00000020  0a 0c 32 31 32 2d 35 35 35 2d 31 32 31 33 0a 36 |..212-555-1213.6|
00000030  0a 07 57 69 6c 6c 69 61 6d 10 8e c0 05 1a 07 45 |..William......E|
00000040  64 77 61 72 64 73 2a 0e 0a 0c 33 30 31 2d 35 35 |dwards*...301-55|
00000050  35 2d 31 31 31 31 2a 0e 0a 0c 33 30 31 2d 35 35 |5-1111*...301-55|
00000060  35 2d 33 33 33 33                               |5-3333|

00000066

```

现在，让我们看看如何从文件中读取联系人。这段代码要短得多，也更容易阅读。我们再次导入`contacts_pb2`文件，然后打开该文件进行读取。然而，在本例中，我们创建了 Contacts 类的一个新实例，然后使用`ParseFromString()`方法从文件中读取。这将在内存中创建联系人列表，然后我们可以遍历并打印数据。下面显示了读取联系人列表的完整代码。

```sql
import contacts_pb2

contacts = contacts_pb2.Contacts()

# Read the existing contacts.
with open("my_contacts", "rb") as f:
    contacts.ParseFromString(f.read())

# Print out the contacts
for contact in contacts.list:
    print contact
f.close()

```

与 write 示例中一样，我们可以执行这段代码，但在本例中，我们将看到联系人列表被打印出来。清单 [7-3](#Par78) 显示了输出。请注意，我们看到一个类似 C++(和 JSON 有点像)的格式良好的输出。

```sql
$ python ./read_contacts.py
first: "Andrew"
id: 90125
phones {
  number: "212-555-1212"
}
phones {
  number: "212-555-1213"
}

first: "William"
id: 90126
last: "Edwards"
phones {
  number: "301-555-1111"
}
phones {
  number: "301-555-3333"
}

Listing 7-3Reading the Contact List (protobuf example)

```

当然，您可以编写代码来使用点语法访问单个字段。例如，您可以用下面的示例代码只打印出名字和姓氏。

```sql
# Print out the contacts
for contact in contacts.list:
    print contact.first, contact.last,
    for phone in contact.phones:
        print phone.number,
    print

```

当您执行这个文件时，您会看到如下所示的输出。

```sql
$ python ./read_contacts.py
Andrew  212-555-1212 212-555-1213
William Edwards 301-555-1111 301-555-3333

```

正如您所看到的，使用 protobuf 使读写结构化数据变得更加容易，并且比我们自己编写结构要简单得多。如果这个例子很有意思，我鼓励你去尝试一下，并随心所欲地修饰它。如果您想了解更多关于 protobuf 的信息，包括如何开始构建您自己的消息和协议，请参阅位于 [`https://developers.google.com/protocol-buffers/docs/overview`](https://developers.google.com/protocol-buffers/docs/overview) 的在线文档。

那么，MySQL protobuf 称为 X 协议是什么呢？不应该被命名为“MySQL 协议缓冲区”吗？Recall protobuf 是一种可以用来设计协议的技术。因此，X 协议是使用 protobuf 定义组成新协议的消息、命令等的产物。因此，X 协议是使用 protobuf 语言的通信协议的定义。酷吧。

既然我们对 X 协议有了更多的了解，知道了它是如何(以及为什么)被设计的，那么让我们更仔细地看看它在代码和 protobuf 级别是如何工作的。

## x 协议:引擎盖下

虽然开发者不太可能需要编写直接与 X 协议接口的低级代码，但是浏览一下 X 协议是如何实现的还是很有帮助的。为了简洁起见，在开始详细研究一个数据库连接器如何实现 X 协议之前，我们将只看 X 协议的一小部分。如果你是一个代码狂热者，你现在可以采取你最好的编码姿势。 [<sup>6</sup>](#Fn6)

让我们先来看看定义 MySQL X 协议的 protobuf 定义文件。

### Protobuf 实现

MySQL protobuf 定义文件可以在任何实现 X 协议的产品的源代码下载中找到。例如，您可以在 MySQL 服务器的源代码中的`rapid/plugin/x/protocol`文件夹中找到它们，该文件夹以前缀`mysqlx`和文件扩展名`.proto`命名。也可以在 [`https://github.com/mysql/mysql-server/blob/5.7/rapid/plugin/x/protocol`](https://github.com/mysql/mysql-server/blob/5.7/rapid/plugin/x/protocol) 从 GitHub 看到并下载 X 协议 protobuf 定义文件。

我展示 Github 存储库，而不是让您下载服务器代码，因为您可以使用 Github 存储库深入查看文件，而不必下载任何东西。只需使用之前的 URL 并点击 mysqlx.proto 文件链接。图 [7-1](#Fig1) 显示了在 Github 中查看文件的示例。

![A432285_1_En_7_Fig1_HTML.jpg](img/A432285_1_En_7_Fig1_HTML.jpg)

图 7-1

The mysqlx.proto file (Github)

但是，如果您喜欢下载服务器代码，您可以。只需访问 [`https://dev.mysql.com/downloads/mysql/`](https://dev.mysql.com/downloads/mysql/) ，在选择操作系统下拉列表中选择源代码条目，为您的平台选择一个文件，并下载它。一旦您解压缩了文件，您就可以在您自己的 PC 上探索服务器源代码。

这些是未编译的原始 protobuf 定义文件。表 [7-1](#Tab1) 列出了组成 X 协议的 protobuf 定义文件，包括文件名和简短描述。注意，文件名与 X DevAPI 中的主要概念相关联，显示了 protobuf 到 X 协议的清晰映射。

表 7-1

Protobuf Definition Files (X Protocol)

<colgroup><col align="left"> <col align="left"></colgroup> 
| 文件 | 描述 |
| :-- | :-- |
| `mysqlx.proto` | 定义客户端、服务器以及常规 Ok 和错误消息。这是导入所有其他文件的主文件。 |
| `mysqlx_connection.proto` | 定义用于在连接协商过程中确定服务器功能的消息(见下文) |
| `mysqlx_crud.proto` | 定义用于处理 CRUD 操作的消息 |
| `mysqlx_datatypes.proto` | 定义使用标量数据类型的消息 |
| `mysqlx_expect.proto` | 定义用于处理管道消息的消息 |
| `mysqlx_expr.proto` | 定义使用表达式的消息 |
| `mysqlx_notice.proto` | 定义用于发布通知(如会话和变量状态更改)的消息 |
| `mysqlx_resultset.proto` | 为包括行和列的结果集定义消息；这个文件是 X 协议的关键组件，展示了 protobuf 的强大功能。 |
| `mysqlx_sql.proto` | 定义用于执行语句的消息 |
| `mysqlx_session.proto` | 定义管理会话的消息 |

为了让您对文件包含的内容有所了解，清单 [7-4](#Par94) 显示了来自`mysqlx.proto`文件的错误消息。

```sql
...
// generic Error message
//
// A ``severity`` of ``ERROR`` indicates the current message sequence is
// aborted for the given error and the session is ready for more.
//
// In case of a ``FATAL`` error message the client should not expect
// the server to continue handling any further messages and should
// close the connection.
//
// :param severity: severity of the error message
// :param code: error-code
// :param sql_state: SQL state
// :param msg: human readable error message
message Error {
  optional Severity severity = 1 [ default = ERROR ];
  required uint32 code = 2;
  required string sql_state = 4;
  required string msg = 3;

  enum Severity {
    ERROR = 0;
    FATAL = 1;
  };
}
...

Listing 7-4Generic Error Message (mysqlx.proto)

```

请注意，该消息定义得非常好，包含了您在查看客户机/服务器协议时所期望看到的内容。特别是，我们看到一个可选的严重性设置、错误代码、SQL 状态代码(字符串)和一条错误消息(字符串)。严重性是一个枚举值，当前可以设置为错误(0)或失败(1)。酷吧。

您可能想知道 protobuf 编译器在编译时对这段代码做了什么。让我们来看看由此产生的 Python 代码。清单 [7-5](#Par97) 显示了通用错误消息的编译代码。为了简洁起见，我省略了一些代码。

```sql
...
_ERROR = _descriptor.Descriptor(
  name='Error',
  full_name='Mysqlx.Error',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='severity', full_name='Mysqlx.Error.severity', index=0,
      number=1, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='code', full_name='Mysqlx.Error.code', index=1,
      number=2, type=13, cpp_type=3, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
...
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _ERROR_SEVERITY,
  ],
  options=None,
  is_extendable=False,
  syntax='proto3',
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=872,
  serialized_end=1001,
)
...
Listing 7-5Python Generic Error Message (mysqlx_pb2.proto)

```

啊！这一点也不简单，也不容易读懂。这是一个很好的例子，展示了 protobuf 可以为我们做多少事情。显然，用 protobuf 定义消息比用 Python 定义消息要重要得多(相对而言)。如果您感到好奇，用其他语言编译 protobuf 定义文件同样会产生复杂且看似难以理解的代码。但是不用担心；我们不需要直接读取编译后的文件！这很好，不是吗？

为了了解 X 协议的复杂性(和完整性),让我们看看 Connector/Python 是如何实现 X 协议的。在下一节中，我们将通过几个简单的例子，包括连接过程，来看看 X 协议是如何工作的。

Tip

我鼓励您探索其他* `.proto`文件，看看它们定义的消息。

### x 协议示例

我们探索 X 协议的两个实例:1)概述如何从协商、认证开始建立连接，然后是命令；以及 2)如何处理 SQL 插入。这些例子很容易理解，如果你好奇的话，可以很容易地在 protobuf 定义文件中找到。

#### 示例 1:身份验证

为简单起见，让我们假设我们想要使用旧的身份验证连接到服务器。这将让您很好地了解通信协议是如何工作的，而不像我们在新机制中看到的那样费力。目标是通过举例来理解典型的通信协议是如何工作的。毕竟，您不太可能构建自己的身份验证协议(但您可以通过构建自己的身份验证插件)。

该过程的生命周期从协商阶段开始，在这个阶段，客户机使用`CapabilitiesGet()`方法向服务器请求认证(和其他)能力。服务器用`CapabilitiesGet`消息响应(在`mysqlx_connection.proto`文件中定义)。客户端然后设置功能(比如设置 TLS 之类的认证扩展),通过`CapabilitiesSet()`方法发送完整的消息。假设数据是正确的，服务器回复`Ok`消息。

然后，客户端使用`AuthenticateStart()`方法启动身份验证。然后，服务器可以发出一个`AuthenticateContinue()`方法调用，向客户机请求更多数据。然后，客户端可以用相同的`AuthenticateContinue()`方法调用进行响应，一旦认证完成，服务器就用`AuthenticateOk()`方法调用进行响应。从那里，客户端可以启动命令。图 [7-2](#Fig2) 显示了消息传输方向的生命周期示例(执行相关方法的结果)。

![A432285_1_En_7_Fig2_HTML.jpg](img/A432285_1_En_7_Fig2_HTML.jpg)

图 7-2

X Protocol connection procedure (Courtesy of Oracle)

我们来看一下`CapabilitiesSet`的消息。清单 [7-6](#Par106) 显示了来自`mysqlx_connection.proto`文件的摘录。

```sql
...
// a Capability
//
// a tuple of a ``name`` and a :protobuf:msg:`Mysqlx.Datatypes::Any`
message Capability {
  required string name = 1;
  required Mysqlx.Datatypes.Any value = 2;
}

// Capabilities
message Capabilities {
  repeated Capability capabilities = 1;
}
...
// :precond: active sessions == 0
// :returns: :protobuf:msg:`Mysqlx::Ok` or :protobuf:msg:`Mysqlx::Error`
message CapabilitiesSet {
  required Capabilities capabilities = 1;
};
...

Listing 7-6CapabilitiesSet Message (mysqlx_connection.proto)

```

注意，我们看到`CapabilitiesSet`消息有一个名为`Capabilities`类型消息的能力的字段。这是一个占位符，供客户端用数据完成消息并将其发送回服务器。其他值包括`SCALAR` (1)、`OBJECT` (2)或`ARRAY` (3)，可以在`mysqlx_datatypes.proto`文件中找到。

#### 示例 2:简单插入

在本例中，我们将检查发出 SQL 语句时会发生什么。特别是，对一个简单的表执行两个`INSERT`语句。此时，我们正在处理一个 SQL 对象和位于名称奇怪的`mysqlx_sql.proto`文件中的`StmtExecute`消息。

该过程从客户端使用`Sql.StmtExecute()`方法向服务器发送语句开始。然后，服务器可以用`Sql.StmtExecuteOk()`方法进行响应。如图 [7-3](#Fig3) 所示，对下一条 INSERT 语句重复该过程。

![A432285_1_En_7_Fig3_HTML.jpg](img/A432285_1_En_7_Fig3_HTML.jpg)

图 7-3

X Protocol simple inserts (Courtesy of Oracle)

我们来看一下`Sql.StmtExecute`的消息。清单 [7-7](#Par111) 显示了来自`mysqlx_sql.proto`文件的摘录。

```sql
...
// execute a statement in the given namespace
//
// .. uml::
//
//   client -> server: StmtExecute
//   ... zero or more Resultsets ...
//   server --> client: StmtExecuteOk
//
// Notices:
//   This message may generate a notice containing WARNINGs generated by its execution.
//   This message may generate a notice containing INFO messages generated by its execution.
//
// :param namespace: namespace of the statement to be executed
// :param stmt: statement that shall be executed.
// :param args: values for wildcard replacements
// :param compact_metadata: send only type information for :protobuf:msg:`Mysqlx.Resultset::ColumnMetadata`, skipping names and others
// :returns:
//    * zero or one :protobuf:msg:`Mysqlx.Resultset::` followed by :protobuf:msg:`Mysqlx.Sql::StmtExecuteOk`
message StmtExecute {
  optional string namespace = 3 [ default = "sql" ];
  required bytes stmt = 1;
  repeated Mysqlx.Datatypes.Any args = 2;
  optional bool compact_metadata = 4 [ default = false ];
}
...
Listing 7-7Sql.StmtExecute Message (mysqlx_sql.proto)

```

注意，我们有用于`namespace`(默认设置为 SQL)的字段，SQL 语句存储在`stmt`中。注意，它的类型是 byte，所以我们可以处理任何字符集，包括二进制数据。然后，我们可以有零个或多个参数(`args`)，以允许参数化查询。最后，我们可以有一个可选的`compact_metadata`设置，允许服务器只将类型信息发送回客户端。

正如你所看到的，X 协议有很多内幕。然而，我们不需要了解 X 协议的所有知识就可以使用它。事实上，使用 X 协议的最佳方式是通过 MySQL Shell，这一点我们在第 [4](04.html) 章中有详细介绍，或者通过支持 X 协议的数据库连接器。让我们看看一个数据库连接器是如何实现 X 协议的。

Wait! Where’s the Rest of the Code?

如果您花时间检查 protobuf 定义文件，您可能会注意到缺少了两个主要的东西。Protobuf 是一种协议定义语言(API ),但它不支持通过网络直接传输消息，也不支持加密、压缩和其他数据传输技术。

因此，X 协议是所有这些代码存在的地方。现在你可以明白为什么 X 协议不仅仅是一个 protobuf 实现了。X 协议还实现了其他一些不属于 protobuf 消息定义的功能。这些包括与服务器握手、错误消息定义等等。

### x 协议演练

为了更好地理解 X 协议的强大和优雅，我们将研究一个数据库连接器是如何实现 X 协议的。这在 protobuf 定义文件上提供了一个抽象层，这让我们了解了 protobuf，这是一件非常好的事情。正如您将看到的，连接器使得使用 X 协议非常容易，从而延续了 protobuf 的目标，使通信协议易于创建和使用。

我们在本节和下一节中使用的数据库连接器是 Connector/Python，C/Py。我再次选择 C/Py 是因为它的简单性和可读性。如果您想继续学习并查看上下文中的代码，可以在 [`http://dev.mysql.com/downloads/connector/python/`](http://dev.mysql.com/downloads/connector/python/) 下载 Connector/Python 8 . 0 . 5 版或更高版本的源代码。请注意，您可能需要单击开发版本选项卡，然后从下拉列表中选择独立于平台的条目。

我们看一下上一节中每个例子的 C/Py 代码。因此，我们将看到连接到服务器并执行 SQL `INSERT`语句的代码。

#### 示例 1:身份验证

我们在位于`/lib/mysqlx`文件夹中的名为`connection.py`的 C/Py 源代码文件中找到了认证过程的代码。清单 [7-8](#Par120) 显示了实现该过程的源代码(方法)的摘录。为了简洁起见，我省略了收集和传递连接信息的细节。重点关注的起点是`Connection`类中的`connect()`方法。

```sql
...

def connect(self):
    # Loop and check
    error = None
    while self._can_failover:
        try:
            self.stream.connect(self._connection_params())
            self.reader_writer = MessageReaderWriter(self.stream)
            self.protocol = Protocol(self.reader_writer)
            self._handle_capabilities()
            self._authenticate()
            return
        except socket.error as err:
            error = err

    if len(self._routers) <= 1:
        raise InterfaceError("Cannot connect to host: {0}".format(error))
    raise InterfaceError("Failed to connect to any of the routers.", 4001)

def _handle_capabilities(self):
    if self.settings.get("ssl-mode") == SSLMode.DISABLED:
        return
    if self.stream.is_socket:
        if self.settings.get("ssl-mode"):
            _LOGGER.warning("SSL not required when using Unix socket.")
        return

    data = self.protocol.get_capabilites().capabilities
    if not (get_item_or_attr(data[0], "name").lower() == "tls"
            if data else False):
        self.close_connection()
        raise OperationalError("SSL not enabled at server.")

    is_ol7 = False
    if platform.system() == "Linux":
        # pylint: disable=W1505
        distname, version, _ = platform.linux_distribution()
        try:
            is_ol7 = "Oracle Linux" in distname and version.split(".")[0] == "7"
        except IndexError:
            is_ol7 = False
    if sys.version_info < (2, 7, 9) and not is_ol7:
        self.close_connection()
        raise RuntimeError("The support for SSL is not available for "
            "this Python version.")

    self.protocol.set_capabilities(tls=True)
    self.stream.set_ssl(self.settings.get("ssl-mode", SSLMode.REQUIRED),
                        self.settings.get("ssl-ca"),
                        self.settings.get("ssl-crl"),
                        self.settings.get("ssl-cert"),
                        self.settings.get("ssl-key"))

def _authenticate(self):
    auth = self.settings.get("auth")
    if (not auth and self.stream.is_secure()) or auth == Auth.PLAIN:
        self._authenticate_plain()
    elif auth == Auth.EXTERNAL:
        self._authenticate_external()
    else:
        self._authenticate_mysql41()
...

Listing 7-8Connection Methods for Authenticate Procedure (C/Py)

```

注意，在 connect()方法中，我们看到发生了几件事情。首先，我们看到 C/Py 打开了一个到服务器的流连接(通过 _connection_params()方法，该方法先前返回了数据集),然后代码创建了一个到读取器/写入器的实例。这就是连接器向/从服务器传输邮件的方式。

接下来，代码实例化协议类的一个实例，这是 X 协议的抽象。稍后我们将看到该代码的更多细节。

现在，关注 connect()方法中的最后两条语句。这里我们看到 _handle_capabilities()中对 CapabilitiesGet/Set 方法的方法调用和 _authenticate()中的身份验证阶段。花一些时间通读代码，这样您就可以看到图 [7-1](#Fig1) 中的所有步骤都显示出来了。

`Protocol`类的 CapabilitiesGet/Set 方法可以在 C/Py 源代码的/lib/mysqlx 文件夹中的 protocol.py 文件中找到，如清单 [7-9](#Par125) 所示。

```sql
...
def get_capabilites(self):
    msg = Message("Mysqlx.Connection.CapabilitiesGet")
    self._writer.write_message(
        mysqlxpb_enum("Mysqlx.ClientMessages.Type.CON_CAPABILITIES_GET"),
        msg)
    return self._reader.read_message()

def set_capabilities(self, **kwargs):
    capabilities = Message("Mysqlx.Connection.Capabilities")
    for key, value in kwargs.items():
        capability = Message("Mysqlx.Connection.Capability")
        capability["name"] = key
        capability["value"] = self._create_any(value)
        capabilities["capabilities"].extend([capability.get_message()])
    msg = Message("Mysqlx.Connection.CapabilitiesSet")
    msg["capabilities"] = capabilities
    self._writer.write_message(
        mysqlxpb_enum("Mysqlx.ClientMessages.Type.CON_CAPABILITIES_SET"),
        msg)
    return self.read_ok()
)
...

Listing 7-9CapabilitiesGet/Set Methods for Authenticate Procedure (C/Py)

```

在这一点上，我们可以看到通过由 protobuf 编译器生成的`MySQLx*`类对 protobuf 代码的调用。

#### 示例 2:简单插入

这个例子更容易理解，所以我们将比上一个例子更深入一些。我们在 C/Py 源代码的`/lib/mysqlx`文件夹中名为`statement.py`的 C/Py 源代码文件中找到了认证过程的代码。清单 [7-10](#Par128) 显示了源代码的摘录，它实现了一个用于执行`INSERT` SQL 语句的类。

```sql
...
class InsertStatement(WriteStatement):
    """A statement for insert operations on Table.

    Args:
        table (mysqlx.Table): The Table object.
        *fields: The fields to be inserted.
    """
    def __init__(self, table, *fields):
        super(InsertStatement, self).__init__(table, False)
        self._fields = flexible_params(*fields)

    def values(self, *values):
        """Set the values to be inserted.

        Args:
            *values: The values of the columns to be inserted.

        Returns:
            mysqlx.InsertStatement: InsertStatement object.
        """
        self._values.append(list(flexible_params(*values)))
        return self

    def execute(self):
        """Execute the statement.

        Returns:
            mysqlx.Result: Result object.
        """
        return self._connection.send_insert(self)
...

Listing 7-10SQL INSERT Class (C/Py)

```

如您所见，代码很容易阅读。首先要注意的是该类是从一个名为 WriteStatement 的基类派生而来的(也在`statement.py`中)。这个基类有一个名为`execute()`的抽象(虚拟)方法，这个派生类实现了这个方法。然而，在这种情况下，它从连接类(在`connection.py`中)调用`send_insert()`方法。下面展示了`send_insert()`的方法。

```sql
@catch_network_exception
def send_insert(self, statement):
    self.protocol.send_insert(statement)
    ids = None
    if isinstance(statement, AddStatement):
        ids = statement._ids
    return Result(self, ids)

```

如您所见，这用清单 [7-11](#Par132) 所示的语句调用了`protocol.py`文件中的协议类方法`send_insert()`。

```sql
...
def send_insert(self, stmt):
    data_model = mysqlxpb_enum("Mysqlx.Crud.DataModel.DOCUMENT"
                               if stmt._doc_based else
                               "Mysqlx.Crud.DataModel.TABLE")
    collection = Message("Mysqlx.Crud.Collection",
                         name=stmt.target.name,
                         schema=stmt.schema.name)
    msg = Message("Mysqlx.Crud.Insert", data_model=data_model,
                  collection=collection)

    if hasattr(stmt, "_fields"):
        for field in stmt._fields:
            expr = ExprParser(field, not stmt._doc_based) \
                .parse_table_insert_field()
            msg["projection"].extend([expr.get_message()])

    for value in stmt._values:
        row = Message("Mysqlx.Crud.Insert.TypedRow")
        if isinstance(value, list):
            for val in value:
                row["field"].extend([build_expr(val).get_message()])
        else:
            row["field"].extend([build_expr(value).get_message()])
        msg["row"].extend([row.get_message()])

    msg["upsert"] = stmt._upsert
    self._writer.write_message(
        mysqlxpb_enum("Mysqlx.ClientMessages.Type.CRUD_INSERT"), msg)
...

Listing 7-11The send_insert() Method in the Protocol Class (C/Py)

```

和前面的例子一样，我们现在可以看到 protobuf 接口，并按照代码来查看图 [7-2](#Fig2) 中概述的步骤。

Tip

如果你想了解更多关于 X 协议是如何工作的，请看位于 [`https://dev.mysql.com/doc/internals/en/x-protocol.html`](https://dev.mysql.com/doc/internals/en/x-protocol.html) 的 MySQL 内部文档。

既然我们对 X 协议有了更多的了解，并且能够理解 X 插件和 Shell 以及数据库连接器提供的抽象，那么让我们看看如何编写利用 MySQL 连接器提供的 X 协议的客户端应用。在这种情况下，我们将继续通过使用 Connector/Python 来掌握 X 协议。

## 创建 X 客户端

创建使用 X 协议的 MySQL 客户端应用最好是使用 MySQL Shell 或者最终使用一个数据库连接器，并在服务器上安装 X 插件。在本节中，我们将看到两个独立客户端的示例。一个是使用 MySQL 作为文档存储编写的，另一个只使用关系数据模型。

我们将使用的编程语言是一种非常简单的脚本语言，叫做 Python。正如您将看到的，这些命令非常直观，非常有表现力。出于本演示的目的，您不需要成为这种语言的专家。我会提供所有的代码和命令，你需要我们一起去。

Python? Isn’t That a Snake?

Python 编程语言是一种高级语言，旨在尽可能接近阅读英语，同时简单、易学且非常强大。皮托尼斯塔斯会告诉你设计师们确实达到了这些目标。

Python 在使用前不需要编译步骤。相反，Python 应用(其文件名以`.py`结尾)是动态解释的。这是非常强大的；但是除非使用 Python 开发环境，否则一些语法错误(比如不正确的缩进)直到应用执行后才会被发现。幸运的是，Python 提供了一个健壮的异常处理机制。

如果您从未使用过 Python，或者您想了解更多，下面是几本介绍这种语言的好书。互联网上也有很多资源，包括位于 [`http://www.python.org/doc/`](http://www.python.org/doc/) 的 Python 文档页面:

*   《树莓派编程》，西蒙·蒙克著(麦格劳-希尔出版社，2013 年)。
*   Python 入门，从新手到专业人士，第 2 版。马格努斯·李·赫特兰德著。
*   大卫·比兹利和布莱恩·k·琼斯的《Python 食谱》(O'Reilly Media，2013 年)。

有趣的是，Python 是以英国喜剧团 Monty Python 而不是爬行动物命名的。当你学习 Python 的时候，你可能会遇到对 Monty Python 剧集的无聊引用。我对巨蟒小组情有独钟，觉得这些参考资料很有趣。当然，您的里程可能会有所不同。

首先，您可以输入示例中所示的代码，或者从本书的网站下载源代码。在编写 Python 脚本时，您可以使用任何想要的代码编辑器。我们从如何设置环境来运行示例的简短描述开始。

Tip

有很多可用的，包括 JetBrains 的一个非常强大的 IDE，名为 PyCharm ( [`http://www.jetbrains.com/pycharm/`](http://www.jetbrains.com/pycharm/) )。如果您想要一个优秀的 Python 开源软件，请查看 PyCharm 社区版。

### 示例的设置

要使用本节中的示例，您需要安装一些东西。您必须下载 Google Protocol Buffers Python 库并安装编程语言运行时。您还必须下载 C/Py 的源代码。

回想一下，我们需要安装 protobuf 编译器和 protobuf 库。如果您还没有这样做，请参考上一节“安装 Protobuf 编译器”

特定语言的运行时库可以从 [`https://github.com/google/protobuf`](https://github.com/google/protobuf) 下载。您应该通过单击克隆或下载按钮来下载整个包。下载完成后，您会看到一个名为`protobuf-master.zip`的文件，您可以解压缩它。要安装所选语言的库，请导航到以该语言命名的文件夹，并阅读 README.md 文件以获取特定的安装说明。例如，我们将在本章中使用 Python。这个文件夹被命名为`/protobuf-master/python`。要在 macOS 上安装 Python，可以运行以下命令。

```sql
$ python ./setup.py build
$ sudo python ./setup.py install

```

在其他系统上安装 Python 库是类似的。在 Windows 上安装它的唯一区别是你不需要使用 sudo(超级用户)。然而，在我的系统上，定位 protobuf 编译器有一个问题。我收到了类似如下的错误。

```sql
protoc is not installed nor found in ../src.  Please compile it or install the binary package.

```

一旦我将 protobuf 编译器可执行文件(`protoc`)放在指定的目录(`../src`)中，我就可以用前面的命令安装 Python protobuf 库了。您可能会在其他平台上遇到类似的问题。

Tip

向下滚动到页面底部的 [`https://github.com/google/protobuf`](https://github.com/google/protobuf) ，点击表格中的链接，查看安装其他语言的 protobuf 库的说明。

如果您还没有，您必须从 [`http://dev.mysql.com/downloads/connector/python/`](http://dev.mysql.com/downloads/connector/python/) 下载 C/Py 8 . 0 . 5 版或更高版本的源代码。确保从下拉列表中下载独立于平台的选项。在我们的例子中，我们将使用 C/Py 源文件树中的一些源文件。

我选择这样做是为了帮助您了解 protobuf 如何与 Python 一起工作以及 C/Py 如何实现 X 协议的细节。尽管这些示例将展示 C/Py 中的 X 协议抽象层，但是您可以使用您最喜欢的调试器或 Python IDE 来深入研究代码，看看事情是如何工作的。因此，我为我们当中的好奇者树立了这个榜样。然而，如果你不想走那么远，你可以不走那么远。相反，您可以专注于示例是如何工作的，以便更好地理解如何通过数据库连接器使用新的 X 协议。

也许更重要的是，因为我们使用的 C/Py 示例是一个开发里程碑版本(考虑 beta 版)，复制源代码不会影响系统上 C/Py 的任何其他安装，从而允许您运行这些示例，而不必安装连接器的开发里程碑版本。

我们需要的文件在`/lib/mysqlx`文件夹里。但是首先，在你的系统上创建一个新的文件夹。随便你怎么命名比如`xclient`。接下来，将 C/Py 档案中的`mysqlx`文件夹复制到`xclient`文件夹中。当你为下面的例子创建文件时，把它们保存在`xclient`文件夹中。例如，我将文档存储示例命名为`xclient_json.p` y，将关系数据示例命名为`xclient_sql.py`。

Tip

如果出现找不到一个或多个库的错误，请确保将 mysqlx 文件夹复制到与 xclient_json.py 和 xclient_sql.py 文件相同的文件夹中。

### 文档存储示例

这个例子创建了一个简单的客户机来演示如何使用 C/Py 中的 X 协议抽象。这个例子使用了我们在第 [1](01.html) 章中遇到的联系人的概念。在这种情况下，代码将连接到服务器，在模式中创建一个模式和集合，并用文档填充集合。然后，代码将检索所有文档并打印出来。但是我们不仅仅打印原始文档。该代码演示了如何在集合上执行查找操作，并遍历文档，为找到的每个联系人文档打印电话号码。

下面简要描述了代码部分。我强调了相关的代码语句，以引起您对 X 协议抽象方法的注意。大多数调用对你来说都很熟悉，因为我们在第 5 章和本书的其他地方遇到过它们。因此，我保持解释简短。如果你需要更多关于例子中使用的类和方法的信息，请参考第 5 章。

我们需要做的第一件事是导入`mysqlx`库。回想一下，这是从 C/Py 下载的一组文件。它包含了我们前面看到的 X 协议文件的 C/Py 抽象。如果您检查该文件夹，您会注意到`.proto`文件丢失了。这是因为我们只需要运行 protobuf 编译器时生成的`.py`文件。幸运的是，所有这些文件都存在于`mysqlx`文件夹中。

接下来，我们要求用户提供登录凭证(用户 id、密码、主机和端口)。我们使用这些信息来打开一个到服务器的会话(连接)。为此，我们使用`get_session()`方法，并将会话对象的结果实例赋给变量`mysqlx_session`。如果发生了我们无法连接的情况，我们会检查会话的状态，如果会话没有打开，就退出。注意，我们在这个例子中使用 X 会话，因为我们只执行 CRUD 操作，不需要任何 SQL 支持。

接下来，我们使用`mysqlx_session`对象实例，并尝试用`get_schema()`方法获取模式。 [<sup>8</sup>](#Fn8) 这将设置默认模式，以便当我们创建集合(或者其他对象)时；它们将包含在模式中。我使用一个常量来存储模式名和集合名。如果模式不在服务器上，我们用`create_schema()`方法创建它。无论哪种方式，我们都会得到一个 schema 对象实例，我们可以用这个实例用`create_collection()`方法创建集合，这个方法为我们提供了一个集合的对象实例。注意，我使用了`remove()`方法来清空集合。这允许我们在不复制数据的情况下重新运行代码(我没有检查文档 id)。

在继续之前，让我们看一下代码。清单 [7-12](#Par169) 显示了完整的代码。花一些时间通读代码，以便您可以看到到目前为止描述的所有方法和操作。您应该对 contacts.remove()调用之前的所有代码都很熟悉。如果您想执行这段代码来看看它做了什么，您可以将这段代码放在一个名为 xclient_json.py 的文件中。

```sql
#
# Introducing the MySQL 8 Document Store - xclient_json
#
# This file contains and example of how to read a collection from a MySQL
# server using the X Protocol via a Session object
#
# Dr. Charles Bell, 2018
#
import getpass
import mysqlx

# Declarations
TEST_SCHEMA = "rolodex"
TEST_COL = "contacts"

# Get user information
print("Please enter the connection information.")
user = raw_input("Username: ")
passwd = getpass.getpass("Password: ")
host = raw_input("Hostname [localhost]: ") or 'localhost'
port = raw_input("Port [33060]: ") or '33060'

# Get a session object using a dictionary of terms
mysqlx_session = mysqlx.get_session({'host': host, 'port': port, 'user': user, 'password': passwd})

# Check to see that the session is open. If not, quit.
if not mysqlx_session.is_open():
    exit(1)

# Get the schema and create it if it doesn't exist
schema = mysqlx_session.get_schema(TEST_SCHEMA)
if not schema.exists_in_database():
    schema = mysqlx_session.create_schema(TEST_SCHEMA)

# Create a collection or use it if it already exists
contacts = schema.create_collection(TEST_COL)

# Empty the collection
contacts.remove()

# Insert data with inline JSON
contacts.add({"name": {"first": "Allen"},
              "phones": [{"work": "212-555-1212"}]}).execute()
contacts.add({"name": {"first": "Joe", "last": "Wheelerton"},
              "phones": [{"work": "212-555-1213"}, {"home": "212-555-1253"}],
              "address": {"street": "123 main", "city": "oxnard", "state": "ca", "zip": "90125"},
              "notes": "Excellent car detailer. Referrals get $20 off next detail!"}).execute()

# Get all of the data
doc_results = contacts.find().execute()

# Show the results
print("\nList of Phone Numbers")
document = doc_results.fetch_one()
while document:
    print("{0}:\t".format(document.name['first'])),
    for phone in document.phones:
        for key, value in phone.iteritems():
            print("({0}) {1}".format(key, value)),
    print("")
    document = doc_results.fetch_one()

# Drop the collection
schema.drop_collection(TEST_COL)

# Drop the schema
mysqlx_session.drop_schema(TEST_SCHEMA)

# Close the session
mysqlx_session.close()

Listing 7-12
X Client Source Code (JSON)

```

Tip

如果您使用的是 Python 3.0 或更高版本，您需要将`raw_input()`调用改为`input()`，将`iteritems()`改为`items()`。这是因为在 Python 的后续版本中不再支持`raw_input()`和`iteritems()`。

接下来，我们可以添加一些联系人。我们使用集合对象实例的`add()`方法来实现这一点。在本例中，我们添加了几个文档；一个是我们只知道他们的名字和电话号码的人，另一个是我们知道他们的全名、几个电话号码和一些我们做的笔记的人。这说明了使用文档存储的强大之处:存储您需要的东西，不要强迫数据遵守严格的结构或存储机制！

一旦添加了文档，我们就对集合使用`find()`方法，而不使用任何表达式。我们用`execute()`方法链接查找操作。这只是以文档结果对象实例的形式返回集合中的所有文档。然后我们可以用这个对象通过`fetch_one()`方法迭代文档。请注意，这将返回一个文档对象实例，我们可以使用该实例通过命名属性(一个强大的表达式)直接获取数据元素。花点时间通读一下获取文档的代码。注意，当收集结束时，`fetch_one()`返回`None`，while 循环终止。

最后，我们用`drop_collection()`方法删除集合，用`drop_schema()`方法删除模式，这样我们就可以重新运行代码并避免重复。但是，您可能会注意到，我添加了代码来防止意外执行。例如，如果您使用调试器并在结束前终止代码，代码顶部的语句将使用该架构(如果它已经存在)并清空集合。

现在让我们看看脚本的运行情况。在这种情况下，我们希望只看到 rolodex 中的人的名字和电话号码列表(在这种情况下只有两个条目)。

```sql
$ python ./xclient_json.py
Please enter the connection information.
Username: root
Password:
Hostname [localhost]:
Port [33060]:

List of Phone Numbers
Joe:     (work) 212-555-1213 (home) 212-555-1253
Allen:   (work) 212-555-1212

```

如果您想知道这是否是一个精心策划的诡计，我们创建的集合和文档不知何故存储在 MySQL 的其他地方，如果您禁用了`drop_*()`调用并再次运行该程序，您可以登录到服务器并查看底层表的构造，如清单 [7-13](#Par177) 所示。

```sql
$ mysqlsh root@localhost:33060 --sql --json=pretty --schema=rolodex -e "EXPLAIN contacts"
{
    "password": "Enter password: "
}

{
    "executionTime": "0.00 sec",
    "warningCount": 0,
    "warnings": [],
    "rows": [
        {
            "Field": "doc",
            "Type": "json",
            "Null": "YES",
            "Key": "",
            "Default": null,
            "Extra": ""
        },
        {
            "Field": "_id",
            "Type": "varchar(32)",
            "Null": "NO",
            "Key": "PRI",
            "Default": null,
            "Extra": "STORED GENERATED"
        }
    ],
    "hasData": true,
    "affectedRowCount": 0,
    "autoIncrementValue": 0
}

Listing 7-13Definition of the Contacts Collection

```

如果您运行一个`SELECT`语句从该表中获取所有数据，您将看到类似于清单 [7-14](#Par179) 中所示的结果。结果的顺序可能有所不同，但您应该在结果中看到相同的数据。注意，文档 id 被添加到每个 JSON 文档中。

```sql
$ mysqlsh root@localhost:33060 --sql --json=pretty --schema=rolodex -e "SELECT * FROM contacts"
{
    "password": "Enter password: "
}

{
    "executionTime": "0.00 sec",
    "warningCount": 0,
    "warnings": [],
    "rows": [
        {
            "doc": "{\"_id\": \"9801A79DE09382A811E806BFAD2FA2CF\", \"name\": {\"first\": \"Allen\"}, \"phones\": [{\"work\": \"212-555-1212\"}]}",
            "_id": "9801A79DE09382A811E806BFAD2FA2CF"
        },
        {
            "doc": "{\"_id\": \"9801A79DE0938DFD11E806BFAD314DE1\", \"name\": {\"last\": \"Wheelerton\", \"first\": \"Joe\"}, \"notes\": \"Excellent car detailer. Referrals get $20 off next detail!\", \"phones\": [{\"work\": \"212-555-1213\"}, {\"home\": \"212-555-1253\"}], \"address\": {\"zip\": \"90125\", \"city\": \"oxnard\", \"state\": \"ca\", \"street\": \"123 main\"}}",
            "_id": "9801A79DE0938DFD11E806BFAD314DE1"
        }
    ],
    "hasData": true,
    "affectedRowCount": 0,
    "autoIncrementValue": 0
}

Listing 7-14Results of SELECT Statement for Contacts Collection

```

那很酷，不是吗？当我们探索一个完整的文档存储应用示例时，我们将在第 [8](08.html) 章中看到更多这样的代码。但是首先，让我们看一个使用 X 协议执行 SQL 命令的 Connector/Python 示例。

### 关系数据示例

现在让我们看一个使用 X 协议的关系数据例子。我们将使用与上一个示例相同的 C/Py 代码，只是这次我们将执行 SQL 语句，而不是处理数据。我选择这个简单的例子是因为，如果不是一开始，最终您的 MySQL 文档存储应用将使用越来越少的 SQL 操作。即便如此，如果您想检查变量、状态或类似的服务器操作，您可能需要不时地执行一条 SQL 语句。

这个示例使用一个会话连接到服务器，并执行 SQL 语句`SHOW VARIABLES LIKE`，来检索 X 插件的所有系统变量。这与我们在第 6 章[中看到的 SQL 语句相同。尽管我们没有访问任何数据，但是从`SHOW VARIABLES`语句返回的结果集与查询表时返回的结果集是相同的。因此，我们将看到如何处理来自 SQL 命令的结果集，而不需要创建任何示例数据。](06.html)

和上一个例子一样，我们从导入`mysqlx`库开始，并提示用户输入登录凭证。请注意，我演示了如何为用户输入使用默认值。接下来，我们用`get_session()`方法得到一个会话。这将返回一个会话对象实例。然后，我们检查连接是否打开，如果不是(例如，连接失败)，我们退出。清单 [7-15](#Par184) 显示了这个例子的完整代码。花点时间通读一下，这样你就可以看到到目前为止讨论的所有概念。

```sql
#
# Introducing the MySQL 8 Document Store - xclient_sql
#
# This file contains an example of how to read a database (SQL) from a MySQL
# server using the X Protocol via a Session object
#
# Dr. Charles Bell, 2018
#
import getpass
import mysqlx

# Get user information
print("Please enter the connection information.")
user = raw_input("Username: ")
passwd = getpass.getpass("Password: ")
host =  raw_input("Hostname [localhost]: ") or 'localhost'
port = raw_input("Port [33060]: ") or '33060'

# Get a session object since we want to execute SQL statements
mysqlx_session = mysqlx.get_session({'host': host, 'port': port, 'user': user, 'password': passwd})

# Check to see that the session is open. If not, quit.
if not mysqlx_session.is_open():
    exit(1)

# Get an SqlStatements object
sql_stmt = mysqlx_session.sql("SHOW VARIABLES LIKE 'mysqlx_%'")

# Execute and get a SqlResult object
sql_result = sql_stmt.execute()

print("\nVariables for the X Plugin:")
# Print the column labels (names)
for col in sql_result.columns:
    print("{0}\t".format(col.get_column_name())),
print("\n-------------------------------------------")

# Print the rows
for row in sql_result.fetch_all():
    for col in row:
        print("{0}\t".format(col)),
    print("")

# Close the session
mysqlx_session.close()

Listing 7-15
X Client Source Code (SQL)

```

Tip

如果您使用的是 Python 3.0 或更高版本，您可能需要将`raw_input()`调用改为`input()`。这是因为在 Python 的后续版本中不再支持`raw_input()`。

为了执行 SQL 语句，我们需要通过传入我们想要执行的 SQL 语句，向会话请求 SQL statement 对象实例。我们通过调用会话对象实例的 sql()方法来实现这一点。我们可以使用该对象来执行语句，并获得一个结果对象实例作为回报。

接下来，我们可以迭代结果集中的列，打印它们的名称。这说明了如何捕获结果集中的列名。

接下来，我们使用`fetch_all()`方法获取列表中的所有行，在 for 循环中遍历它们，并打印找到的每一列的值。注意，我们在这里使用“行”和“列”,因为这不是一个被返回的文档——它是一个老式的 SQL 结果集(嗯，通过 X 协议)。最后，我们结束会议。清单 [7-16](#Par189) 展示了脚本运行的一个例子。您应该能够将输出等同于源代码中的`print()`语句。请注意，MySQL 的更高版本可能会有额外的变量，一些默认值可能会有所不同。

```sql
$ python ./xclient_sql.py
Please enter the connection information.
Username: root
Password:
Hostname [localhost]:
Port [33060]:

Variables for the X Plugin:
Variable_name    Value
-------------------------------------------
mysqlx_bind_address     *
mysqlx_connect_timeout  30
mysqlx_idle_worker_thread_timeout        60
mysqlx_max_allowed_packet        1048576
mysqlx_max_connections  100
mysqlx_min_worker_threads        2
mysqlx_port      33060
mysqlx_port_open_timeout         0
mysqlx_socket   /tmp/mysqlx.sock
mysqlx_ssl_ca
mysqlx_ssl_capath
mysqlx_ssl_cert
mysqlx_ssl_cipher
mysqlx_ssl_crl
mysqlx_ssl_crlpath
mysqlx_ssl_key

Listing 7-16X Client Results (SQL)

```

注意这里我们看到了 X 插件的所有系统变量(那些以`mysqlx_`开头的变量)。我们还可以看到每个系统变量的值。SSL 条目没有任何值，因为示例中使用的连接没有通过安全连接进行连接。

如您所见，即使使用像 Python 这样的语言，也很容易编写利用 X 协议和 X DevAPI 的客户端。当然，这在 Connector/Python 中都是可能的，它实现了 X 协议。有关 X 协议的更多信息，请参见在线 MySQL 内部参考手册 [`https://dev.mysql.com/doc/internals/en/`](https://dev.mysql.com/doc/internals/en/) 中的“X 协议”部分。有关使用连接器编写客户端的具体信息，请参见位于 [`https://dev.mysql.com/doc`](https://dev.mysql.com/doc) 的单个连接器在线文档。你可以在 [`https://dev.mysql.com/doc/dev/connector-python/`](https://dev.mysql.com/doc/dev/connector-python/) 找到关于使用 X DevAPI 和 Connector/Python 的信息。

## 摘要

X 协议是 MySQL 中一个革命性的新特性，它克服了旧的客户机/服务器协议的许多限制。X 协议是为可扩展性而设计的，因此它可以在不影响依赖它的客户端的情况下进行扩展。X 协议也被设计成具有更高的安全性和更好的性能。几十年来，MySQL 客户端第一次可以使用现代、可靠的技术与服务器连接和交互，并有望成为未来更多新功能的催化剂。

在这一章中，我们从创建 X 协议的动机、设计的主要原则或目标以及如何使用 protobuf 作为基础来实现 X 协议开始进行了研究。我们还看到了 X 协议的一些部分如何为简单用例工作的演练。然后我们看了如何在我们的应用中使用 protobuf 在代码中移动数据(消息)(在磁盘上，通过网络等)。)，说明了 protobuf 的强大。

我们还通过检查实际 C/Py 源代码的一部分，简短地介绍了 C/Py 如何实现 X 协议。然后，我们在独立的 Python 脚本中使用 C/Py 中的 X 协议抽象层来演示 X 协议是如何工作的——它易于实现，也是本书中到目前为止介绍的技术的一个具体示例。

与 X 插件一样，我们也发现 X 协议不仅仅是一个特性，它是一个精心制作和良好抽象的机制，是 MySQL 未来的基础之一。即使我们知道在使用支持 X 协议的连接器时，我们使用的是 X 协议，X 协议也能正常工作，而且工作得非常好。

在第 8 章中，我提供了一个使用 X DevAPI 编写应用的教程，我们现在知道它是通过 X 插件和 X 协议实现的。该项目将使用 MySQL 文档存储来构建一个基于 Python web 的解决方案，用于存储有关书籍的信息。

Footnotes [1](#Fn1_source)

那么，为什么是 MySQL 8 而不是 MySQL X 呢？

  [2](#Fn2_source)

工作日志是一个内部文档，用于捕获在 MySQL 中实现特性的设计和需求。

  [3](#Fn3_source)

SSL 的一种演变: [`https://en.wikipedia.org/wiki/Transport_Layer_Security`](https://en.wikipedia.org/wiki/Transport_Layer_Security) `.`

  [4](#Fn4_source)

一个认证和数据安全的框架: [`https://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer`](https://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer) `.`

  [5](#Fn5_source)

充其量是渐进成功；总有美中不足的地方。

  [6](#Fn6_source)

换句话说，把你的椅子放在半倾斜的状态，放上你最喜欢的音乐，确保手边有足够的你最喜欢的饮料。

  [7](#Fn7_source)

或者像我有时被指责的那样“没有把事情做好”。有罪。我从小就在拆东西。有时我会把它们放回一起！

  [8](#Fn8_source)

在 SQL 术语中使用它。