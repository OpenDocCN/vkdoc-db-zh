# 十八、锁定理论和监控

与上一章讨论的优化器一起，锁可能是查询优化中最复杂的主题。当锁显示出它们最糟糕的一面时，即使是最好的锁专家也会头发变白。然而，不要绝望。本章将向你介绍你需要的大多数锁的知识，甚至更多。在你读完这一章之后，你应该能够开始研究锁，并利用它获得更多的知识。

本章开始讨论为什么需要锁以及锁的访问级别。本章最大的部分介绍了 MySQL 中最常见的锁。本章的另一半讨论为什么锁请求可能失败，如何减少锁的影响，以及如何监控锁。

Note

大多数例子都包含了再现输出的重要部分的语句(某些数据在本质上会因情况而异)。因为锁定的有趣部分通常包括多个连接，所以查询提示被设置为在重要时指示哪个连接用于哪个查询。例如，`Connection 1>`意味着查询应该由您的第一个连接执行。

## 为什么需要锁？

这似乎是一个不需要锁定数据库的完美世界。但是价格会很高，只有少数用例可以使用该数据库，对于 MySQL 这样的通用数据库来说是不可能的。如果没有锁定，就不能有任何并发性。想象一下，只允许一个到数据库的连接(你可以说它本身是一个锁，因此系统不是无锁的)——这对大多数应用来说不是很有用。

Note

通常，MySQL 中所谓的锁实际上是一个锁请求，它可以处于授权或挂起状态。

当您有几个连接同时执行查询时，您需要某种方法来确保这些连接不会互相妨碍。这就是锁进入画面的地方。您可以将锁想象成道路交通中的交通信号，它控制资源的访问以避免事故。在道路交叉路口，要保证两车不交叉，不发生碰撞。在数据库中，有必要确保两个查询对数据的访问不冲突。

由于控制进入十字路口有不同的级别——让行、停车标志和交通灯——数据库中有不同的锁类型。

## 锁定访问级别

锁访问级别决定了给定锁允许哪种类型的访问。它有时也被称为锁类型，但是因为它可能与锁粒度混淆，所以这里使用术语锁访问级别。

本质上有两种访问级别:共享或独占。访问级别顾名思义。共享锁允许其他连接也获得共享锁。这是最宽松的锁访问级别。独占锁只允许一个连接获得锁。共享锁也称为读锁，排他锁也称为写锁。

MySQL 还有一个叫做意向锁的概念，它指定了事务的意向。意向锁可以是共享的，也可以是排他的。在下一节讨论 MySQL 中的主要锁粒度级别时，将更详细地讨论意向锁。

## 锁定粒度

MySQL 使用一系列不同的锁粒度(也称为锁类型)来控制对数据的访问。通过使用不同的锁粒度，在最大程度上允许对数据的并发访问。本节将介绍 MySQL 使用的主要粒度级别。

### 用户级锁

用户级锁是应用可以用来保护的显式锁类型，例如，工作流。它们不常使用，但是对于一些需要序列化访问的复杂任务来说，它们会很有用。所有用户锁都是排他锁，使用最长 64 个字符的名称获得。

您可以使用一组函数来操作用户级锁:

*   `GET_LOCK(name, timeout)` **:** 通过指定锁的名称获得锁。第二个参数是以秒为单位的超时；如果在这段时间内没有获得锁，该函数将返回 0。如果获得了锁，返回值为 1。如果超时为负，该函数将无限期等待锁变为可用。

*   `IS_FREE_LOCK(name)` **:** 检查命名锁是否可用。如果锁可用，函数返回 1，如果锁不可用，函数返回 0。

*   `IS_USED_LOCK(name)` **:** 这是`IS_FREE_LOCK()`功能的反义词。如果锁在使用中(不可用)，该函数返回持有锁的连接的连接 id，如果锁不在使用中(可用)，则返回`NULL`。

*   `RELEASE_ALL_LOCKS()` **:** 释放连接持有的所有用户级锁。返回值是释放的锁的数量。

*   `RELEASE_LOCK(name)` **:** 用提供的名字解锁。如果锁被释放，返回值为 1；如果锁存在但不属于连接，返回值为 0；如果锁不存在，返回值为`NULL`。

通过多次调用`GET_LOCK()`可以获得多个锁。如果这样做，请注意确保所有用户以相同的顺序获得锁，否则可能会发生死锁。如果发生死锁，将返回一个`ER_USER_LOCK_DEADLOCK`错误(错误代码 3058)。清单 [18-1](#PC1) 中显示了一个例子。

```sql
-- Connection 1
Connection 1> SELECT GET_LOCK('my_lock_1', -1);
+---------------------------+
| GET_LOCK('my_lock_1', -1) |
+---------------------------+
|                         1 |
+---------------------------+
1 row in set (0.0100 sec)

-- Connection 2
Connection 2> SELECT GET_LOCK('my_lock_2', -1);
+---------------------------+
| GET_LOCK('my_lock_2', -1) |
+---------------------------+
|                         1 |
+---------------------------+
1 row in set (0.0006 sec)

Connection 2> SELECT GET_LOCK('my_lock_1', -1);

-- Connection 1

Connection 1> SELECT GET_LOCK('my_lock_2', -1);
ERROR: 3058: Deadlock found when trying to get user-level lock; try rolling back transaction/releasing locks and restarting lock acquisition.

Listing 18-1A deadlock for user-level locks

```

当连接 2 试图获取`my_lock_1`锁时，该语句将被阻塞，直到连接 1 试图获取触发死锁的`my_lock_2`锁。如果您获得多个锁，您应该准备好处理死锁。请注意，对于用户级锁，死锁不会触发事务回滚。

被授予和挂起的用户级锁可以在`performance_schema.metadata_locks`表中找到，其中`OBJECT_TYPE`列设置为`USER LEVEL LOCK`，如清单 [18-2](#PC2) 所示。列出的锁假设您离开了清单 [18-1](#PC1) 中的死锁被触发时的系统。请注意，有些值如`OBJECT_INSTANCE_BEGIN`会因您而异。

```sql
mysql> SELECT *
         FROM performance_schema.metadata_locks
        WHERE OBJECT_TYPE = 'USER LEVEL LOCK'\G
*************************** 1\. row ***************************
          OBJECT_TYPE: USER LEVEL LOCK
        OBJECT_SCHEMA: NULL
          OBJECT_NAME: my_lock_1
          COLUMN_NAME: NULL
OBJECT_INSTANCE_BEGIN: 2600542870816
            LOCK_TYPE: EXCLUSIVE
        LOCK_DURATION: EXPLICIT
          LOCK_STATUS: GRANTED
               SOURCE: item_func.cc:4840
      OWNER_THREAD_ID: 76
       OWNER_EVENT_ID: 33
*************************** 2\. row ***************************
          OBJECT_TYPE: USER LEVEL LOCK
        OBJECT_SCHEMA: NULL
          OBJECT_NAME: my_lock_2
          COLUMN_NAME: NULL
OBJECT_INSTANCE_BEGIN: 2600542868896
            LOCK_TYPE: EXCLUSIVE
        LOCK_DURATION: EXPLICIT
          LOCK_STATUS: GRANTED
               SOURCE: item_func.cc:4840
      OWNER_THREAD_ID: 62
       OWNER_EVENT_ID: 25
*************************** 3\. row ***************************
          OBJECT_TYPE: USER LEVEL LOCK
        OBJECT_SCHEMA: NULL
          OBJECT_NAME: my_lock_1
          COLUMN_NAME: NULL
OBJECT_INSTANCE_BEGIN: 2600542870336
            LOCK_TYPE: EXCLUSIVE
        LOCK_DURATION: EXPLICIT
          LOCK_STATUS: PENDING
               SOURCE: item_func.cc:4840
      OWNER_THREAD_ID: 62
       OWNER_EVENT_ID: 26

3 rows in set (0.0086 sec)

Listing 18-2Listing user-level locks

```

用户级锁的`OBJECT_TYPE`是`USER LEVEL LOCK`，锁的持续时间是`EXPLICIT`，因为这取决于用户或应用是否再次释放锁。在第 1 行中，具有性能模式线程 id 76 的连接已经被授予了`my_lock_1`锁，而在第 3 行中，线程 id 62 正在等待它被授予。线程 id 62 也具有包含在行 2 中的授权锁。

下一级锁涉及非数据表级锁。首先要讨论的是冲水锁。

### 清空锁

大多数参与备份的人都熟悉刷新锁。它是在使用`FLUSH TABLES`语句时获取的，并持续整个语句期间，除非您添加了`WITH READ LOCK`,在这种情况下，共享(读)锁将被持有，直到该锁被显式释放。在`ANALYZE TABLE`语句的结尾也会触发隐式的表刷新。刷新锁是一个表级锁。用`FLUSH TABLES WITH READ LOCK`获取的读锁将在后面的显式锁中讨论。

刷新锁的锁问题的一个常见原因是长时间运行的查询。只要存在打开表的查询，一个`FLUSH TABLES`语句就不能刷新表。这意味着，如果在一个长时间运行的查询使用一个或多个被刷新的表时执行一个`FLUSH TABLES`语句，那么`FLUSH TABLES`语句将阻塞所有其他需要这些表的语句，直到锁的情况得到解决。

嵌入式锁受`lock_wait_timeout`设置的影响。如果获得锁的时间超过`lock_wait_timeout`秒，MySQL 将放弃锁。如果`FLUSH TABLES`声明被扼杀，同样适用。然而，由于 MySQL 的内部原因，在长时间运行的查询完成之前，一个称为表定义缓存(TDC)版本锁的较低级别的锁不能总是被释放。 <sup>[1](#Fn1)</sup> 这意味着确保锁问题得到解决的唯一方法是终止长时间运行的查询，但是要注意，如果查询已经更改了许多行，回滚查询可能需要很长时间。

当围绕刷新锁存在锁争用时，`FLUSH TABLES`语句和随后启动的查询都将状态设置为“等待表刷新”清单 [18-3](#PC3) 展示了一个包含三个查询的例子。为了自己重现这个场景，开始执行三个查询，将提示设置为`Connection N>`，其中`N`为 1、2 或 3，代表三个不同的连接。针对`sys.session`的查询在第四个连接中完成。所有查询都必须在第一个查询完成之前执行(需要三分钟)。

```sql
-- Connection 1
Connection 1> SELECT *, SLEEP(180) FROM world.city WHERE ID = 130;

-- Connection 2
Connection 2> FLUSH TABLES world.city;

-- Connection 3
Connection 3> SELECT * FROM world.city WHERE ID = 201;

-- Connection 4
Connection 4> SELECT thd_id, conn_id, state,
                     current_statement
                FROM sys.session
               WHERE current_statement IS NOT NULL
                     AND thd_id <> PS_CURRENT_THREAD_ID()\G
*************************** 1\. row ***************************
           thd_id: 61
          conn_id: 21
            state: User sleep
current_statement: SELECT *, SLEEP(180) FROM world.city WHERE ID = 130
*************************** 2\. row ***************************
           thd_id: 62
          conn_id: 22
            state: Waiting for table flush
current_statement: FLUSH TABLES world.city
*************************** 3\. row ***************************
           thd_id: 64
          conn_id: 23
            state: Waiting for table flush
current_statement: SELECT * FROM world.city WHERE ID = 201
3 rows in set (0.0598 sec)

Listing 18-3Example of waiting for a flush lock

```

该示例使用了`sys.session`视图；使用`performance_schema.threads`和`SHOW PROCESSLIST`可以获得类似的结果。为了减少输出以仅包括与刷新锁讨论相关的查询，当前线程和没有正在进行的查询的线程被过滤掉。

与`conn_id = 21`的连接正在执行一个使用`world.city`表的慢速查询(使用了一个`SLEEP(180)`来确保它花费很长时间)。同时，`conn_id = 22`为`world.city`表执行了一条`FLUSH TABLES`语句。因为第一个查询仍然打开着表(一旦查询完成，它就会被释放)，所以`FLUSH TABLES`语句最终会等待表刷新锁。最后，`conn_id = 23`试图查询表，因此必须等待`FLUSH TABLES`语句。

另一种非数据表锁是元数据锁。

### 元数据锁

元数据锁是 MySQL 中较新的锁类型之一。它们是在 MySQL 5.5 中引入的，它们的目的是保护模式，因此当查询或事务依赖于模式不变时，它不会被改变。元数据锁在表级别工作，但是它们应该被视为独立于表锁的锁类型，因为它们不保护表中的数据。

语句和 DML 查询使用共享元数据锁，而 DDL 语句使用排他锁。当第一次使用表时，连接获取表上的元数据锁，并保持该锁直到事务结束。当持有元数据锁时，不允许其他连接更改表的模式定义。但是，执行`SELECT`语句和 DML 语句的其他连接不受限制。通常，关于元数据锁的最大问题是阻止 DDL 语句开始工作的空闲事务。

如果遇到关于元数据锁定的冲突，您会看到进程列表中的查询状态设置为“等待表元数据锁定”清单 [18-4](#PC4) 中显示了一个包括要设置的查询的例子。

```sql
-- Connection 1
Connection 1> SELECT CONNECTION_ID();
+-----------------+
| CONNECTION_ID() |
+-----------------+
|              21 |
+-----------------+
1 row in set (0.0003 sec)

Connection 1> START TRANSACTION;
Query OK, 0 rows affected (0.0003 sec)

Connection 1> SELECT * FROM world.city WHERE ID = 130\G
*************************** 1\. row ***************************
         ID: 130
       Name: Sydney
CountryCode: AUS
   District: New South Wales
 Population: 3276207
1 row in set (0.0005 sec)

-- Connection 2
Connection 2> SELECT CONNECTION_ID();
+-----------------+
| CONNECTION_ID() |
+-----------------+
|              22 |
+-----------------+
1 row in set (0.0003 sec)

Connection 2> OPTIMIZE TABLE world.city;

-- Connection 3
Connection 3> SELECT thd_id, conn_id, state,
                     current_statement,
                     last_statement
                FROM sys.session
               WHERE conn_id IN (21, 22)\G
*************************** 1\. row ***************************
           thd_id: 61
          conn_id: 21
            state: NULL

current_statement: SELECT * FROM world.city WHERE ID = 130
   last_statement: SELECT * FROM world.city WHERE ID = 130
*************************** 2\. row ***************************
           thd_id: 62

          conn_id: 22
            state: Waiting for table metadata lock
current_statement: OPTIMIZE TABLE world.city
   last_statement: NULL
2 rows in set (0.0549 sec)

Listing 18-4Example of waiting for table metadata lock

```

在本例中，与`conn_id = 21`的连接有一个正在进行的事务，并且在前一条语句中查询了`world.city`表(本例中的当前语句与下一条语句执行之前不会被清除的语句相同)。当事务仍然活跃时，`conn_id = 22`已经执行了一个`OPTIMIZE TABLE`语句，该语句现在正在等待元数据锁定。(是的，`OPTIMIZE TABLE`并没有改变模式定义，但是它作为 DDL 语句仍然受到元数据锁定的影响。)

当导致元数据锁定的是当前或最后一条语句时，这是很方便的。在更一般的情况下，您可以使用将`OBJECT_TYPE`列设置为`TABLE`的`performance_schema.metadata_locks`表来查找授予的和挂起的元数据锁。清单 [18-5](#PC5) 显示了一个使用与前一个例子相同的设置的被授予和挂起的元数据锁的例子。第 [22 章](22.html)详细介绍了元数据锁的研究。

```sql
-- Connection 3
Connection 3> SELECT *
                FROM performance_schema.metadata_locks
               WHERE OBJECT_SCHEMA = 'world'
                     AND OBJECT_NAME = 'city'\G
*************************** 1\. row ***************************
          OBJECT_TYPE: TABLE
        OBJECT_SCHEMA: world
          OBJECT_NAME: city
          COLUMN_NAME: NULL
OBJECT_INSTANCE_BEGIN: 2195760373456
            LOCK_TYPE: SHARED_READ
        LOCK_DURATION: TRANSACTION
          LOCK_STATUS: GRANTED
               SOURCE: sql_parse.cc:6014
      OWNER_THREAD_ID: 61
       OWNER_EVENT_ID: 53
*************************** 2\. row ***************************
          OBJECT_TYPE: TABLE
        OBJECT_SCHEMA: world
          OBJECT_NAME: city
          COLUMN_NAME: NULL
OBJECT_INSTANCE_BEGIN: 2194784109632
            LOCK_TYPE: SHARED_NO_READ_WRITE
        LOCK_DURATION: TRANSACTION
          LOCK_STATUS: PENDING
               SOURCE: sql_parse.cc:6014
      OWNER_THREAD_ID: 62
       OWNER_EVENT_ID: 26
2 rows in set (0.0007 sec)

-- Connection 1
Connection 1> ROLLBACK;
Query OK, 0 rows affected (0.0003 sec)

Listing 18-5Example of metadata locks

```

在这个例子中，由于一个正在进行的事务，线程 id 61(与来自`sys.session`输出的`conn_id = 22`相同)拥有一个对`world.city`表的共享读锁，而线程 id 62 正在等待一个锁，因为它试图在这个表上执行一个 DDL 语句。

元数据锁的一个特例是用`LOCK TABLES`语句显式获取的锁。

### 显式表锁

使用`LOCK TABLES`和`FLUSH TABLES WITH READ LOCK`语句获取显式表锁。使用`LOCK TABLES`语句，可以获取共享锁或独占锁；`FLUSH TABLES WITH READ LOCK`总是使用共享锁。这些表被锁定，直到用`UNLOCK TABLES`语句显式释放它们。当`FLUSH TABLES WITH READ LOCK`在没有列出任何表的情况下被执行时，全局读锁(即，影响所有表)被获取。虽然这些锁也保护数据，但在 MySQL 中它们被视为元数据锁。

除了与备份相关的带读锁的刷新表之外，显式表锁并不经常与 InnoDB 一起使用，因为 InnoDB 复杂的锁特性在大多数情况下都优于自己处理锁。但是，如果您真的需要锁定整个表，显式锁会很有用，因为 MySQL 检查它们非常便宜。

在`world.country`和`world.countrylanguage`表上获取显式读锁并在`world.city`表上获取写锁的连接示例如下

```sql
mysql> LOCK TABLES world.country READ,
                   world.countrylanguage READ,
                   world.city WRITE;
Query OK, 0 rows affected (0.0500 sec)

```

当您使用显式锁时，只允许您根据请求的锁来使用您已经锁定的表。这意味着，如果您获取一个读锁并试图写入表(`ER_TABLE_NOT_LOCKED_FOR_WRITE`)，或者如果您试图使用一个没有获取锁(`ER_TABLE_NOT_LOCKED`)的表，您将会得到一个错误，例如:

```sql
mysql> UPDATE world.country
          SET Population = Population + 1
        WHERE Code = 'AUS';
ERROR: 1099: Table 'country' was locked with a READ lock and can't be updated

mysql> SELECT *
         FROM sakila.film
        WHERE film_id = 1;
ERROR: 1100: Table 'film' was not locked with LOCK TABLES

```

因为显式锁被认为是元数据锁，所以`performance_schema.metadata_locks`表中的症状和信息与隐式元数据锁相同。

另一种隐式处理的表级锁被称为表锁。

### 隐式表锁

当查询一个表时，MySQL 采用隐式表锁。除了刷新、元数据和显式锁之外，表锁对 InnoDB 表没有太大的作用，因为 InnoDB 使用记录锁来允许对表的并发访问，只要事务不修改相同的行(粗略地说——如下一小节所示——还有更多内容)。

然而，InnoDB 确实在表级别使用了意向锁的概念。由于您在研究锁问题时可能会遇到这些问题，因此有必要熟悉一下它们。正如在锁访问级别的讨论中提到的，意图锁标记了事务的意图。如果您使用一个显式的`LOCK TABLES`语句，该表将被您所请求的访问级别直接锁定。

对于由事务获取的锁，首先获取一个意向锁，然后如果需要的话可以升级它。为了获得共享锁，事务首先获取意向共享锁，然后获取共享锁。类似地，对于排他锁，首先采用意图排他锁。意向锁定的一些示例如下:

*   一个`SELECT ... FOR SHARE`语句在被查询的表上获取一个意向共享锁。`SELECT ... LOCK IN SHARE MODE`语法是同义词。

*   一个`SELECT ... FOR UPDATE`语句在被查询的表上获取一个意向排他锁。

*   一个 DML 语句(不包括`SELECT`)在修改后的表上获取一个意向排他锁。如果修改了外键列，就会在父表上获得一个意向共享锁。

两个意向锁总是互相兼容的。这意味着即使一个事务有一个意向排他锁，它也不会阻止另一个事务获取一个意向锁。但是，它将阻止另一个事务将其意向锁升级为完全锁。表 [18-1](#Tab1) 显示了锁类型之间的兼容性。共享锁表示为 S，排他锁表示为 x。意向锁以 I 为前缀，因此 IS 是意向共享锁，IX 是意向排他锁。

表 18-1

InnoDB 锁兼容性

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-center"> <col class="tcol3 align-center"> <col class="tcol4 align-center"> <col class="tcol5 align-center"></colgroup> 
|   | 

独占(X)

 | 

意图排他(九)

 | 

共享的

 | 

共享意向(IS)

 |
| --- | --- | --- | --- | --- |
| **独占(X)** | -什么 | -什么 | -什么 | -什么 |
| **意图排他(IX)** | -什么 | ✔ | -什么 | ✔ |
| **共享** | -什么 | -什么 | ✔ | ✔ |
| **意向共享(是)** | -什么 | ✔ | ✔ | ✔ |

在该表中，复选标记表示这两种锁兼容，而叉号表示这两种锁相互冲突。唯一的意向冲突锁是独占锁和共享锁。排他锁与所有其他锁冲突，包括两种意向锁类型。共享锁只与排他锁和意图排他锁冲突。

为什么意向锁甚至是必要的？它们允许 InnoDB 在不阻塞兼容操作的情况下按顺序解决锁定请求。细节超出了本次讨论的范围。重要的是你知道意向锁的存在，所以当你看到它们时，你知道它们来自哪里。

可以在`LOCK_TYPE`列设置为`TABLE`的`performance_schema.data_locks`表中找到表级锁。清单 [18-6](#PC8) 展示了一个意向共享锁的例子。

```sql
-- Connection 1
Connection 1> START TRANSACTION;
Query OK, 0 rows affected (0.0003 sec)

Connection 1> SELECT *
                FROM world.city
               WHERE ID = 130
                 FOR SHARE;
Query OK, 1 row affected (0.0010 sec)

-- Connection 2
Connection 2> SELECT *
                FROM performance_schema.data_locks
               WHERE LOCK_TYPE = 'TABLE'\G
*************************** 1\. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2195098223824:1720:2195068346872
ENGINE_TRANSACTION_ID: 283670074934480
            THREAD_ID: 61
             EVENT_ID: 81
        OBJECT_SCHEMA: world
          OBJECT_NAME: city
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: NULL
OBJECT_INSTANCE_BEGIN: 2195068346872
            LOCK_TYPE: TABLE
            LOCK_MODE: IS
          LOCK_STATUS: GRANTED
            LOCK_DATA: NULL
1 row in set (0.0354 sec)

-- Connection 1
Connection 1> ROLLBACK;
Query OK, 0 rows affected (0.0003 sec)

Listing 18-6Example of an InnoDB intention shared lock

```

这显示了一个在`world.city`表上的意向共享锁。注意，`ENGINE`被设置为`INNODB`，而`LOCK_DATA`为`NULL`。如果执行相同的查询，`ENGINE_LOCK_ID`、`ENGINE_TRANSACTION_ID`和`OBJECT_INSTANCE_BEGIN`列的值将会不同。

如前所述，InnoDB 的主要访问级别保护是在记录级别，所以让我们看看那些。

### 记录锁

记录锁通常被称为行锁；但是，它不仅仅是行上的锁，因为它还包括索引和间隙锁。当谈到 InnoDB 锁时，这些通常是指的锁。它们是细粒度的锁，旨在锁定最少量的数据，同时仍然确保数据的完整性。

记录锁可以是共享的，也可以是排他的，并且只影响事务访问的行和索引。排他锁的持续时间通常是有例外的事务，例如，被删除标记的记录用于在`INSERT INTO ... ON DUPLICATE KEY`和`REPLACE`语句中进行唯一性检查。对于共享锁，持续时间可能取决于事务隔离级别，如“减少锁定问题”一节中的“事务隔离级别”所述

可以使用`performance_schema.data_locks`表找到记录锁，该表也用于在表级别找到意图锁。清单 [18-7](#PC9) 展示了一个使用二级索引`CountryCode`更新`world.city`表中的行的锁的例子。

```sql
-- Connection 1
Connection 1> START TRANSACTION;
Query OK, 0 rows affected (0.0003 sec)

Connection 1> UPDATE world.city
                 SET Population = Population + 1
               WHERE CountryCode = 'LUX';
Query OK, 1 row affected (0.0009 sec)

Rows matched: 1  Changed: 1  Warnings: 0

-- Connection 2
Connection 2> SELECT *
                FROM performance_schema.data_locks\G
*************************** 1\. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2195098223824:1720:2195068346872
ENGINE_TRANSACTION_ID: 117114
            THREAD_ID: 61
             EVENT_ID: 121
        OBJECT_SCHEMA: world

          OBJECT_NAME: city
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: NULL
OBJECT_INSTANCE_BEGIN: 2195068346872
            LOCK_TYPE: TABLE
            LOCK_MODE: IX
          LOCK_STATUS: GRANTED
            LOCK_DATA: NULL
*************************** 2\. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2195098223824:507:30:1112:2195068344088
ENGINE_TRANSACTION_ID: 117114
            THREAD_ID: 61
             EVENT_ID: 121
        OBJECT_SCHEMA: world
          OBJECT_NAME: city
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: CountryCode
OBJECT_INSTANCE_BEGIN: 2195068344088
            LOCK_TYPE: RECORD
            LOCK_MODE: X
          LOCK_STATUS: GRANTED
            LOCK_DATA: 'LUX', 2452
*************************** 3\. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2195098223824:507:20:113:2195068344432
ENGINE_TRANSACTION_ID: 117114
            THREAD_ID: 61
             EVENT_ID: 121
        OBJECT_SCHEMA: world
          OBJECT_NAME: city
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: PRIMARY
OBJECT_INSTANCE_BEGIN: 2195068344432
            LOCK_TYPE: RECORD
            LOCK_MODE: X,REC_NOT_GAP
          LOCK_STATUS: GRANTED
            LOCK_DATA: 2452
*************************** 4\. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2195098223824:507:30:1113:2195068344776
ENGINE_TRANSACTION_ID: 117114
            THREAD_ID: 61
             EVENT_ID: 121
        OBJECT_SCHEMA: world
          OBJECT_NAME: city
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: CountryCode
OBJECT_INSTANCE_BEGIN: 2195068344776
            LOCK_TYPE: RECORD

            LOCK_MODE: X,GAP
          LOCK_STATUS: GRANTED
            LOCK_DATA: 'LVA', 2434
4 rows in set (0.0005 sec)

-- Connection 1
Connection 1> ROLLBACK;
Query OK, 0 rows affected (0.0685 sec)

Listing 18-7Example of InnoDB record locks

```

第一行是已经讨论过的意图排他表锁。第二行是值(' LUX '，2452)在`CountryCode`索引上的 next-key 锁(更简短)，其中' LUX '是在`WHERE`子句中使用的国家代码，2452 是添加到非唯一二级索引的主键 id。带有`ID = 2452`的城市是唯一匹配`WHERE`子句的城市，主键记录(行本身)显示在输出的第三行。锁定模式是`X,REC_NOT_GAP`，这意味着它是记录上的排他锁，而不是间隙上的排他锁。

什么是差距？输出的第四行显示了一个示例。间隙锁如此重要，以至于关于间隙锁的讨论被分成单独的部分。

### 间隙锁、下一键锁和谓词锁

间隙锁保护两条记录之间的空间。这可以在聚集索引的行中，也可以在辅助索引中。在索引页中的第一条记录之前和最后一条记录之后，分别有称为下确界记录和上确界记录的伪记录。间隙锁通常是最容易引起混淆的锁类型。研究锁问题的经验是熟悉它们的最好方法。

考虑前面示例中的查询:

```sql
UPDATE world.city
   SET Population = Population + 1
 WHERE CountryCode = 'LUX';

```

该查询更改所有带有`CountryCode = 'LUX'`的城市的人口。如果在事务的更新和提交之间插入一个新的城市，会发生什么情况？如果`UPDATE`和`INSERT`语句提交的顺序与它们执行的顺序相同，一切都没问题。但是，如果以相反的顺序提交更改，结果将会不一致，因为预计插入的行也将被更新。

这就是间隙锁发挥作用的地方。它保护插入新记录(包括从不同位置移动的记录)的空间，因此在持有间隙锁的事务完成之前，它不会被更改。如果您查看清单 [18-7](#PC9) 中示例的输出中第四行的最后几列，您可以看到一个间隙锁的示例:

```sql
           INDEX_NAME: CountryCode
OBJECT_INSTANCE_BEGIN: 2195068344776
            LOCK_TYPE: RECORD
            LOCK_MODE: X,GAP
          LOCK_STATUS: GRANTED
            LOCK_DATA: 'LVA', 2434

```

这是值(' LVA '，2434)的`CountryCode`索引上的独占间隙锁。由于该查询请求更新所有将`CountryCode`设置为“LUX”的行，间隙锁确保没有为“LUX”国家代码插入新行。国家代码“LVA”是`CountryCode`索引中的下一个值，因此“勒克司”和“LVA”之间的差距受到独占锁的保护。另一方面，用`CountryCode = 'LVA'`插入新城市还是有可能的。在某些地方，这被称为“记录前间隙”,这样更容易理解间隙锁是如何工作的。

当您使用`READ COMMITTED`事务隔离级别而不是`REPEATABLE READ`或`SERIALIZABLE`时，间隙锁被采用的程度要小得多。这将在“减少锁定问题”一节中的“事务隔离级别”中进一步讨论

与间隙锁相关的是下一键锁和谓词锁。下一键锁是记录锁和记录前间隙上的间隙锁的组合。这实际上是 InnoDB 中的默认锁类型，因此在锁输出中您只会看到它是`S`和`X`。在本小节和上一小节讨论的示例中，值(' LUX '，2452)的`CountryCode`索引上的锁及其之前的间隙是下一个键锁的示例。来自`performance_schema.data_locks`表的清单 [18-7](#PC9) 中输出的相关部分是

```sql
*************************** 2\. row ***************************
           INDEX_NAME: CountryCode
            LOCK_TYPE: RECORD
            LOCK_MODE: X
          LOCK_STATUS: GRANTED
            LOCK_DATA: 'LUX', 2452
*************************** 3\. row ***************************
           INDEX_NAME: PRIMARY
            LOCK_TYPE: RECORD
            LOCK_MODE: X,REC_NOT_GAP
          LOCK_STATUS: GRANTED
            LOCK_DATA: 2452
*************************** 4\. row ***************************
           INDEX_NAME: CountryCode
            LOCK_TYPE: RECORD
            LOCK_MODE: X,GAP
          LOCK_STATUS: GRANTED
            LOCK_DATA: 'LVA', 2434

```

概括一下，第 2 行是下一个键锁，第 3 行是主键(行)上的记录锁，第 4 行是“LUX”和“LVA”之间的间隙锁(或者是 LVA 之前的间隙锁)。

谓词锁类似于间隙锁，但它适用于无法进行绝对排序的空间索引，因此间隙锁没有意义。对于`REPEATABLE READ`和`SERIALIZABLE`事务隔离级别中的空间索引，InnoDB 在用于查询的最小边界矩形(MBR)上创建了一个谓词锁，而不是间隙锁。这将通过防止对最小边界矩形内的数据进行更改来实现一致的读取。

您应该知道的与记录相关的最后一种锁类型是插入意图锁。

### 插入意向锁

请记住，对于表锁，InnoDB 有意向锁，决定事务是以共享还是独占的方式使用表。类似地，InnoDB 在记录级别有插入意图锁。InnoDB 使用这些锁——顾名思义——和`INSERT`语句向其他事务发出信号。因此，锁是在一个尚未创建的记录上(因此它是一个间隙锁)，而不是在一个现有的记录上。使用插入意图锁有助于提高执行插入的并发性。

您不太可能在锁输出中看到插入意图锁，除非一个`INSERT`语句正在等待一个锁被授予。您可以通过在另一个事务中创建一个间隙锁来阻止`INSERT`语句完成，从而强制出现这种情况。清单 [18-8](#PC13) 中的例子在连接 1 中创建了一个间隙锁，然后在连接 2 中试图插入一个与间隙锁冲突的行。最后，在第三个连接中，检索锁信息。

```sql
-- Connection 1
Connection 1> START TRANSACTION;
Query OK, 0 rows affected (0.0004 sec)

Connection 1> SELECT *
                FROM world.city
               WHERE ID > 4079
                 FOR UPDATE;
Empty set (0.0009 sec)

-- Connection 2
Connection 2> SELECT PS_CURRENT_THREAD_ID();
+------------------------+
| PS_CURRENT_THREAD_ID() |
+------------------------+
|                     62 |
+------------------------+
1 row in set (0.0003 sec)

Connection 2> START TRANSACTION;
Query OK, 0 rows affected (0.0003 sec)

Connection 2> INSERT INTO world.city
              VALUES (4080, 'Darwin', 'AUS',
                      'Northern Territory', 146000);

-- Connection 3
Connection 3> SELECT *
                FROM performance_schema.data_locks
               WHERE THREAD_ID = 62\G
*************************** 1\. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2195098220336:1720:2195068326968
ENGINE_TRANSACTION_ID: 117144
            THREAD_ID: 62
             EVENT_ID: 119
        OBJECT_SCHEMA: world

          OBJECT_NAME: city
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: NULL
OBJECT_INSTANCE_BEGIN: 2195068326968
            LOCK_TYPE: TABLE
            LOCK_MODE: IX
          LOCK_STATUS: GRANTED
            LOCK_DATA: NULL
*************************** 2\. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2195098220336:507:29:1:2195068320072
ENGINE_TRANSACTION_ID: 117144
            THREAD_ID: 62
             EVENT_ID: 119
        OBJECT_SCHEMA: world
          OBJECT_NAME: city
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: PRIMARY
OBJECT_INSTANCE_BEGIN: 2195068320072
            LOCK_TYPE: RECORD
            LOCK_MODE: X,INSERT_INTENTION
          LOCK_STATUS: WAITING
            LOCK_DATA: supremum pseudo-record
2 rows in set (0.0005 sec)

-- Connection 1
Connection 1> ROLLBACK;
Query OK, 0 rows affected (0.0004 sec)

-- Connection 2
Connection 2> ROLLBACK;
Query OK, 0 rows affected (0.0004 sec)

Listing 18-8Example of an insert intention lock

```

连接 2 的性能模式线程 id 为 62，因此在连接 3 中，可以只查询该线程并排除连接 1 获取的锁。注意对于`RECORD`锁，锁模式包括`INSERT_INTENTION`——插入意图锁。在这种情况下，锁定的数据是上确界伪记录，但根据具体情况，它也可以是主键的值。如果您还记得下一个键锁的讨论，那么`X`意味着下一个键锁，但是这是一个特例，因为锁是在上确界伪记录上，并且不可能锁定它，所以实际上它只是上确界伪记录之前的间隙上的间隙锁。

插入数据时需要注意的另一个锁是自动增量锁。

### 自动增量锁

当您将数据插入到具有自动递增计数器的表中时，有必要保护计数器，以便保证两个事务获得唯一的值。如果对二进制日志使用基于语句的日志记录，则会有进一步的限制，因为在重播语句时，将为除第一行之外的所有行重新创建自动增量值。

InnoDB 支持三种锁定模式，因此您可以根据需要调整锁定量。使用`innodb_autoinc_lock_mode`选项选择锁定模式，该选项取值为 0、1 和 2，MySQL 8 中的默认值为 2。它需要重新启动 MySQL 来改变这个值。表 [18-2](#Tab2) 中总结了这些值的含义。

表 18-2

innodb_autoinc_lock_mode 选项的支持值

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

价值

 | 

方式

 | 

描述

 |
| --- | --- | --- |
| Zero | 传统的 | MySQL 5.0 及更早版本的锁定行为。锁一直保持到语句结束，所以值是以可重复的连续顺序赋值的。 |
| one | 连续的 | 对于查询开始时行数已知的`INSERT`语句，所需数量的自动增量值被分配在一个轻量级互斥体下，并且避免了自动增量锁。对于行数未知的语句，自动增量锁被获取并保持到语句结束。这是 MySQL 5.7 和更早版本的默认设置。 |
| Two | 插入纸 | 自动增量锁永远不会被占用，并发插入的自动增量值可能是交错的。只有当二进制记录被禁用或`binlog_format`被设置为`ROW`时，该模式才是安全的。它是 MySQL 8 中的默认值。 |

`innodb_autoinc_lock_mode`值越高，锁定越少。为此付出的代价是增加自动增量值序列中的间隙数量，以及`innodb_autoinc_lock_mode = 2`交错值的可能性。除非不能使用基于行的二进制日志记录，或者对连续的自动增量值有特殊需求，否则建议使用值 2。

对用户级锁、元数据锁和数据级锁的讨论到此结束。您应该知道一些与备份相关的其他锁。

### 备用锁

备份锁是实例级锁；也就是说，它影响整个系统。它是 MySQL 8 中引入的新锁。备份锁防止可能导致备份不一致的语句，同时仍然允许其他语句与备份同时执行。被阻止的语句包括

*   创建、重命名或删除文件的语句。这包括`CREATE TABLE`、`CREATE TABLESPACE`、`RENAME TABLE`和`DROP TABLE`语句。

*   `CREATE USER`、`ALTER USER`、`DROP USER`、`GRANT`等账户管理报表。

*   不将其更改记录到重做日志中的 DDL 语句。例如，这包括添加索引。

用`LOCK INSTANCE FOR BACKUP`语句创建备份锁，用`UNLOCK INSTANCE`语句释放锁。执行`LOCK INSTANCE FOR BACKUP`需要`BACKUP_ADMIN`权限。获取备份锁并再次释放它的一个示例是

```sql
mysql> LOCK INSTANCE FOR BACKUP;
Query OK, 0 rows affected (0.00 sec)

mysql> UNLOCK INSTANCE;
Query OK, 0 rows affected (0.00 sec)

```

Note

在编写时，使用 X 协议(通过用`mysqlx_port`指定的端口或用`mysqlx_socket`指定的套接字连接)时，不允许获取备份锁并释放它。尝试这样做将返回一个`ER_PLUGGABLE_PROTOCOL_COMMAND_NOT_SUPPORTED`错误:`ERROR: 3130: Command not supported by pluggable protocols`。

此外，与备份锁冲突的语句也会使用备份锁。由于 DDL 语句有时由几个步骤组成，例如，在新文件中重建一个表并重命名文件，备份锁可以在这些步骤之间释放，以避免阻塞`LOCK INSTANCE FOR BACKUP`超过必要的时间。

备份锁可以在`performance_schema.metadata_locks`表中找到，其中`OBJECT_TYPE`列设置为`BACKUP LOCK`。清单 [18-9](#PC15) 显示了一个查询等待`LOCK INSTANCE FOR BACKUP`持有的备份锁的例子。

```sql
-- Connection 1
Connection 1> LOCK INSTANCE FOR BACKUP;
Query OK, 0 rows affected (0.00 sec)

-- Connection 2
Connection 2> OPTIMIZE TABLE world.city;

-- Connection 3
Connection 3> SELECT *
                FROM performance_schema.metadata_locks
               WHERE OBJECT_TYPE = 'BACKUP LOCK'\G
*************************** 1\. row ***************************
          OBJECT_TYPE: BACKUP LOCK
        OBJECT_SCHEMA: NULL
          OBJECT_NAME: NULL
          COLUMN_NAME: NULL
OBJECT_INSTANCE_BEGIN: 2520402231312
            LOCK_TYPE: SHARED
        LOCK_DURATION: EXPLICIT
          LOCK_STATUS: GRANTED
               SOURCE: sql_backup_lock.cc:101
      OWNER_THREAD_ID: 49
       OWNER_EVENT_ID: 8
*************************** 2\. row ***************************
          OBJECT_TYPE: BACKUP LOCK
        OBJECT_SCHEMA: NULL
          OBJECT_NAME: NULL
          COLUMN_NAME: NULL
OBJECT_INSTANCE_BEGIN: 2520403183328
            LOCK_TYPE: INTENTION_EXCLUSIVE
        LOCK_DURATION: TRANSACTION
          LOCK_STATUS: PENDING
               SOURCE: sql_base.cc:5400
      OWNER_THREAD_ID: 60
       OWNER_EVENT_ID: 19
2 rows in set (0.0007 sec)

-- Connection 1
Connection 1> UNLOCK INSTANCE;
Query OK, 0 rows affected (0.00 sec)

Listing 18-9Example of a conflict for the backup lock

```

在本例中，线程 id 为 49 的连接拥有备份锁，而线程 id 为 60 的连接正在等待它。注意`LOCK INSTANCE FOR BACKUP`持有一个共享锁，而 DDL 语句请求一个意向排他锁。

与备份锁相关的是日志锁，它的引入也是为了减少备份过程中的锁定。

### 日志锁

创建备份时，您通常希望包括与备份一致的日志位置的相关信息。在 MySQL 5.7 和更早的版本中，在获取这些信息时需要全局读锁。在 MySQL 8 中，引入了日志锁，允许您在不使用全局读锁的情况下读取 InnoDB 的信息，如执行的全局事务标识符(GTIDs)、二进制日志位置和日志序列号(LSN)。

日志锁防止对日志相关信息进行更改的操作。实际上，这意味着提交、`FLUSH LOGS`等等。日志锁是通过查询`performance_schema.log_status`表隐式获取的。它需要`BACKUP_ADMIN`特权来访问表。清单 [18-10](#PC16) 显示了`log_status`表的输出示例。

```sql
mysql> SELECT *
         FROM performance_schema.log_status\G
*************************** 1\. row ***************************
    SERVER_UUID: 59e3f95b-e0d6-11e8-94e8-ace2d35785be
          LOCAL: {"gtid_executed": "59e3f95b-e0d6-11e8-94e8-ace2d35785be:1-5343", "binary_log_file": "mysql-bin.000033", "binary_log_position": 3874615}
    REPLICATION: {"channels": []}
STORAGE_ENGINES: {"InnoDB": {"LSN": 7888992157, "LSN_checkpoint": 7888992157}}
1 row in set (0.0004 sec)

Listing 18-10Example output of the log_status table

```

对 MySQL 中主要锁类型的回顾到此结束。当一个查询请求一个锁，但是不能被授予时会发生什么？让我们考虑一下。

## 无法获得锁

锁的整体思想是限制对对象或记录的访问，以避免并发执行的冲突操作。这意味着有时锁不能被授予。那种情况下会发生什么？这取决于请求的锁和环境。元数据锁(包括显式请求的表锁)操作超时。InnoDB 记录锁支持超时和显式死锁检测。

Note

确定两个锁是否相互兼容非常复杂。这变得特别有趣，因为这种关系是不对称的，也就是说，一个锁可以在另一个锁存在时被允许，但反之则不行。例如，插入意图锁必须等待间隙锁，但是间隙锁不必等待插入意图锁。另一个例子(缺乏传递性)是间隙加记录锁必须等待仅记录锁，插入意图锁必须等待间隙加记录锁，但是插入意图锁不需要等待仅记录锁。

使用数据库时，无法获得锁是不可避免的，理解这一点很重要。原则上，您可以使用非常粗粒度的锁并避免失败的锁，除非超时——这就是 MyISAM 存储引擎在写入并发性非常差的情况下所做的事情。然而，在实践中，考虑到写工作负载的高并发性，细粒度锁是首选，这也引入了死锁的可能性。

结论是，您应该始终让您的应用准备好重试获取锁或优雅地失败。无论是显式锁还是隐式锁，这都适用。

Tip

总是准备好处理失败以获得锁。无法获得锁并不是一个灾难性的错误，通常不应该被认为是一个 bug。也就是说，正如“减少锁定问题”一节中所讨论的，在开发应用时，有一些减少锁争用的技术值得考虑。

本章的其余部分将讨论表级超时、记录级超时和 InnoDB 死锁的细节。

### 元数据和备份锁等待超时

当您请求刷新、元数据或备份锁时，获取锁的尝试将在`lock_wait_timeout`秒后超时。默认超时是 31536000 秒(365 天)。您可以在全局和会话范围内动态设置`lock_wait_timeout`选项，这允许您根据给定流程的特定需求调整超时。

当超时发生时，语句失败，出现错误`ER_LOCK_WAIT_TIMEOUT`(错误号 1205)。例如:

```sql
mysql> LOCK TABLES world.city WRITE;
ERROR: 1205: Lock wait timeout exceeded; try restarting transaction

```

`lock_wait_timeout`选项的推荐设置取决于应用的要求。使用较小的值来防止锁请求长时间阻塞其他查询可能是一个优势。这通常需要您实现对锁请求失败的处理，例如，通过重试该语句。另一方面，较大的值有助于避免重试该语句。对于`FLUSH TABLES`语句，还要记住它与低级表定义缓存(TDC)版本锁交互，这可能意味着放弃该语句不允许后续查询继续进行。在这种情况下，最好为`lock_wait_timeout`设置一个较高的值，以便更清楚地了解锁的关系。

### InnoDB 锁等待超时

当查询请求 InnoDB 中的记录级锁时，它会超时，类似于刷新、元数据和备份锁的超时。由于记录级锁争用比表级锁争用更常见，并且记录级锁增加了死锁的可能性，因此超时默认为 50 秒。它可以使用`innodb_lock_wait_timeout`选项进行设置，该选项可以针对全局和会话范围进行设置。

当超时发生时，查询失败，并出现`ER_LOCK_WAIT_TIMEOUT`错误(错误号 1205 ),就像表级锁超时一样。清单 [18-11](#PC18) 展示了一个发生 InnoDB 锁等待超时的例子。

```sql
-- Connection 1
Connection 1> START TRANSACTION;
Query OK, 0 rows affected (0.0003 sec)

Connection 1> UPDATE world.city
                 SET Population = Population + 1
               WHERE ID = 130;
Query OK, 1 row affected (0.0005 sec)

Rows matched: 1  Changed: 1  Warnings: 0

-- Connection 2
Connection 2> SET SESSION innodb_lock_wait_timeout = 3;
Query OK, 0 rows affected (0.0004 sec)

Connection 2> UPDATE world.city
                 SET Population = Population + 1
               WHERE ID = 130;
ERROR: 1205: Lock wait timeout exceeded; try restarting transaction

-- Connection 1
Connection 1> ROLLBACK;
Query OK, 0 rows affected (0.0003 sec)

Listing 18-11Example of an InnoDB lock wait timeout

```

在本例中，连接 2 的锁等待超时设置为 3 秒，因此没有必要等待通常的 50 秒超时。

当超时发生时，`innodb_rollback_on_timeout`选项定义了事务完成的工作有多少被回滚。当`innodb_rollback_on_timeout`被禁用时(默认)，只有触发超时的语句被回滚。启用该选项后，整个事务将回滚。`innodb_rollback_on_timeout`选项只能在全局级别配置，并且需要重启才能更改值。

Caution

处理锁等待超时是非常重要的，否则它可能会使事务带有未释放的锁。如果发生这种情况，其他事务可能无法获得它们需要的锁。

一般情况下，建议将 InnoDB 记录级锁的超时值保持在较低水平。通常，最好降低默认值 50 秒。允许查询等待锁的时间越长，其他锁请求受影响的可能性就越大，这也可能导致其他查询停止。这也使得死锁更有可能发生。如果您禁用死锁检测(接下来将讨论)，您应该为`innodb_lock_wait_timeout`使用一个非常小的值，比如一秒或两秒，因为您将使用超时来检测死锁。如果没有死锁检测，也建议启用`innodb_rollback_on_timeout`选项。

### 僵局

死锁听起来是一个非常可怕的概念，但是你不应该让这个名字吓住你。就像锁等待超时一样，死锁是高并发数据库世界中的现实。它真正的意思是锁请求之间存在循环关系。解决僵局的唯一方法是强制放弃其中一个请求。从这个意义上说，死锁与锁等待超时没有什么不同。事实上，您可以禁用死锁检测，在这种情况下，其中一个锁将以锁等待超时结束。

那么，如果不是真正需要的话，为什么会有死锁呢？因为当锁请求之间存在循环关系时会出现死锁，所以 InnoDB 可以在循环完成后立即检测到死锁。这允许 InnoDB 立即告诉用户发生了死锁，而不必等待锁等待超时。告知发生了死锁也是有用的，因为这通常提供了改进应用中数据访问的机会。因此，您应该将死锁视为朋友，而不是敌人。图 [18-1](#Fig1) 显示了两个事务查询一个导致死锁的表的例子。

![img/484666_1_En_18_Fig1_HTML.png](img/484666_1_En_18_Fig1_HTML.png)

图 18-1

导致死锁的两个事务的示例

在本例中，事务 1 首先用`ID = 130`更新行，然后用`ID = 3805`更新行。在此期间，事务 2 首先用`ID = 3805`更新行，然后用`ID = 130`更新行。这意味着当事务 1 试图更新`ID = 3805`时，事务 2 已经锁定了该行。事务 2 也无法继续，因为它无法锁定`ID = 130`，因为事务 1 已经持有该锁。这是一个简单死锁的典型例子。图 [18-2](#Fig2) 中也显示了环锁关系。

![img/484666_1_En_18_Fig2_HTML.png](img/484666_1_En_18_Fig2_HTML.png)

图 18-2

导致死锁的锁的循环关系

在该图中，事务 1 和事务 2 持有哪个锁，请求哪个锁，以及如果没有干预，冲突如何永远无法解决，这一点很清楚。这使得它有资格成为一个僵局。

在现实世界中，死锁往往更加复杂。在这里讨论的例子中，只涉及到主键记录锁。一般来说，通常还包括二级钥匙、间隙锁和其他可能的锁类型。也可能涉及两个以上的事务。然而，原则是一样的。

Note

对于两个事务中的每一个，即使只有一个查询，也会发生死锁。如果一个查询按升序读取记录，而另一个按降序读取记录，则可能会出现死锁。

当死锁发生时，InnoDB 选择“工作最少”的事务成为受害者。您可以检查`information_schema.INNODB_TRX`视图中的`trx_weight`列，查看 InnoDB 使用的权重(完成的工作越多，权重越高)。实际上，这意味着持有最少锁的事务将被回滚。当这种情况发生时，事务中被选作牺牲品的查询失败，并返回错误`ER_LOCK_DEADLOCK`(错误代码 1213)，事务被回滚以释放尽可能多的锁。清单 [18-12](#PC19) 中显示了一个发生死锁的例子。

```sql
-- Connection 1
Connection 1> START TRANSACTION;
Query OK, 0 rows affected (0.0003 sec)

Connection 1> UPDATE world.city
                 SET Population = Population + 1
               WHERE ID = 130;
Query OK, 1 row affected (0.0006 sec)

Rows matched: 1  Changed: 1  Warnings: 0

-- Connection 2
Connection 2> START TRANSACTION;
Query OK, 0 rows affected (0.0003 sec)

Connection 2> UPDATE world.city
                 SET Population = Population + 1
               WHERE ID = 3805;
Query OK, 1 row affected (0.0006 sec)

Rows matched: 1  Changed: 1  Warnings: 0

Connection 2> UPDATE world.city
                 SET Population = Population + 1
               WHERE ID = 130;

-- Connection 1
Connection 1> UPDATE world.city
                 SET Population = Population + 1
               WHERE ID = 3805;
ERROR: 1213: Deadlock found when trying to get lock; try restarting transaction

Connection 1> ROLLBACK;
Query OK, 0 rows affected (0.0438 sec)

-- Connection 2
Connection 2> ROLLBACK;
Query OK, 0 rows affected (0.0438 sec)

Listing 18-12Example of a deadlock

```

在大多数情况下，自动死锁检测对于避免查询延迟过长时间是非常有用的。不过死锁检测不是免费的。对于具有非常高的查询并发性的 MySQL 实例，查找死锁的成本会变得很高，您最好禁用死锁检测，这是通过将`innodb_deadlock_detect`选项设置为`OFF`来完成的。也就是说，在 MySQL 8.0.18 和更高版本中，死锁检测被移到了一个专用的后台线程中，从而提高了性能。

如果您确实禁用了死锁检测，建议将`innodb_lock_wait_timeout`设置为一个非常低的值，比如一秒钟，以便快速检测锁争用。此外，启用`innodb_rollback_on_timeout`选项以确保锁被释放。

既然您已经了解了锁是如何工作的以及锁请求是如何失败的，那么您需要考虑如何减少锁的影响。

## 减少锁定问题

当您编写应用并为其数据和访问设计模式时，记住锁是很重要的。减少锁定的策略包括添加索引、更改事务隔离级别和抢先锁定。

Tip

不要被优化锁冲昏了头脑。如果只是偶尔遇到锁等待超时和死锁，通常最好重试查询或事务，而不是花时间来避免这个问题。多频繁取决于您的工作负载，但是对于许多应用来说，每小时重试几次不是问题。

### 事务规模和年龄

减少锁问题的一个重要策略是保持您的事务较小，并避免使事务打开的时间超过必要时间的延迟。锁问题最常见的原因是事务修改了大量的行，或者事务的活动时间超过了必要的时间。

事务的大小是事务所做的工作量，尤其是它占用的锁的数量，但是事务执行所花费的时间也很重要。正如本讨论中的一些其他主题将会提到的，您可以通过索引和事务隔离级别来部分地降低影响。然而，记住总体结果也很重要。如果您需要修改许多行，问问自己是否可以将工作分成更小的批，或者要求所有工作都在同一个事务中完成。也可以将一些准备工作分离出来，在主事务之外完成。

事务的持续时间也很重要。一个常见的问题是使用`autocommit = 0`的连接。每次在没有活动事务的情况下执行一个查询(包括`SELECT`)时，都会启动一个新的事务，直到执行一个显式的`COMMIT`或`ROLLBACK`(或者连接关闭)，事务才会完成。一些连接器默认禁用自动提交，因此您可能在没有意识到的情况下使用这种模式，这可能会错误地让事务打开几个小时。

Tip

启用`autocommit`选项，除非您有特定的理由禁用它。当您启用自动提交时，InnoDB 还可以为许多`SELECT`查询检测出它是一个只读事务，并减少查询的开销。

另一个缺陷是在事务活动时启动事务并在应用中执行缓慢的操作。这可以是发送回用户的数据、交互式提示或文件 I/O。确保在 MySQL 中没有打开活动事务时执行这些缓慢的操作。

### 索引

索引减少了访问给定行所需的工作量。这样，索引是减少锁定的一个很好的工具，因为只有在执行查询时访问的记录才会被锁定。

考虑一个简单的例子，在`world.city`表中查询名为 Sydney 的城市:

```sql
START TRANSACTION;

SELECT *
  FROM world.city
 WHERE Name = 'Sydney'
   FOR SHARE;

```

`FOR SHARE`选项用于强制查询对读取的记录使用共享锁。默认情况下,`Name`列上没有索引，因此查询将执行全表扫描来查找结果中需要的行。如果没有索引，则有 4103 个记录锁(有些是重复的):

```sql
mysql> SELECT INDEX_NAME, LOCK_TYPE,
              LOCK_MODE, COUNT(*)
         FROM performance_schema.data_locks
        WHERE OBJECT_SCHEMA = 'world'
              AND OBJECT_NAME = 'city'
        GROUP BY INDEX_NAME, LOCK_TYPE, LOCK_MODE;
+------------+-----------+-----------+----------+
| INDEX_NAME | LOCK_TYPE | LOCK_MODE | COUNT(*) |
+------------+-----------+-----------+----------+
| NULL       | TABLE     | IS        |        1 |
| PRIMARY    | RECORD    | S         |     4103 |
+------------+-----------+-----------+----------+
2 rows in set (0.0210 sec)

```

如果在`Name`列上添加一个索引，锁计数将减少到总共三个记录锁:

```sql
mysql> SELECT INDEX_NAME, LOCK_TYPE,
              LOCK_MODE, COUNT(*)
         FROM performance_schema.data_locks
        WHERE OBJECT_SCHEMA = 'world'
              AND OBJECT_NAME = 'city'
        GROUP BY INDEX_NAME, LOCK_TYPE, LOCK_MODE;
+------------+-----------+---------------+----------+
| INDEX_NAME | LOCK_TYPE | LOCK_MODE     | COUNT(*) |
+------------+-----------+---------------+----------+
| NULL       | TABLE     | IS            |        1 |
| Name       | RECORD    | S             |        1 |
| PRIMARY    | RECORD    | S,REC_NOT_GAP |        1 |
| Name       | RECORD    | S,GAP         |        1 |
+------------+-----------+---------------+----------+
4 rows in set (0.0005 sec)

```

另一方面，更多的索引提供了更多访问相同行的方法，这可能会增加死锁的数量。

### 记录访问顺序

确保您尽可能多地以相同的顺序访问不同事务的记录。在本章前面讨论的死锁示例中，导致死锁的原因是两个事务以相反的顺序访问行。如果它们以相同的顺序访问这些行，就不会出现死锁。当您访问不同表中的记录时，这也适用。

确保相同的访问顺序绝非易事。当您执行连接并且优化器为两个查询决定不同的连接顺序时，甚至可能发生不同的访问顺序。如果不同的连接顺序导致过多的锁问题，您可以考虑使用第 [17](17.html) 章中描述的优化器提示来告诉优化器改变连接顺序，但是在这种情况下，您当然也应该考虑查询性能。

### 事务隔离级别

InnoDB 支持几种事务隔离级别。不同的隔离级别有不同的锁需求:特别是`REPEATABLE READ`和`SERIALIZABLE`比`READ COMMITTED`需要更多的锁。

`READ COMMITTED`事务隔离级别可以从两个方面帮助解决锁定问题。使用的间隙锁要少得多，并且在 DML 语句期间被访问但未被修改的行在语句完成后会再次释放它们的锁。对于`REPEATABLE READ`和`SERIALIZABLE`，锁仅在事务结束时释放。

Note

人们常说`READ COMMITTED`事务隔离级别不采用间隙锁。这是一个神话，是不正确的。虽然使用的间隙锁要少得多，但仍然需要一些。例如，这包括 InnoDB 在更新时执行页面分割。(页面分割将在第 [25 章](25.html)中讨论。)

考虑一个例子，其中使用`CountryCode`列将查询限制在一个国家，名为 Sydney 的城市的人口发生了变化。这可以通过以下查询来完成:

```sql
START TRANSACTION;

UPDATE world.city
   SET Population = 5000000
 WHERE Name = 'Sydney'
       AND CountryCode = 'AUS';

```

在`Name`列上没有索引，但是在`CountryCode`上有一个。所以更新需要扫描部分`CountryCode`索引。清单 [18-13](#PC24) 展示了一个在`REPEATABLE READ`事务隔离级别执行查询的例子。

```sql
-- Connection 1
Connection 1> SET transaction_isolation = 'REPEATABLE-READ';
Query OK, 0 rows affected (0.0003 sec)

Connection 1> START TRANSACTION;
Query OK, 0 rows affected (0.0003 sec)

Connection 1> UPDATE world.city
                 SET Population = 5000000
               WHERE Name = 'Sydney'
                 AND CountryCode = 'AUS';
Query OK, 1 row affected (0.0005 sec)

Rows matched: 1  Changed: 1  Warnings: 0

-- Connection 2
Connection 2> SELECT INDEX_NAME, LOCK_TYPE,
                     LOCK_MODE, COUNT(*)
                FROM performance_schema.data_locks
               WHERE OBJECT_SCHEMA = 'world'
                     AND OBJECT_NAME = 'city'
               GROUP BY INDEX_NAME, LOCK_TYPE, LOCK_MODE;
+-------------+-----------+---------------+----------+
| INDEX_NAME  | LOCK_TYPE | LOCK_MODE     | COUNT(*) |
+-------------+-----------+---------------+----------+
| NULL        | TABLE     | IX            |        1 |
| CountryCode | RECORD    | X             |       14 |
| PRIMARY     | RECORD    | X,REC_NOT_GAP |       14 |
| CountryCode | RECORD    | X,GAP         |        1 |
+-------------+-----------+---------------+----------+
4 rows in set (0.0007 sec)

Connection 1> ROLLBACK;
Query OK, 0 rows affected (0.0725 sec)

Listing 18-13The locks held in the REPEATABLE READ transaction isolation level

```

在每个`CountryCode`索引和主键上有 14 个记录锁，在`CountryCode`索引上有一个间隙锁。将这与在清单 [18-14](#PC25) 中所示的`READ COMMITTED`事务隔离级别中执行查询后持有的锁进行比较。

```sql
-- Connection 1
Connection 1> SET transaction_isolation = 'READ-COMMITTED';
Query OK, 0 rows affected (0.0003 sec)

Connection 1> START TRANSACTION;
Query OK, 0 rows affected (0.0003 sec)

Connection 1> UPDATE world.city
                 SET Population = 5000000
               WHERE Name = 'Sydney'
                 AND CountryCode = 'AUS';
Query OK, 1 row affected (0.0005 sec)

Rows matched: 1  Changed: 1  Warnings: 0

-- Connection 2
Connection 2> SELECT INDEX_NAME, LOCK_TYPE,
                     LOCK_MODE, COUNT(*)
                FROM performance_schema.data_locks
               WHERE OBJECT_SCHEMA = 'world'
                     AND OBJECT_NAME = 'city'
               GROUP BY INDEX_NAME, LOCK_TYPE, LOCK_MODE;
+-------------+-----------+---------------+----------+
| INDEX_NAME  | LOCK_TYPE | LOCK_MODE     | COUNT(*) |
+-------------+-----------+---------------+----------+
| NULL        | TABLE     | IX            |        1 |
| CountryCode | RECORD    | X,REC_NOT_GAP |        1 |
| PRIMARY     | RECORD    | X,REC_NOT_GAP |        1 |
+-------------+-----------+---------------+----------+
3 rows in set (0.0006 sec)

Connection 1> ROLLBACK;
Query OK, 0 rows affected (0.0816 sec)

Listing 18-14The locks held in the READ-COMMITTED transaction isolation level

```

在这里，记录锁减少为每个索引和主键上的一个锁。没有间隙锁。

并非所有工作负载都可以使用`READ COMMITTED`事务隔离级别。如果您必须让`SELECT`语句在同一事务中多次执行时返回相同的结果，或者让不同的查询对应于同一时间快照，您必须使用`REPEATABLE READ`或`SERIALIZABLE`。但是，在许多情况下，降低隔离级别是一个选项，您可以为不同的事务选择不同的隔离级别。如果您正在从 Oracle DB 迁移应用，那么您已经在使用`READ COMMITTED`，并且您也可以在 MySQL 中使用它。

### 抢先锁定

将讨论的最后一个策略是抢先锁定。如果您有一个执行多个查询的复杂事务，在某些情况下，执行一个`SELECT ... FOR UPDATE`或`SELECT ... FOR SHARE`查询来锁定您知道在事务中稍后会用到的记录可能是一种优势。另一个有用的情况是，确保对于不同的任务以相同的顺序访问行。

抢先锁定对于减少死锁的频率特别有效。一个缺点是，你最终会持有更长时间的锁。总的来说，抢占式锁定是一种应该谨慎使用的策略，但是在正确的情况下，它可以有效地防止死锁。

本章的最后一个主题是回顾如何监控锁。

## 监控锁

已经有几个查询持有的锁的信息的例子。本节将回顾已经提到的资源，并介绍一些额外的资源。第 [22 章](22.html)将通过展示调查锁问题的例子对此进行深入探讨。监控选项可以分为四组:性能模式、`sys`模式、状态指标和 InnoDB 锁监控。

### 性能模式

性能模式包含除死锁之外的大多数可用锁信息的来源。您不仅可以直接使用性能模式中的锁信息；它还用于`sys`模式中两个与锁相关的视图。

这些信息可通过四个表格获得:

*   `data_locks` **:** 该表包含 InnoDB 级别的表和锁记录的详细信息。它显示当前持有的或待定的所有锁。

*   `data_lock_waits` **:** 与`data_locks`表一样，它显示了与 InnoDB 相关的锁，但是只显示那些等待被授予关于哪些线程阻塞了请求的信息的锁。

*   `metadata_locks` **:** 该表包含关于用户级锁、元数据锁等的信息。要记录信息，必须启用`wait/lock/metadata/sql/mdl`性能模式工具(在 MySQL 8 中默认启用)。`OBJECT_TYPE`列显示持有哪种锁。

*   `table_handles` **:** 该表保存了关于哪些表锁当前有效的信息。必须启用`wait/lock/table/sql/handler`性能模式仪器才能记录数据(这是默认设置)。与其他表格相比，此表格的使用频率较低。

`metadata_locks`表是最通用的表，它支持从全局读锁到低级锁(如访问控制列表(ACL ))的各种锁。表 [18-3](#Tab3) 按字母顺序总结了`OBJECT_TYPE`列的可能值，并简要说明了每个值代表的锁。

表 18-3

performance _ schema . metadata _ locks 表中的对象类型

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

对象类型

 | 

描述

 |
| --- | --- |
| `ACL_CACHE` | 用于访问控制列表(ACL)缓存。 |
| `BACKUP_LOCK` | 备用锁。 |
| `CHECK_CONSTRAINT` | 对于`CHECK`约束的名称。 |
| `COLUMN_STATISTICS` | 用于直方图和其他列统计。 |
| `COMMIT` | 用于阻止提交。它与全局读锁相关。 |
| `EVENT` | 对于存储的事件。 |
| `FOREIGN_KEY` | 对于外键名。 |
| `GLOBAL` | 用于全局读锁(由`FLUSH TABLES WITH READ LOCK`触发)。 |
| `FUNCTION` | 对于存储函数。 |
| `LOCKING_SERVICE` | 对于使用锁定服务接口获取的锁。 |
| `PROCEDURE` | 对于存储过程。 |
| `RESOURCE_GROUPS` | 对于资源组。 |
| `SCHEMA` | 对于模式/数据库。这些类似于表的元数据锁，只是它们是用于模式的。 |
| `SRID` | 用于空间参考系统。 |
| `TABLE` | 对于表和视图。这包括本章中讨论的元数据锁。 |
| `TABLESPACE` | 对于表空间。 |
| `TRIGGER` | For 触发器(在表上)。 |
| `USER_LEVEL_LOCK` | 用于用户级锁。 |

性能模式表中的数据是原始锁数据。通常，当您调查锁问题或监控锁问题时，确定是否有锁等待更有意义。对于这些信息，您需要使用`sys`模式。

### sys 架构

`sys`模式有两个视图，获取性能模式表中的信息并返回锁对，其中一个锁由于另一个锁而不能被授予。因此，它们显示了锁等待的问题所在。这两个视图是`innodb_lock_waits`和`schema_table_lock_waits`。

`innodb_lock_waits`视图使用性能模式中的`data_locks`和`data_lock_waits`视图返回 InnoDB 记录锁的所有锁等待情况。它显示诸如连接试图获取什么锁以及涉及哪些连接和查询之类的信息。如果您需要没有格式的信息，视图也以`x$innodb_lock_waits`的形式存在。

`schema_table_lock_waits`视图以类似的方式工作，但是使用`metadata_locks`表返回与模式对象相关的锁等待。该信息在`x$schema_table_lock_waits`视图中也是无格式的。

第 [22](22.html) 章包含了使用两种视图来调查锁问题的例子。

### 状态计数器和 InnoDB 指标

有几个状态计数器和 InnoDB 指标提供关于锁定的信息。这些主要用于全局(实例)级别，对于检测锁问题的总体增加非常有用。一起监控所有这些指标的一个好方法是使用`sys.metrics`视图。清单 [18-15](#PC26) 展示了一个检索指标的例子。

```sql
mysql> SELECT Variable_name,
              Variable_value AS Value,
              Enabled
         FROM sys.metrics
        WHERE Variable_name LIKE 'innodb_row_lock%'
              OR Variable_name LIKE 'Table_locks%'
              OR Type = 'InnoDB Metrics - lock';
+-------------------------------+--------+---------+
| Variable_name                 | Value  | Enabled |
+-------------------------------+--------+---------+
| innodb_row_lock_current_waits | 0      | YES     |
| innodb_row_lock_time          | 595876 | YES     |
| innodb_row_lock_time_avg      | 1683   | YES     |
| innodb_row_lock_time_max      | 51531  | YES     |
| innodb_row_lock_waits         | 354    | YES     |
| table_locks_immediate         | 4194   | YES     |
| table_locks_waited            | 0      | YES     |
| lock_deadlocks                | 1      | YES     |
| lock_rec_lock_created         | 0      | NO      |
| lock_rec_lock_removed         | 0      | NO      |
| lock_rec_lock_requests        | 0      | NO      |
| lock_rec_lock_waits           | 0      | NO      |
| lock_rec_locks                | 0      | NO      |
| lock_row_lock_current_waits   | 0      | YES     |
| lock_table_lock_created       | 0      | NO      |
| lock_table_lock_removed       | 0      | NO      |
| lock_table_lock_waits         | 0      | NO      |
| lock_table_locks              | 0      | NO      |
| lock_timeouts                 | 1      | YES     |
+-------------------------------+--------+---------+
19 rows in set (0.0076 sec)

Listing 18-15Lock metrics

```

如您所见，默认情况下，并非所有指标都是启用的。未启用的可使用第 [7](07.html) 章中讨论的`innodb_monitor_enable`选项启用。`innodb_row_lock_%`、`lock_deadlocks`和`lock_timeouts`度量是最有趣的。行锁指标显示了当前有多少锁正在等待，并统计了等待获取 InnoDB 记录锁所花费的时间(毫秒)。`lock_deadlocks`和`lock_timeouts`指标分别显示遇到的死锁和锁等待超时的数量。

### InnoDB 锁监控器和死锁记录

InnoDB 很久以前就有了自己的锁监控器，锁信息在 InnoDB 监控器输出中返回。默认情况下，InnoDB 监控器包含关于最新死锁以及锁等待中涉及的锁的信息。通过启用`innodb_status_output_locks`选项(默认禁用)，将列出所有锁；这类似于性能模式`data_locks`表中的内容。

为了演示死锁和事务信息，您可以从清单 [18-12](#PC19) 中创建死锁，并创建一个新的正在进行的事务，该事务通过`world.city`表中的主键更新了一行:

```sql
mysql> START TRANSACTION;
Query OK, 0 rows affected (0.0002 sec)

mysql> UPDATE world.city
          SET Population = Population + 1
        WHERE ID = 130;
Query OK, 1 row affected (0.0005 sec)

Rows matched: 1  Changed: 1  Warnings: 0

```

使用`SHOW ENGINE INNODB STATUS`语句生成 InnoDB 锁监控器输出。清单 [18-16](#PC28) 显示了启用所有锁定信息并生成监控器输出的示例。完整的 InnoDB monitor 输出也可以从本书的 GitHub 资源库的文件`listing_18_16.txt`中获得。

```sql
mysql> SET GLOBAL innodb_status_output_locks = ON;
Query OK, 0 rows affected (0.0022 sec)

mysql> SHOW ENGINE INNODB STATUS\G
*************************** 1\. row ***************************
  Type: InnoDB
  Name:
Status:
=====================================
2019-11-04 17:04:48 0x6e88 INNODB MONITOR OUTPUT
=====================================
Per second averages calculated from the last 51 seconds
-----------------
BACKGROUND THREAD
-----------------
srv_master_thread loops: 170 srv_active, 0 srv_shutdown, 62448 srv_idle
srv_master_thread log flush and writes: 0
----------
SEMAPHORES
----------
OS WAIT ARRAY INFO: reservation count 138
OS WAIT ARRAY INFO: signal count 133
RW-shared spins 1, rounds 1, OS waits 0
RW-excl spins 109, rounds 1182, OS waits 34
RW-sx spins 24, rounds 591, OS waits 18
Spin rounds per wait: 1.00 RW-shared, 10.84 RW-excl, 24.63 RW-sx
------------------------
LATEST DETECTED DEADLOCK
------------------------
2019-11-03 19:41:43 0x4b78
*** (1) TRANSACTION:
TRANSACTION 5585, ACTIVE 10 sec starting index read
mysql tables in use 1, locked 1
LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1
MySQL thread id 37, OS thread handle 28296, query id 21071 localhost ::1 root updating
UPDATE world.city
                 SET Population = Population + 1
               WHERE ID = 130

*** (1) HOLDS THE LOCK(S):
RECORD LOCKS space id 159 page no 28 n bits 248 index PRIMARY of table `world`.`city` trx id 5585 lock_mode X locks rec but not gap
Record lock, heap no 26 PHYSICAL RECORD: n_fields 7; compact format; info bits 0
 0: len 4; hex 80000edd; asc     ;;
 1: len 6; hex 0000000015d1; asc       ;;
 2: len 7; hex 01000000f51aa6; asc        ;;
 3: len 30; hex 53616e204672616e636973636f2020202020202020202020202020202020; asc San Francisco                 ; (total 35 bytes);
 4: len 3; hex 555341; asc USA;;

 5: len 20; hex 43616c69666f726e696120202020202020202020; asc California          ;;
 6: len 4; hex 800bda1e; asc     ;;

*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
...
------------
TRANSACTIONS
------------
Trx id counter 5662
Purge done for trx's n:o < 5661 undo n:o < 0 state: running but idle
History list length 11
LIST OF TRANSACTIONS FOR EACH SESSION:
---TRANSACTION 284075292758256, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 284075292756560, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 284075292755712, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 5661, ACTIVE 60 sec
2 lock struct(s), heap size 1136, 1 row lock(s), undo log entries 1
MySQL thread id 40, OS thread handle 2044, query id 26453 localhost ::1 root
TABLE LOCK table `world`.`city` trx id 5661 lock mode IX
RECORD LOCKS space id 160 page no 7 n bits 248 index PRIMARY of table `world`.`city` trx id 5661 lock_mode X locks rec but not gap
Record lock, heap no 41 PHYSICAL RECORD: n_fields 7; compact format; info bits 0
 0: len 4; hex 80000082; asc     ;;
 1: len 6; hex 00000000161d; asc       ;;
 2: len 7; hex 01000001790a72; asc     y r;;
 3: len 30; hex 5379646e6579202020202020202020202020202020202020202020202020; asc Sydney                        ; (total 35 bytes);
 4: len 3; hex 415553; asc AUS;;
 5: len 20; hex 4e657720536f7574682057616c65732020202020; asc New South Wales     ;;
 6: len 4; hex 8031fdb0; asc  1  ;;
...

Listing 18-16The InnoDB monitor output

```

靠近顶部的部分是`LATEST DETECTED DEADLOCK`部分，它包括最近一次死锁所涉及的事务和锁的详细信息以及它发生的时间。如果自 MySQL 最后一次重启以来没有发生死锁，则省略这一节。第 22 章将包括一个调查死锁的例子。

Note

InnoDB 监控器输出中的 deadlock 部分仅包含涉及 InnoDB 记录锁的死锁信息。对于涉及用户级锁的死锁，没有等效的信息。

输出再往下一点，是列出 InnoDB 事务的部分`TRANSACTIONS`。请注意，不持有任何锁的事务(例如，纯`SELECT`查询)不包括在内。在这个例子中，在`world.city`表上有一个意向排他锁，在主键等于 130 的行上有一个排他锁(第一个字段的记录锁信息中的 80000082 表示值为 0x82 的行，它与十进制表示法中的 130 相同)。

Tip

如今，InnoDB 监控器输出中的锁定信息最好从`performance_schema.data_locks`和`performance_schema.data_lock_waits`表中获取。然而，死锁信息仍然非常有用。

您可以请求每隔 15 秒将监控器输出转储到`stderr`。您可以通过启用`innodb_status_output`选项来启用转储。请注意，输出非常大，所以如果启用它，请做好错误日志快速增长的准备。InnoDB monitor 输出也很容易隐藏关于更严重问题的消息。

如果您想确保记录所有死锁，您可以启用`innodb_print_all_deadlocks`选项。这导致每次发生死锁时，InnoDB monitor 输出中的死锁信息都会打印到错误日志中。如果您需要调查死锁，这可能是有用的，但是建议您仅在需要时启用它，以避免错误日志变得非常大并可能隐藏其他问题。

Caution

如果启用 InnoDB 监控器的常规输出或关于所有死锁的信息，请小心。这些信息很容易隐藏错误日志中记录的重要消息。

## 摘要

锁是一个庞大而复杂的话题。希望这一章已经帮助你了解了为什么需要锁以及各种锁。

这一章开始询问为什么需要锁。没有锁，对模式和数据进行并发访问是不安全的。打个比方，数据库锁的工作方式与交通信号灯和停车标志在交通中的工作方式相同。它规范了对数据的访问，因此事务可以确保不会与另一个事务发生冲突而导致不一致的结果。

数据有两种访问级别:共享访问(也称为读访问)和独占访问(也称为写访问)。这些访问级别适用于各种锁粒度，从全局读锁到记录锁和间隙锁。此外，InnoDB 在表级别使用意向共享锁和意向排他锁。

努力减少应用需要的锁的数量并减少所需锁的影响是很重要的。减少锁问题的策略本质上可以归结为在事务中做尽可能少的工作，方法是使用索引，将大型事务分成较小的事务，并尽可能短时间地持有锁。对于应用中的不同任务，尝试以相同的顺序访问数据也很重要；否则，可能会出现不必要的死锁。

本章的最后一部分介绍了性能模式、`sys`模式、状态指标和 InnoDB 监控器中的锁监控选项。大多数监控最好使用性能模式表和`sys`模式视图来完成。例外情况是死锁，此时 InnoDB 监控器仍然是最佳选择。

这是第四部分的结论。现在是时候让查询分析变得更加实用了，首先要找到适合优化的查询。

<aside aria-label="Footnotes" class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

[T2`https://bugs.mysql.com/bug.php?id=44884`](https://bugs.mysql.com/bug.php%253Fid%253D44884)

 </aside>