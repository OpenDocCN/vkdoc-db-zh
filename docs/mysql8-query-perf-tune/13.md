# 十三、数据类型

在 MySQL(和其他关系数据库)中创建表时，需要为每一列指定数据类型。为什么不把所有东西都存储成字符串呢？毕竟，当数字 42 在本书中被使用时，它被表示为一个字符串，那么为什么不直接对所有内容使用字符串，并允许每一列都有各种值呢？这个想法有一些优点。这是 NoSQL 数据库的部分工作方式(尽管不止如此)，本书的作者见过所有列都被定义为`varchar(255)`字符串的表格。为什么要为整数、小数、浮点数、日期、字符串等等而烦恼呢？这有几个原因，这就是本章的主题。

首先，将讨论对不同类型的值使用不同数据类型的好处。然后会有 MySQL 支持的数据类型的概述。最后，将讨论数据类型如何影响查询性能以及如何为列选择数据类型。

## 为什么是数据类型？

列的数据类型定义了可以存储什么类型的值以及如何存储这些值。此外，可能存在与数据类型相关联的元属性，例如大小(例如，用于数字的字节数和字符串中的最大字符数)以及用于字符串的字符集和校对。虽然数据类型属性看起来像是不必要的限制，但它们也有好处。这些好处包括

*   数据有效性

*   文件

*   优化存储

*   表演

*   正确排序

本节的其余部分将讨论这些好处。

### 数据有效性

在它们的核心，数据类型定义了什么样的值是允许的。定义为整数数据类型的列只能存储整数值。这也是一种保障。如果您犯了一个错误，并试图将一个值存储到一个与定义的数据类型不同的列中，则可能会拒绝该值或转换该值。

Tip

将错误数据类型的值分配给列是否会导致错误或数据类型被转换取决于您是否启用了`STRICT_TRANS_TABLES`(对于事务存储引擎)和`STRICT_ALL_TABLES`(对于所有存储引擎)SQL 模式，以及转换数据类型是否被认为是安全的。某些被认为是安全的转换总是被允许的，例如，将“42”转换为 42，反之亦然。建议始终启用严格模式，当试图进行不安全的转换或截断数据时，该模式会使 DML 查询失败。

当您可以确保存储在表中的数据总是具有预期的数据类型时，您的工作会更轻松。如果用整数查询列，那么对返回值进行算术运算是安全的。同样，如果您知道值是一个字符串，您可以安全地执行字符串操作。这需要提前多做一点规划，但是一旦完成，您将会发现自己了解数据的数据类型。

关于数据类型和数据验证还有一点需要考虑。通常，有一些属性与数据类型相关联。在最简单的情况下，你有最大的尺寸。例如，整数的大小可以是 1、2、3、4 或 8 个字节。这会影响可以存储的值的范围。此外，整数可以是有符号的，也可以是无符号的。一个更复杂的例子是字符串，它不仅对存储多少文本有限制，而且需要一个字符集来定义数据如何编码，还需要一个排序规则来定义数据如何排序。

清单 [13-1](#PC1) 展示了 MySQL 如何根据数据类型验证数据的例子。

```sql
mysql> SELECT @@sql_mode\G
*************************** 1\. row ***************************
@@sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION
1 row in set (0.0003 sec)

mysql> SHOW CREATE TABLE t1\G
*************************** 1\. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `val1` int(10) unsigned DEFAULT NULL,
  `val2` varchar(5) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
1 row in set (0.0011 sec)

mysql> INSERT INTO t1 (val1) VALUES ('abc');
ERROR: 1366: Incorrect integer value: 'abc' for column 'val1' at row 1

mysql> INSERT INTO t1 (val1) VALUES (-5);
ERROR: 1264: Out of range value for column 'val1' at row 1

mysql> INSERT INTO t1 (val2) VALUES ('abcdef');
ERROR: 1406: Data too long for column 'val2' at row 1

mysql> INSERT INTO t1 (val1, val2) VALUES ('42', 42);
Query OK, 1 row affected (0.0825 sec)

Listing 13-1Data validation based on data type

```

SQL 模式被设置为默认模式，包括`STRICT_TRANS_TABLES`。除了主键之外，该表还有两列，其中一列是无符号整数，另一列是`varchar(5)`，这意味着它最多可以存储五个字符。当试图将字符串或负整数插入到`val1`列时，该值会被拒绝，因为它不能安全地转换为无符号整数。类似地，试图将一个包含六个字符的字符串存储到`val2`列中也会失败。然而，将字符串`'42'`存储到`val1`并将整数 42 存储到`val2`被认为是安全的，因此是允许的。

数据验证的一个副作用是，您还描述了您期望的数据——这是列的隐式文档。

### 文件

当您设计表格时，您知道表格的预期用途。然而，当您或其他人以后使用该表时，这不一定清楚。有几种方法记录列:使用描述值的列名、`COMMENT`列子句、`CHECK`约束和数据类型。

虽然不是记录列的最详细的方法——当然也不应该独立存在——但是数据类型确实有助于描述您期望的数据类型。如果您选择了`date`列而不是`datetime`，那么很明显您只打算存储日期部分。类似地，使用`tinyint`而不是`int`表明您只期望相对较小的值。这些都有助于你自己或他人理解什么样的数据是可以预期的。当您需要优化查询时，对数据的理解越好，您所做的更改就越成功，这样它就可以间接地帮助查询优化。

Tip

在表中提供文档的最佳方式是使用`COMMENT`子句和`CHECK`约束。然而，这些在表格图中通常是看不到的，在表格图中，数据类型有助于更好地理解预期的数据类型。

关于性能，显式选择数据类型也有好处。其中之一与值的存储方式有关。

### 优化存储

MySQL 并不以相同的方式存储所有数据。给定数据类型的存储格式选择得尽可能紧凑，以减少所需的存储空间。例如，考虑值 123456。如果将其存储为字符串，则至少需要 6 个字节加上可能的 1 个字节来存储字符串的长度。如果您选择一个整数，您只需要 3 个字节(对于整数，所有值总是使用相同数量的字节，这取决于该列允许的最大存储)。此外，从存储器中读取整数不需要对值 <sup>[1](#Fn1)</sup> 进行任何解释，而对于字符串，则需要使用其字符集对值进行解码。

选择正确的最大列大小可以减少所需的存储量。如果您需要存储整数，并且知道您从不需要需要超过 4 个字节存储的值，那么您可以使用`int`数据类型，而不是使用 8 个字节存储的`bigint`。这是该列所需存储量的一半。如果您使用大数据，存储(和内存)节省可能会变得非常大。但是，注意不要过度优化。在许多情况下，更改列的数据类型或大小需要重新构建整个表，如果表很大，这可能是一个开销很大的操作。这样，最好现在就使用多一点的存储空间，以节省以后的工作。

Tip

与其他类型的优化一样，注意不要过度优化数据类型。现在相对较小的存储节省可能会导致以后的痛苦。

数据的存储方式也会影响性能。

### 表演

并非所有数据类型都是平等的。在计算和比较中使用整数非常便宜，而存储字节的字符串必须使用字符集解码，因此相对昂贵。通过选择正确的数据类型，可以显著提高查询的性能。特别是，如果您需要比较两列中的值(可能在不同的表中)，请确保它们具有相同的数据类型，包括字符集和字符串的排序规则。否则，必须先转换其中一列中的数据，然后才能与另一列进行比较。

虽然理解为什么整数比字符串的性能好很简单，但究竟是什么使一种数据类型的性能比另一种数据类型好或差却相对复杂，这取决于数据类型是如何实现的(存储在磁盘上)。因此，关于性能的进一步讨论将推迟到下一节介绍 MySQL 数据类型之后。

将讨论的最后一个好处是排序。

### 正确排序

日期类型对值的排序方式有很大影响。虽然人脑通常可以直观地理解数据，但计算机需要一些帮助来理解两个值如何相互比较。数据类型和字符串的排序规则是用于确保数据正确排序的关键属性。

为什么排序很重要？这有几个原因:

*   正确的排序需要知道两个值是否相等或者一个值是否在给定的范围内。这对于让`WHERE`子句和连接条件按预期工作是至关重要的。

*   当您创建索引时，排序用于确保 MySQL 能够快速找到具有您正在寻找的值的行。 <sup>[2](#Fn2)</sup> 指标将在下一章详细介绍。

考虑值 8 和 10。它们是如何排序的？如果你认为它们是整数，8 在 10 之前。但是，如果您将它们视为字符串，那么“10”(ASCII:0x 3130)位于“8”(ASCII:0x 38)之前。您是否期望一个或另一个取决于您的应用，但是除非也有包含非数字部分的值，否则您可能期望 integer 行为，该行为要求数据类型为 integer 类型。

既然已经讨论了显式数据类型的好处，那么是时候了解 MySQL 支持的数据类型了。

## MySQL 数据类型

MySQL 中有 30 多种不同的数据类型。其中几个可以根据大小、精度以及是否接受有符号值进行微调。乍一看，这似乎让人不知所措，但是如果您将数据类型分成不同的类别，您可以逐步为您的数据选择正确的数据类型。

MySQL 中的数据类型可被视为以下类别之一的一部分:

*   **数值:**这包括整数、固定精度小数类型、近似精度浮点类型和位类型。

*   **Temporal:** 这包括年份、日期、时间、日期时间和时间戳值。

*   **字符串:**这包括二进制对象和带有字符集的字符串。

*   **JSON:**JSON 数据类型可以存储 JSON 文档。

*   **Spatial:** 这些类型用于存储描述坐标系中一个或多个点的值。

*   **Hybrid:** MySQL 有两种数据类型，都可以作为整数和字符串使用。

Tip

《MySQL 参考手册》对 [`https://dev.mysql.com/doc/refman/8.0/en/data-types.html`](https://dev.mysql.com/doc/refman/8.0/en/data-types.html) 中的数据类型以及其中的引用有全面的论述。

本节的其余部分将介绍数据类型并讨论它们的细节。

### 数字数据类型

数值数据类型是 MySQL 支持的最简单的数据类型。您可以在整数、固定精度十进制值和近似浮点值之间进行选择。

表 [13-1](#Tab1) 总结了数字数据类型，包括其存储要求(以字节为单位)和支持的取值范围。对于整数，您可以选择值是有符号的还是无符号的，这会影响支持的值的范围。对于支持的值，开始值和结束值都包括在允许值的范围内。

表 13-1

数字数据类型(整数、定点和浮点)

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

数据类型

 | 

存储的字节数

 | 

范围

 |
| --- | --- | --- |
| `tinyint` | one | 签名:-128–127 无符号:0–255 |
| `smallint` | Two | 签名:-32768–32767 无符号:0–65535 |
| `mediumint` | three | 签名:-8388608–8388607 无符号:0–16777215 |
| `int` | four | 签名:-2147483648–2147483647 无符号:0–4294967295 |
| `bigint` | eight | 签名:-2<sup>63</sup>–2<sup>63</sup>-1 无符号:0–2<sup>64</sup>-1 |
| `decimal(M, N)` | 1–29 | 取决于 M 和 N |
| `float` | four | 可变的 |
| `double` | eight | 可变的 |
| `bit(M)` | 1–8 |   |

整数数据类型是最简单的，具有固定的存储要求和固定的支持值范围。`tinyint`的同义词是`bool`(布尔值)。

`decimal`数据类型(`numeric`是同义词)有两个参数，M 和 N，它们定义了值的精度和小数位数。如果有`decimal(5,2)`，数值最多有五位，其中两位是小数(小数点右边)。这意味着允许值在-999.99 和 999.99 之间。最多支持 65 位数字。小数的存储量取决于位数，每个 9 位数的倍数使用 4 个字节，其余位数使用 0-4 个字节。

`float`和`double`数据类型存储近似值。这些类型对于数值计算很有效，但代价是它们的值存在不确定性。它们分别使用 4 字节和 8 字节进行存储。

Tip

不要使用浮点数据类型来存储精确的数据，如货币金额。请改用精确小数数据类型。对于近似浮点数据类型，永远不要使用等号(`=`)和不等号(`<>`)运算符，因为比较两个近似值通常不会返回相等的结果，即使它们应该相等。

最后一种数值数据类型是`bit`类型。它可以在一个值中存储 1 到 64 位。例如，这可以用于位屏蔽。所需的存储取决于所需的位数(M 值)；可以近似为`FLOOR((M+7)/8)`字节。

与数值类型相关的一类数据类型是时态数据类型，这是下一个将要讨论的类别。

### 时态数据类型

时态数据定义一个时间点。精度范围从一年到一微秒。除了 year 数据类型之外，值是以字符串形式输入的，但是在内部使用了优化的格式，并且值将根据值所代表的时间点正确排序。

表 [13-2](#Tab2) 显示了 MySQL 支持的时态数据类型，每种类型使用的存储量(以字节为单位),以及支持的值的范围。

表 13-2

时态数据类型

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

数据类型

 | 

存储的字节数

 | 

范围

 |
| --- | --- | --- |
| `year` | one | 1901–2155 |
| `date` | 3–6 | “1000-01-01”到“9999-12-31” |
| `datetime` | 5–8 | “1000-01-01 00:00:00.000000”到“9999-12-31 23:59:59.999999” |
| `timestamp` | 4–7 | “1970-01-01 00:00:01.000000”到“2038-01-19 03:14:07.999999” |
| `time` | 3–6 | -838:59:59.000000 '到' 838:59:59.000000 ' |

`datetime`、`timestamp`和`time`类型都支持高达微秒分辨率的小数秒。小数秒的存储要求为 0-3 字节，具体取决于位数(每两位数一个字节)。

`datetime`和`timestamp`列略有不同。当您在`datetime`列中存储一个值时，MySQL 会按照您指定的方式存储它。另一方面，对于一个`timestamp`列，使用 MySQL 被配置为使用的时区——变量`@@session.time_zone`(默认为系统时区)将值转换为 UTC。同样，当您检索数据时，`datetime`值将按照您最初指定的方式返回，而`timestamp`列将被转换为在`@@session.time_zone`变量中设置的时区。

Tip

使用`datetime`列时，以 UTC 时区存储数据，并在使用数据时转换为所需的时区。通过始终以 UTC 格式存储值，如果操作系统时区或 MySQL 服务器时区被更改，或者您与来自不同时区的用户共享数据，出现问题的可能性就会降低。

当您使用字符串输入和检索日期和时间时，它们以专用格式存储在内部。实际的字符串呢？让我们来看看字符串和二进制数据类型。

### 字符串和二进制数据类型

字符串和二进制数据类型是存储任意数据的非常灵活的类型。二进制值和字符串的区别在于，字符串有一个与之关联的字符集，所以 MySQL 知道如何解释数据。另一方面，二进制值存储原始数据，这意味着您可以将它们用于任何类型的数据，包括图像和自定义数据格式。

虽然字符串和二进制数据非常灵活，但它们也有代价。对于字符串，MySQL 需要解释字节来确定它们代表哪些字符。就所需的计算能力而言，这是相对昂贵的。有些字符集，包括 MySQL 8 中默认的字符集 UTF-8，是可变宽度的，即一个字符使用可变数量的字节；对于 UTF-8，它的范围是每个字符 1 到 4 个字节。这意味着，如果您请求一个字符串的前四个字符，它可能需要读取 4 到 16 个字节，这取决于是哪些字符，因此 MySQL 将需要分析这些字节来确定何时找到了四个字符。对于二进制字符串，数据含义的解释被放回到应用中。

表 [13-3](#Tab3) 显示了 MySQL 中代表字符串和二进制数据的数据类型。该表包括可存储的最大数据量以及存储要求的描述。对于数据类型，`(M)`是该列必须能够存储的最大字符数，而在存储的字节数中，L 是表示用于编码的字符集中的字符串值所需的字节数。

表 13-3

字符串和二进制数据类型

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

数据类型

 | 

存储的字节数

 | 

最大长度

 |
| --- | --- | --- |
| `char(M)` | M*char 宽度 | 255 个字符 |
| `varchar(M)` | L+1 或 L+2 | `utf8mb4`的 16383 个字符和`latin1`的 65532 个字符 |
| `tinytext` | L+1 | 255 字节 |
| `text` | L+2 | 65535 字节 |
| `mediumtext` | L+3 | 16777216 字节 |
| `longtext` | L+4 | 4294967296 字节 |
| `binary(M)` | M | 255 字节 |
| `varbinary(M)` | L+1 或 L+2 | 65532 字节 |
| `tinyblob` | L+1 | 255 字节 |
| `blob` | L+2 | 65536 字节 |
| `mediumblob` | L+3 | 16777216 字节 |
| `longblob` | L+4 | 4294967296 字节 |

字符串和二进制对象的存储要求取决于数据的长度。l 是存储该值所需的字节数；对于文本字符串，字符集也必须考虑在内。对于可变宽度类型，1–4 个字节用于存储值的长度。对于`char(M)`列，当使用紧凑系列的 InnoDB 存储格式并且字符串用可变宽度字符集编码时，所需的存储空间可能小于字符宽度的 M 倍。

对于除 char 和 varchar 之外的所有类型，字符串支持的最大长度以字节为单位指定。这意味着字符串类型中可以存储的字符数取决于字符集。此外，`char`、`varchar`、`binary`和`varbinary`列计入行宽，行宽总计必须小于 64kb，这实际上意味着很少可能使用理论上的最大长度创建列。(这也是`varchar`和`varbinary`列最多可以存储 65532 个字符/字节的原因。)对于`longtext`和`longblob`列，应该注意的是，虽然它们原则上可以存储多达 4 GiB 的数据，但实际上存储受到`max_allowed_packet`变量的限制，该变量最多可以是 1 GiB。

对于存储字符串的数据类型，另一个需要考虑的问题是，您必须为列选择字符集和排序规则。如果没有明确选择，将使用表的默认值。在 MySQL 8 中，默认字符集是使用`utf8mb4_0900_ai_ci`排序规则的`utf8mb4`。`utf8mb4`和`utf8mb4_0900_ai_ci`是什么意思？

`utf8mb4`字符集是 UTF 8，支持每个字符多达 4 个字节(例如，对于一些表情符号是必需的)。最初，MySQL 只支持 UTF-8 的每个字符最多 3 个字节，后来添加了`utf8mb4`来扩展支持。今天，你不应该使用`utf8mb3`(每个字符最多 3 个字节)或其别名`utf8`(已弃用，所以后来可以改为表示`utf8mb4`)。当您使用 UTF-8 时，请始终选择 4 字节变体，因为 3 字节变体几乎没有什么好处，并且已经被弃用。在 MySQL 5.7 和更早的版本中，拉丁语 1 是默认字符集，但随着 MySQL 8 中 UTF-8 的改进，建议使用`utf8mb4`，除非你有特定的理由选择另一个字符集。

`utf8mb4_0900_ai_ci`排序规则是用于`utf8mb4`的通用排序规则。归类定义了排序和比较规则，因此当您比较两个字符串时，它们会正确地进行比较。这些规则可能相当复杂，包括某些字符序列与其他单个字符相等(例如，在某些归类中，德语中的 sharp 与“ss”相同)。排序规则名称由几个部分组成，它们是

*   **utf8mb4:** 归类所属的字符集。

*   **0900:** 这意味着该排序规则是基于 Unicode 排序算法(UCA) 9.0.0 的排序规则之一。这些是在 MySQL 8 中引入的，与旧的 UTF-8 排序规则相比，提供了显著的性能改进。

*   **ai:** 排序规则可以是不区分重音的(ai)或区分重音的(as)。当排序规则不区分重音时，带重音的字符(如à)被视为等于不带重音的字符 a。在这种情况下，它不区分重音。

*   **ci:** 排序规则可以不区分大小写(ci)或区分大小写(cs)。在这种情况下，它不区分大小写。

名称也可以包含其他部分，其他字符集也有其他排序规则。特别是，有几个特定于国家的字符集需要考虑本地排序和比较规则；对于这些，国家代码被添加到名称中。建议使用 UCA 9.0.0 排序规则之一，因为与其他排序规则相比，这些排序规则具有更好的性能，并且更加现代化。`information_schema.COLLATIONS`视图包括 MySQL 支持的所有排序规则，支持按字符集过滤。从 8.0.18 开始，有 75 种归类可用于 utf8mb4，其中 49 种是 UCA 9.0.0 归类。

Tip

字符集和排序规则本身就是一个大而有趣的话题。如果你想深入这个话题，可以从本书作者的博客和其中的参考资料开始: [`https://mysql.wisborg.dk/mysql-8_charset`](https://mysql.wisborg.dk/mysql-8_charset) 。

JSON 文档是一种特殊的字符串。MySQL 为它们提供了专用的数据类型。

### JSON 数据类型

比关系表更灵活的一种流行的数据存储格式是 JavaScript 对象表示法(JSON)格式。这也是 MySQL 8 中可用的 MySQL 文档存储所选择的格式。MySQL 5.7 引入了对`json`数据类型的支持。

JSON 文档是 JSON 对象(键和值)、JSON 数组和 JSON 值的组合。下面是一个简单的 JSON 文档示例:

```sql
{
    "name": "Sydney",
    "demographics": {
        "population": 5500000
    },
    "geography": {
        "country": "Australia",
        "state": "NSW"
    },
    "suburbs": [
        "The Rocks",
        "Surry Hills",
        "Paramatta"
    ]
}

```

因为 JSON 文档也是一个字符串(或二进制对象)，所以它也可以存储在字符串或二进制对象列中。但是，通过拥有专用的数据类型，可以添加验证，并且存储为访问文档中的特定元素而优化。

MySQL 8 中 JSON 文档的一个很好的性能相关特性是支持部分更新。这使得更改就地进行，不仅减少了更新期间所做的工作量，还可以只将部分更改写入二进制日志。要使部分就地更新成为可能，需要满足一些要求。这些措施如下:

*   仅支持`JSON_SET()`、`JSON_REPLACE()`和`JSON_REMOVE()`功能。

*   仅支持列内的更新。也就是说，不支持将一列设置为对另一列起作用的三个 JSON 函数之一的返回值。

*   它必须是被替换的现有值。添加新的对象或数组元素会导致整个文档被重写。

*   新值最多必须与被替换的值大小相同。例外情况是先前部分更新释放的空间可以重用。

为了将部分更新作为部分更新记录到二进制日志中，您需要将`binlog_row_value_options`选项设置为`PARTIAL_JSON`。该选项可以在会话和全局级别动态设置。

在内部，文档存储为一个长二进制对象(`longblob`)，文本使用`utf8mb4`字符集进行解释。最大存储量限制为 1 GiB。存储需求与`longblob`相似，但是有必要考虑元数据和用于查找的字典的开销。

到目前为止，已经讨论了数字、时态数据、字符串、二进制对象和 JSON 文档。指定空间中一个点的数据呢？这是要涵盖的下一类数据类型。

### 空间数据类型

空间数据指定坐标系中的一个或多个点，可能形成一个对象，如多边形。例如，这对于在地图上指定项目的位置非常有用。

MySQL 8 增加了指定使用哪个参考系的支持；这被称为空间参考系统标识符(SRID)。支持的参考系统可以在`information_schema.ST_SPATIAL_REFERENCE_SYSTEMS`视图中找到(`SRS_ID`列有用于 SRID 的值)；有 5000 多种可供选择。每个空间值都有一个关联的参考系统，以便 MySQL 能够正确识别两个值之间的关系，例如，计算两点之间的距离。要使用地球作为参考系统，请将 SRID 设置为 4326。

支持八种不同的空间数据类型，其中四种是单值类型，四种是值的集合。表 [13-4](#Tab4) 总结了以字节为单位列出的所需存储的空间类型。

表 13-4

空间数据类型

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

数据类型

 | 

存储的字节数

 | 

描述

 |
| --- | --- | --- |
| `geometry` | 可变的 | 任何类型的单个空间对象。 |
| `point` | Twenty-five | 单点，例如，一个人的位置。 |
| `linestring` | 9+16 * #点 | 形成一条线的一组点，也就是说，它不是一个封闭的对象。 |
| `polygon` | 13+16 * #点 | 包围一个区域的一组点。一个多边形可以包括几个这样的集合，例如，创建环形对象的内环和外环。 |
| `multipoint` | 13+21 * #点 | 点的集合。 |
| `multilinestring` | 可变的 | linestring 值的集合。 |
| `multipolygon` | 可变的 | 多边形的集合。 |
| `geometrycollection` | 可变的 | 几何值的集合。 |

MySQL 使用二进制格式存储数据。`geometry`、`multilinestring`、`multipolygon`和`geometrycollection`类型的存储需求取决于值中包含的对象的大小。这些对象集合的存储比将对象存储在单独的列中稍大一些。您可以使用`LENGTH()`函数来获得空间对象的大小，然后添加 4 个字节来存储 SRID，以获得数据所需的总存储空间。

这就剩下一类数据类型需要讨论:数字和字符串数据类型的混合。

### 混合数据类型

有两种特殊的数据类型结合了整数和字符串的属性:`enum`和`set`。两者都可以被认为是可能值的集合，区别在于`enum`数据类型允许您选择其中一个可能值，而`set`数据类型允许您选择任何可能值。

使`enum`和`set`数据类型混合在一起的是，您可以将它们作为整数和字符串使用。后者是最常见的，也是最容易使用的。在内部，值被存储为整数，这提供了紧凑和有效的存储，同时仍然允许在设置或查询列时使用字符串。两种数据类型都可以使用查找表来实现。

`enum`数据类型是两者中最常用的。创建列时，可以指定允许值的列表，例如:

```sql
CREATE TABLE t1 (
   id int unsigned NOT NULL PRIMARY KEY,
   val enum('Sydney', 'Melbourne', 'Brisbane')
);

```

数值是列表中从 1 开始的位置。也就是说，悉尼的整数值为 1，墨尔本为 2，布里斯班为 3。根据列表中成员的数量，总存储需求只有 1 或 2 个字节，最多支持 65535 个成员。

除了您可以选择多个选项之外，`set`数据类型的工作方式与`enum`类似。要创建它，请列出您希望可用的成员，例如:

```sql
CREATE TABLE t1 (
   id int unsigned NOT NULL PRIMARY KEY,
   val set('Sydney', 'Melbourne', 'Brisbane')
);

```

根据成员在列表中的位置，列表中的每个成员都将获得 1、2、4、8 等系列中的一个数值。在本例中，悉尼的值为 1，墨尔本的值为 2，布里斯班的值为 4。那么值 3 代表什么呢？是悉尼和墨尔本。如果要包含多个值，可以对它们的单个值求和。这样，set 数据类型的工作方式与 bit 类型相同。当您将值指定为字符串时会更简单，因为您将值的成员包括在逗号分隔的列表中。清单 [13-2](#PC5) 显示了两个插入`set`值的例子，每个例子使用数字和字符串值两次插入相同的值。

```sql
mysql> INSERT INTO t1
       VALUES (1, 4),
              (2, 'Brisbane');
Query OK, 2 rows affected (0.0812 sec)

Records: 2  Duplicates: 0  Warnings: 0

mysql> INSERT INTO t1
       VALUES (3, 7),
              (4, 'Sydney,Melbourne,Brisbane');
Query OK, 2 rows affected (0.0919 sec)

Records: 2  Duplicates: 0  Warnings: 0

mysql> SELECT *
         FROM t1\G
*************************** 1\. row ***************************
 id: 1
val: Brisbane
*************************** 2\. row ***************************
 id: 2
val: Brisbane
*************************** 3\. row ***************************
 id: 3
val: Brisbane,Melbourne,Sydney
*************************** 4\. row ***************************
 id: 4
val: Brisbane,Melbourne,Sydney
4 rows in set (0.0006 sec)

Listing 13-2Working with set values

```

首先，插入`'Brisbane'`的值。因为它是集合中的第三个元素，所以它的数值为 4。然后插入悉尼、墨尔本和布里斯班的布景。这里你需要把 1，2，4 相加。注意在`SELECT`查询中，元素的顺序与`set`定义中的不同。

根据集合中成员的数量，`set`列使用 1、2、3、4 或 8 个字节的存储空间。一个集合中最多可以有 64 个成员。

对可用数据类型的讨论到此结束。数据类型如何影响查询的性能？可能很多，所以值得考虑一下。

## 表演

数据类型的选择不仅对于数据完整性和判断预期的数据类型很重要，而且不同的数据类型具有不同的性能特征。本节将讨论在比较数据类型时性能如何变化。

一般来说，数据类型越简单，性能越好。整数的性能最好，浮点(近似值)紧随其后。十进制(精确)值比近似浮点值有更高的开销。二进制对象比文本字符串执行得更好，因为二进制对象没有字符集的开销。

当谈到像 JSON 这样的数据类型时，您可能认为它的性能比使用二进制对象差，因为 JSON 文档有一些存储开销，如本章前面所述。然而，正是这种存储开销意味着 JSON 数据类型的性能要优于将相同的数据存储为 blob。开销包括元数据和用于查找的字典，这意味着访问数据更快。此外，JSON 文档支持就地更新，而 text 和 blob 数据类型会替换整个对象，即使只替换了单个字符或字节。

在给定的数据类型族中(例如，`int`对`bigint`)，较小的数据类型比较大的数据类型执行得更好；然而，在实践中，还需要考虑硬件寄存器内的对齐，因此对于内存中的工作负载，这种差异可以忽略不计，甚至相反。

那么应该使用哪些数据类型呢？这是本章的最后一个主题。

## 应该选择哪种数据类型？

在本章的开始，我们讨论了如何将所有数据存储在字符串或二进制对象中以获得最大的灵活性。在本章的过程中，我们已经讨论了使用特定数据类型的好处，并且在上一节中讨论了不同数据类型的性能。那么应该选择哪种数据类型呢？

您可以开始问自己一些关于需要存储在列中的数据的问题。一些问题的例子如下:

*   数据的本机格式是什么？

*   最初可以预期多大的值？

*   值的大小会随着时间增长吗？如果有，有多少，多快？

*   在查询中检索数据的频率是多少？

*   你期望有多少独特的价值观？

*   需要对值进行索引吗？特别是，它是表的主键吗？

*   您是否需要存储数据，或者是否可以通过另一个表中的外键(使用整数引用列)获取数据？

您应该为需要存储的数据选择本地数据类型。如果你需要存储整数，选择一个整数数据类型，通常是`int`或`bigint`，这取决于你需要多大的值。如果要限制值，可以选择较小的整数类型；例如，存储关于父母的数据的表的孩子数量不需要是一个`bigint`，但是一个`tinyint`就足够了。同样，如果你想存储 JSON 文档，使用`json`类型，而不是`longtext`或`longblob`。

对于数据类型的大小，您需要同时考虑当前需求和未来需求。如果您预计在 long 内需要更大的值，那么最好立即选择更大的数据类型。这样可以避免以后更改表定义。但是，如果预期的变化是几年后的事情，现在使用较小的数据类型并随着时间的推移重新评估您的需求可能会更好。对于`varchar`和`varbinary`，只要不改变存储字符串或字符集长度所需的字节数，也可以就地改变宽度。

当处理字符串和二进制对象时，还可以考虑将数据存储在单独的表中，并使用整数引用这些值。这将在您需要检索值时添加一个联接；但是，如果您只是很少需要实际的字符串值，那么保持主表较小可能是一个整体的优势。这种方法的好处还取决于表中的行数以及如何查询这些行；检索许多行的大型扫描将比单行查找受益更多，即使不需要所有列也使用`SELECT *`将比只选择需要的列受益更多。

如果只有几个唯一的字符串值，那么使用`enum`数据类型也是值得考虑的。它的工作方式类似于查找表，但它保存连接并允许您直接检索字符串值。

对于非整数数字数据，您可以选择精确的`decimal`数据类型和近似的`float`和`double`数据类型。如果您需要存储数据，比如必须精确的货币值，您应该总是选择`decimal`数据类型。如果需要进行相等和不相等的比较，这也是可以选择的类型。如果不需要精确的数据，那么`float`和`double`数据类型会表现得更好。

对于字符串值，那么`char`、`varchar`、`tinytext`、`text`、`mediumtext`和`longtext`数据类型需要一个字符集和一个排序规则。通常，建议选择带有基于 UCA 9.0.0 的排序规则之一的`utf8mb4`(名称中带有`_0900_`的排序规则)。默认的`utf8mb4_0900_ai_ci`是一个不错的选择，如果你没有特定的需求。Latin 1 的性能会稍微好一点，但不足以保证为不同的需求增加不同字符集的复杂性。UCA 9.0.0 排序规则还提供了比 Latin 1 更现代的排序规则。

当您需要决定允许多大的值时，选择支持您现在和不久的将来需要的值的最小数据类型或宽度。更小的数据类型也意味着更少的空间用于行大小限制(64 kiB ),更多的数据可以放入 InnoDB 页面。由于 InnoDB 缓冲池可以根据缓冲池和页面的大小存储一定数量的页面，这反过来意味着可以将更多的数据放入缓冲池，从而有助于减少磁盘 I/O。同时，请记住，优化还意味着知道何时已经进行了足够的优化。不要花很长时间来删除几个字节，结果却不得不在一年内进行昂贵的表重建。

最后要考虑的是值是否包含在索引中。值越大，索引也越大。这是主键的一个特殊问题。InnoDB 根据主键(作为聚集索引)组织数据，因此当您添加辅助索引时，主键会添加到索引的末尾，以提供到行的链接。此外，这种数据组织方式意味着通常单调递增的值最适合作为主键。如果主键列随时间随机变化和/或很大，那么最好添加一个带有自动递增整数的伪列，并将其用作主键。

索引本身是一个重要的大主题，将在下一章讨论。

## 摘要

本章介绍了数据类型的概念。使用数据类型有几个好处:数据验证、文档、优化存储、性能和正确排序。

MySQL 支持大范围的数据类型，从字符串和空间对象上的简单整数到复杂的 JSON 文档。我们讨论了每种数据类型，重点是支持的值、支持的值大小以及所需的存储量。

本章的最后部分讨论了数据类型如何影响性能，以及如何确定为列选择哪种数据类型。这包括考虑列是否会被索引，这也涉及到数据类型的一个好处:正确的排序。索引是一个非常重要的主题，实际上下一章将会涉及到它们。

<aside aria-label="Footnotes" class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

严格来说，这并不正确，但这种解释是在较低的级别上进行的，例如，所使用的字节顺序。

  [2](#Fn2_source)

有几种不同的索引类型，它们的实现有很大的不同。并非所有索引类型都使用排序；大多数著名的散列索引计算值的散列。

 </aside>