# 七、向 MySQL 添加函数和命令

系统集成商面临的最大挑战之一是克服被集成系统的局限性。这通常是由于系统对集成有限制，或者没有集成所需的某些功能或命令。通常，这意味着通过创建更多的“粘合”程序来翻译或增强现有的功能和命令来解决问题。

MySQL 开发者认识到了这一需求，并在 MySQL 服务器中添加了灵活的选项来添加新的功能和命令。例如，您可能需要添加函数来执行一些计算或数据转换，或者您可能需要一个新命令来提供特定的管理数据。

本章向您介绍了可用于添加函数的选项，并向您展示了如何向服务器添加您自己的 SQL 命令。我们将探索用户定义的函数、本地函数和新的 SQL 命令。本章的大部分背景材料已经在前面的章节中介绍过了。在你继续学习的时候，请随意查阅这些章节。

添加用户自定义函数

MySQL 支持用户自定义函数(UDF)已经有一段时间了。UDF 是一个新功能(计算、转换等)。)，您可以将它添加到服务器中，从而扩展可以在 SQL 命令中使用的可用函数的列表。UDF 最好的一点是它们可以在运行时动态加载。此外，您可以创建自己的 UDF 库，并在您的企业中使用它们，甚至免费提供它们(作为开源)。这可能是系统集成商寻求扩展 MySQL 服务器的第一个地方。MySQL 工程师对 UDF 机制有另一个天才级的想法。

只要 SQL 语言允许使用表达式，就可以在任何地方使用用户定义函数。例如，您可以在存储过程和`SELECT`语句中使用 UDF。它们是扩展您的服务器而不必修改服务器源代码的极好方法。事实上，您可以定义任意多的 UDF，甚至可以将它们组合在一起形成函数库。每个库都是一个单独的文件，包含编译成库的源代码(Linux 中的`.so`或 Windows 中的`.dll`)。

该机制类似于插件接口，事实上，早于插件接口。UDF 接口利用外部的、可动态加载的目标文件来加载和卸载 UDF。该机制使用一个`CREATE FUNCTION`命令在每个函数的基础上建立到可加载目标文件的连接，并使用一个`DROP FUNCTION`命令删除函数的连接。让我们来看看这些命令的语法。

创建函数语法

`CREATE FUNCTION`命令向服务器注册函数，在 mysql.func 表中放置一行。语法是:

```sql
CREATE FUNCTION function_name RETURNS [STRING | INTEGER | REAL | DECIMAL] SONAME "mylib.so";
```

`function_name`参数代表您正在创建的函数的名称。返回类型可以是`STRING`、`INTEGER`、`REAL`或`DECIMAL`中的一种，`SONAME`表示库的名称。`CREATE FUNCTION`命令告诉 MySQL 服务器创建命令(`function_name`)中的函数名到目标文件的映射。当调用函数时，服务器调用库中的函数来执行。

DROP 函数语法

`DROP FUNCTION`命令通过从所选数据库的`func`表中删除相关的行，向服务器注销该函数。语法如下所示。`function_name`参数代表您正在创建的函数的名称。

```sql
DROP FUNCTION function_name;
```

让我们看看如何创建一个 UDF 库，并在 MySQL 服务器安装中使用它。我们将从修改现有的示例 UDF 库开始。一旦熟悉了函数的编码方式，创建一个新的源文件并将其添加到服务器构建文件(CMakeLists.txt)是一个基本的练习。

创建用户自定义库

有两种类型的用户定义函数:

*   您可以创建作为单个调用运行的函数，该调用计算一组参数并返回单个结果。
*   您可以创建函数，作为从分组函数中调用的聚合。例如，您可以创建将一种数据类型转换为另一种数据类型的 UDF，例如将日期字段从一种格式更改为另一种格式的函数，或者您可以创建对一组记录执行高级计算的函数，例如平方和函数。UDF 只能返回整数、字符串或实数值。
*   您可以创建提供 SELECT 语句中使用的值的函数。

单呼叫 UDF 是最常见的。它们用于对一个或多个参数执行操作。在某些情况下，不使用任何参数。例如，您可以创建一个 UDF，为全局状态或类似的`SERVER_STATUS()`返回值。这种形式的 UDF 通常用在`SELECT`语句的字段列表中，或者作为辅助函数用在存储过程中。

聚合 UDF 函数用于`GROUP BY`子句中。当它们被使用时，它们在表中的每一行被调用一次，在组的末尾再次被调用。

创建 UDF 库的过程是创建一个新项目，该项目公开 UDF 加载/卸载方法(`xxx_init`和`xxx_deinit`，其中`xxx`是函数的名称)和函数本身。每条语句调用一次`xxx_init`和`xxx_deinit`函数。每一行都会调用一次`XXX`函数。如果您正在创建一个聚合函数，您还需要实现分组函数`xxx_clear`和`xxx_add`。调用`xxx_clear`函数来重置值(在组的开始)。对分组中的每一行调用`xxx_add`函数，在分组处理结束时调用函数本身。因此，聚合被清除，然后为每个 add 调用添加数据。最后，调用函数本身来返回值。

一旦实现了这些函数，您就可以编译该文件并将其复制到服务器安装的插件目录中。您可以使用`CREATE FUNCTION`命令加载和使用这些功能。[清单 7-1](#list1) 展示了一组用于 UDF 的示例方法。

***[清单 7-1](#_list1) 。*** 样 UDF 战法

```sql
/*
  Simple example of how to get a sequences starting from the first
  argument or 1 if no arguments have been given
*/

my_bool sequence_init(UDF_INIT *initid, UDF_ARGS *args, char *message)
{
  if (args->arg_count > 1)
  {
    strmov(message,"This function takes none or 1 argument");
    return 1;
  }
  if (args->arg_count)
    args->arg_type[0]= INT_RESULT; /* Force argument to int */

  if (!(initid->ptr=(char*) malloc(sizeof(longlong))))
  {
    strmov(message,"Couldn't allocate memory");
    return 1;
  }
  memset(initid->ptr, 0, sizeof(longlong));
  /*
    sequence() is a non-deterministic function : it has different value
    even if called with the same arguments.
  */
  initid->const_item=0;
  return 0;
}

void sequence_deinit(UDF_INIT *initid)
{
  if (initid->ptr)
    free(initid->ptr);
}

longlong sequence(UDF_INIT *initid __attribute__((unused)), UDF_ARGS *args,
                  char *is_null __attribute__((unused)),
                  char *error __attribute__((unused)))
{
  ulonglong val=0;
  if (args->arg_count)
    val= *((longlong*) args->args[0]);
  return ++*((longlong*) initid->ptr) + val;
}
```

Oracle 提供了一个名为`udf_example.cc and`的示例 UDF 项目，它位于`/sql`文件夹中，包含您可能想要创建的所有类型的函数的示例。这为添加您自己的函数提供了一个极好的起点。示例函数包括:

*   在字符串上产生类似 soundex 操作的变音函数
*   一个示例函数，返回一个 double 值，该值是参数的字符代码值之和除以所有参数的长度之和
*   示例函数返回一个整数，该整数是参数长度的总和
*   基于传递的值返回序列中下一个值的序列函数
*   从整数参数(数量)和双参数(成本)列表中返回平均成本的示例聚合函数

根据您的需要，您可能会发现其中一些示例很有用。

让我们从修改示例 UDF 项目开始。找到位于源代码根目录下的`/sql`目录中的`udf_example.cc`文件，并在您喜欢的编辑器中打开它。因为 udf_example 库包含在 cmake 文件中，所以编译它非常容易。完成编辑后，只需执行 make 即可。在 Windows 上，可以使用 Visual Studio 重新生成 mysql.sln 文件。

![image](img/sq.jpg) **警告** Windows 用户必须从库中删除网络 UDF。Windows 不直接支持这些功能。如果遇到关于缺少头文件或外部函数的错误，请注释掉这些函数。

如果在编译过程中遇到错误，请返回并更正它们，然后再次尝试编译。最可能的原因是键入了错误的名称、不正确的代码替换或不正确的路径。

现在库已经编译好了，让我们测试加载和卸载操作。这将确保库已被正确编译并位于正确的位置。打开一个 MySQL 客户端窗口，发出`CREATE FUNCTION`和`DROP FUNCTION`命令来加载库中的所有函数。[清单 7-2](#list2) 显示了加载和卸载前五个函数的命令。该列表显示了用于 Windows 的命令；在 Linux 上用`udf_example.so`替换`udf_example.dll`。在执行这些函数的任何平台上，输出都是一样的。

***[清单 7-2](#_list2) 。*** 样本创建和删除功能命令

```sql
CREATE FUNCTION metaphon RETURNS STRING SONAME "udf_example.dll";
CREATE FUNCTION myfunc_double RETURNS REAL SONAME "udf_example.dll";
CREATE FUNCTION myfunc_int RETURNS INTEGER SONAME "udf_example.dll";
CREATE FUNCTION sequence RETURNS INTEGER SONAME "udf_example.dll";
CREATE AGGREGATE FUNCTION avgcost RETURNS REAL SONAME "udf_example.dll";

DROP FUNCTION metaphon;
DROP FUNCTION myfunc_double;
DROP FUNCTION myfunc_int;
DROP FUNCTION sequence;
DROP FUNCTION avgcost;
```

[清单 7-3](#list3) 和 [7-4](#list4) 显示了运行前面显示的`CREATE FUNCTION`和`DROP FUNCTION`命令时的正确结果。

***[清单 7-3](#_list3) 。*T5 安装功能**

```sql
mysql> CREATE FUNCTION metaphon RETURNS STRING SONAME "udf_example.dll";Query OK, 0 rows affected (0.00 sec)

mysql> CREATE FUNCTION myfunc_double RETURNS REAL SONAME "udf_example.dll";Query OK, 0 rows affected (0.00 sec)

mysql> CREATE FUNCTION myfunc_int RETURNS INTEGER SONAME "udf_example.dll";Query OK, 0 rows affected (0.00 sec)

mysql> CREATE FUNCTION sequence RETURNS INTEGER SONAME "udf_example.dll";Query OK, 0 rows affected (0.00 sec)

mysql> CREATE AGGREGATE FUNCTION avgcost RETURNS REAL SONAME "udf_example.dll";Query OK, 0 rows affected (0.00 sec)
```

***[清单 7-4](#_list4) 。*T5 卸载功能**

```sql
mysql> DROP FUNCTION metaphon;Query OK, 0 rows affected (0.00 sec)

mysql> DROP FUNCTION myfunc_double;Query OK, 0 rows affected (0.00 sec)

mysql> DROP FUNCTION myfunc_int;Query OK, 0 rows affected (0.00 sec)

mysql> DROP FUNCTION sequence;Query OK, 0 rows affected (0.00 sec) 
mysql> DROP FUNCTION avgcost;Query OK, 0 rows affected (0.00 sec)
```

现在，让我们运行命令，看看它们是否有效。回到 MySQL 客户端窗口，再次运行`CREATE FUNCTION`命令来加载 UDF。清单 7-5 展示了库中前五个 UDF 的执行示例。请随意尝试所示的命令。你的结果应该差不多。

***[清单 7-5](#_list5) 。*** 执行 UDF 命令的例子

```sql
mysql> SELECT metaphon("This is a test.");
+−−---------------------------+
| metaphon("This is a test.") |
+−−---------------------------+
| 0SSTS                       |
+−−---------------------------+
1 row in set (0.00 sec)

mysql> SELECT myfunc_double(5.5, 6.1);
+−−-----------------------+
| myfunc_double(5.5, 6.1) |
+−−-----------------------+
| 50.17                   |
+−−-----------------------+
1 row in set (0.01 sec)

mysql> SELECT myfunc_int(5, 6, 8);
+−−-------------------+
| myfunc_int(5, 6, 8) |
+−−-------------------+
| 19                  |
+−−-------------------+
1 row in set (0.00 sec)

mysql> SELECT sequence(8);
+−−-----------+
| sequence(8) |
+−−-----------+
| 9           |
+−−-----------+
1 row in set (0.00 sec)

mysql> CREATE TABLE testavg (order_num int key auto_increment, cost double, qty int);
Query OK, 0 rows affected (0.02 sec) 
mysql> INSERT INTO testavg (cost, qty) VALUES (25.5, 17);Query OK, 1 row affected (0.00 sec) 
mysql> INSERT INTO testavg (cost, qty) VALUES (0.23, 5);Query OK, 1 row affected (0.00 sec) 
mysql> INSERT INTO testavg (cost, qty) VALUES (47.50, 81);Query OK, 1 row affected (0.00 sec) 
mysql> SELECT avgcost(qty, cost) FROM testavg;
+−−------------------+
| avgcost(qty, cost) |
+−−------------------+
| 41.5743            |
+−−------------------+
1 row in set (0.03 sec)
```

最后几个命令展示了`avgcost()`聚合函数的一个非常基本的用法。在使用`GROUP BY`子句时，通常会使用聚合函数。

添加新的用户自定义函数

让我们现在添加一个新的 UDF 到库。如果您正在进行一个集成项目，并且需求要求用 Julian 格式表示日期，该怎么办？儒略历转换只是将一年中的某一天(自前一年的 12 月 31 日以来经过的天数)加上年份形成一个数值，如 DDDYYYY。在这种情况下，您需要添加一个函数，该函数接受月份、日期和年份值，并返回以儒略日表示的日期。该功能应定义为:

```sql
longlong julian(int month, int day, int year);
```

我保持了函数的简单，使用了三个整数。该函数可以以多种方式实现(例如，接受日期或字符串值)。现在让我们将`JULIAN`函数添加到您刚刚构建的 UDF 库中。

这就是创建你自己的 UDF 库的价值所在。任何时候你需要一个新的函数，你都可以把它添加到现有的库中，而不需要从头开始创建一个新的项目。

添加新 UDF 的过程从将函数声明添加到 UDF 库源代码的`extern`部分开始，然后实现这些函数。然后可以重新编译这个库，并将其部署到 MySQL 服务器安装的插件目录中。让我们用`JULIAN`函数来完成这个过程。

![image](img/sq.jpg) **注意**使用`SHOW VARIABLES LIKE 'plugin%';`发现插件目录。

打开`udf_example.cc`文件并添加函数声明。回想一下，您需要定义`julian_init()`、`julian_deinit()`和`julian()`函数。`julian_init()`函数有三个参数:

*   `UDF_INIT`，该方法可以用来在方法之间传递信息的结构
*   `UDF_ARGS`，一个包含参数数量、参数类型和参数本身的结构
*   发生错误时方法应返回的字符串

`julian()`方法有四个参数:

*   由`julian_init()`函数完成的`UDF_INIT`结构
*   一个包含参数数量、参数类型和参数的`UDF_ARGS`结构
*   如果结果为空，则指向设置为 1 的变量的 char 指针
*   发生错误时发送给调用方的消息

`julian_deinit()`函数使用由`julian_init()`函数完成的`UDF_INIT`结构。

当从服务器调用 UDF 时，一个新的`UDF_INIT`结构被创建并传递给函数，参数被放在`UDF_ARGS`结构中，然后调用`julian_init()`函数。如果那个函数没有错误地返回，那么从`julian_init()`函数中用`UDF_INIT`结构调用`julian()`函数。在`julian()`函数完成后，调用`julian_deinit()`函数来清除保存在`UDF_INIT`结构中的值。[清单 7-6](#list6) 显示了添加了`JULIAN`函数的文件的`declaration`部分的摘录。该部分用`C_MODE_START`和`C_MODE_END`宏表示，位于文件的顶部。我们包含了修改标记，以确保其他人(或者将来的我们自己)知道我们有意修改了这个文件。

***[清单 7-6](#_list6) 。*** 朱利安的声明 (udf_example.cc)

```sql
C_MODE_START;
...

/* BEGIN CAB MODIFICATION */
/* Reason for Modification: */
/* This section declares the methods for the Julian function */
my_bool julian_init(UDF_INIT *initid, UDF_ARGS *args, char *message);
longlong julian(UDF_INIT *initid, UDF_ARGS *args,
                char *is_null, char *error);
void julian_deinit(UDF_INIT *initid);
/* END CAB MODIFICATION */
...
C_MODE_END;
```

![image](img/sq.jpg) **注意**我们显示了用椭圆圈出的宏，以指示这些语句应该放在哪里。

现在可以添加这些函数的实现了。我发现复制与我的返回类型匹配的示例函数，然后修改它们以满足我的需要是很有帮助的。`julian_init()`函数负责初始化变量并检查正确的用法。由于`JULIAN`函数需要三个整数参数，您需要添加适当的错误处理来实现这一点。[清单 7-7](#list7) 展示了`julian_init()`功能的实现。您可以在 udf_example.cc 文件的末尾附近插入此方法。

***[清单 7-7](#_list7) 。*** 实现为 julian_init()函数(udf_example.cc)

```sql
/* BEGIN CAB MODIFICATION */
/* Reason for Modification: */
/* This section implements the Julian initialization function */
my_bool julian_init(UDF_INIT *initid, UDF_ARGS *args, char *message)
{
  if (args->arg_count != 3) /* if there are not three arguments */
  {
    strcpy(message, "Wrong number of arguments: JULIAN() requires 3 arguments.");
    return 1;
  }
  if ((args->arg_type[0] != INT_RESULT) ||
      (args->arg_type[1] != INT_RESULT) ||
      (args->arg_type[2] != INT_RESULT))
  {
    strcpy(message, "Wrong type of arguments: JULIAN() requires 3 integers.");
    return 1;
  }
  return 0;
}
/* END CAB MODIFICATION */
```

注意在[清单 7-7](#list7) 中，首先检查参数计数，然后是三个参数的类型检查。这确保了它们都是整数。精明的程序员会注意到代码还应该检查值的范围。由于代码不检查参数的范围，这可能导致异常或无效的返回值。如果您决定在您的库中实现该功能，我将把它留给您来完成。当参数值的定义域和范围已知时，检查范围值始终是一个好的做法。

实际上并不需要`julian_deinit()`函数，因为没有内存或变量需要清理。您可以实现一个空函数来完成这个过程。即使你不需要这个函数，编写它也是一个好主意。清单 7-8 展示了这个函数的实现。因为我们没有使用任何新的变量或结构，所以实现只是一个空函数。如果已经创建了变量或结构，您可以在这个函数中释放它们。

***[清单 7-8](#_list8) 。*** 实现为 julian_deinit()函数(udf_example.cc)

```sql
/* BEGIN CAB MODIFICATION */
/* Reason for Modification: */
/* This section implements the Julian deinitialization function */
void julian_deinit(UDF_INIT *initid)
{
}
/* END CAB MODIFICATION */
```

`JULIAN`函数的真正工作发生在`julian()`实现中。[清单 7-9](#list9) 显示了完整的`julian()`功能。

![image](img/sq.jpg) **注**一些复杂的儒略历方法计算从开始日期(通常是在 18 或 19 世纪)起经过的天数。此方法假设需要儒略日/年值。

***[清单 7-9](#_list9) 。*** 实现为 julian()函数(udf_example.cc)

```sql
/* BEGIN CAB MODIFICATION */
/* Reason for Modification: */
/* This section the Julian function */
longlong julian(UDF_INIT *initid, UDF_ARGS *args,
                char *is_null, char *error)
{
  longlong jdate = 0;
  static int DAYS_IN_MONTH[] = {31, 28, 31, 30, 31, 30, 31,
                                31, 30, 31, 30, 31};
  longlong month = 0;
  longlong day = 0;
  longlong year = 0;
  int i;

  /* copy memory from the arguments */
  month = *(longlong *)args->args[0];
  day = *(longlong *) args->args[1];
  year = *(longlong *) args->args[2];

  /* add the days in the month for each prior month */
  for (i = 0; i < month - 1; i++)
    jdate += DAYS_IN_MONTH[i];

  /* add the day of this month */
  jdate += day;

  /* find the year */
  if (((year % 100) != 0) && ((year % 4) == 0))
    jdate++;  /*leap year!*/

  /* shift day of year to left */
  jdate *= 10000;

  /* add the year */
  jdate += year;
  return jdate;
}
/* END CAB MODIFICATION */
```

注意变量声明后的前几行。这是一个如何将来自`args`数组的值封送到你自己的局部变量的例子。在本例中，我将前三个参数复制为整数值。源代码的其余部分是返回给调用者的儒略日值的计算。

![image](img/sq.jpg) **注**闰年的计算故意显得幼稚。我给你留了一个更正确的计算方法作为练习。提示:jdate 变量应该在什么时候递增？

如果使用的是 Windows，还需要修改`udf_example.def`文件，添加`JULIAN`函数的方法。[清单 7-10](#list10) 显示了更新后的`udf_example.def`文件。

***[清单 7-10](#_list10) 。*T5【UDF _ example . def】源代码**

```sql
LIBRARY       MYUDF
DESCRIPTION  'MySQL Sample for UDF'
VERSION       1.0
EXPORTS
  metaphon_init
  metaphon_deinit
  metaphon
  myfunc_double_init
  myfunc_double
  myfunc_int
  myfunc_int_init
  sequence_init
  sequence_deinit
  sequence
  avgcost_init
  avgcost_deinit
  avgcost_reset
  avgcost_add
  avgcost_clear
  avgcost
  julian_init
  julian_deinit
  julian
```

现在你可以编译这个库了。一旦库被编译，将库复制到 MySQL 服务器安装的插件目录中。如果你运行的是 Linux，你将会复制文件`udf_example.so`；如果你运行的是 Windows，你将从`/udf_example/debug`目录中复制文件`udf_example.dll`。

我建议在复制文件之前停止服务器，并在复制完成后重新启动它。这是因为目标文件可能与先前的编译不同(取决于您将新函数放在哪里)。每当您对可执行代码进行更改时，遵循这一点总是一个好的做法。

继续复制库并安装函数，然后输入`CREATE FUNCTION`命令并尝试新函数。[清单 7-11](#list11) 显示了在 Windows 上安装和运行`JULIAN`函数的例子。

***[清单 7-11](#_list11) 。*** 示例执行 julian()函数

```sql
mysql> CREATE FUNCTION julian RETURNS INTEGER SONAME "udf_example.dll";
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT JULIAN(8, 13, 2012);

+−−-------------------+
| JULIAN(8, 13, 2012) |
+−−-------------------+
| 2262012             |
+−−-------------------+
1 row in set (0.00 sec)
```

如果我想创建自己的库怎么办？

你可以使用`udf_example`库作为你自己库的开始，或者复制它并创建你的 UDF 库。要在`/sql`文件夹中编译您自己的 UDF 库，编辑`/sql/CMakeLists.txt`文件并复制下面的代码块，替换库名的`udf_example`。您需要在执行`make`命令之前重新运行`cmake`命令。

```sql
IF(WIN32 OR HAVE_DLOPEN AND NOT DISABLE_SHARED)
  ADD_LIBRARY(udf_example MODULE udf_example.cc)
  SET_TARGET_PROPERTIES(udf_example PROPERTIES PREFIX "")
  # udf_example depends on strings
  IF(WIN32)
    IF(MSVC)
SET_TARGET_PROPERTIES(udf_example PROPERTIES LINK_FLAGS "/DEF:${CMAKE_CURRENT_SOURCE_DIR}/udf_example.def")
    ENDIF()
    TARGET_LINK_LIBRARIES(udf_example strings)
  ELSE()
    # udf_example is using safemutex exported by mysqld
    TARGET_LINK_LIBRARIES(udf_example mysqld)
  ENDIF()
ENDIF()
```

UDF 库可以帮助您扩展服务器的能力，以满足几乎任何计算需求。这些库很容易创建，并且只需要少量的函数来实现。除了需要 Linux 的动态加载版本之外，UDF 工作得很好，没有什么特殊的配置需求。

添加本地函数

本地函数是作为 MySQL 服务器的一部分编译的函数。它们无需从库中加载就可以使用，因此它们总是可用的。它们还可以直接访问服务器内部，这是 UDF 所不具备的，从而允许本地函数响应或启动系统操作。从`ABS()`到`UCASE(),`等等，有一长串可用的本地函数。有关当前支持的本机函数集的更多信息，请参考在线 MySQL 参考手册。

如果您想要使用的函数不可用(它不是内置的本地函数之一)，您可以通过修改服务器源代码来添加自己的本地函数。现在您有了一个`JULIAN`函数，如果有一个等价的函数将儒略历日期转换回公历日期不是更好吗？在这一节中，我将向您展示如何添加一个新的本机函数。

添加新的本地函数的过程包括更改`mysqld`源代码文件。我们需要创建两个类:Item_func_gregorian 和 Create_func_gregorian。服务器为每个调用该函数的 SQL 语句实例化一次 Item _ func _ gregorian 然后它调用这个类的成员函数进行实际的计算，对结果集的每一行进行一次。Create_func_gregorian 仅在服务器启动时实例化一次。这个类只包含一个工厂成员函数，当服务器需要创建一个 Item_func_gregorian 的对象时调用这个函数..您需要更改的文件总结在[表 7-1](#Tab1) 中。

[表 7-1](#_Tab1) 。对 mysqld 源代码文件的更改，用于添加新的本机函数

| 文件 | 变更描述 |
| --- | --- |
| item_create.cc | 添加用于注册函数、帮助器方法和符号定义的函数类定义。 |
| 物料 _str_func.h | 添加函数类定义。 |
| item_str_func.cc | 添加 Gregorian 函数的实现。 |

![image](img/sq.jpg) **注意**文件位于源代码树根下的`/sql`目录中。

LEX [<sup>1</sup>](#Fn1) 文件怎么了？

熟悉 MySQL 5 . 6 . 5 之前的早期版本的读者可能还记得词法分析器文件 lex*和 sql_parse.yy。这些文件仍然在源代码文件中，但是 MySQL 开发者已经通过几乎完全消除修改 lex 和 yacc 代码的需要，使添加新的函数和命令变得更加容易。正如我们将在下一节中看到的，对于 SQL 命令，我们仍然必须这样做，但是对于函数和类似的扩展，代码进行了更改，以便更容易修改和删除创建新保留字的限制。新的保留字可以对想要在 SQL 语句中使用保留字的用户施加限制。

让我们开始添加公历函数注册码。打开`item_create.cc`文件，添加实例化，如[清单 7-12](#list12) 所示。您可以添加这个行号为 2000 的行，就在其他`Create_func_*`类定义的后面。

***[清单 7-12](#_list12) 。*T5 添加 Create_func_gregorian 类**

```sql
/* BEGIN CAB MODIFICATION */
/* Reason for Modification: */
/* Add gregorian class definition */
class Create_func_gregorian : public Create_func_arg1
{
public:
  virtual Item *create(THD *thd, Item *arg1);

  static Create_func_gregorian s_singleton;

protected:
  Create_func_gregorian() {}
  virtual ∼Create_func_gregorian() {}
};
/* END CAB MODIFICATION */
```

来自[清单 7-12](#list12) 的代码创建了一个类，解析器可以用它将格里高利函数(稍后定义)与`GREGORIAN`符号关联起来(参见[清单 7-14](#list14) )。这里的 Create 函数创建了一个`Create_func_gregorian`类的 singleton(所有线程都使用的类的单个实例),解析器可以用它来执行 Gregorian 函数。

接下来，我们为`Create_function_gregorian`方法本身添加代码。[清单 7-13](#list13) 显示了对这段代码的修改。您可以将这段代码放在文件中另一个`Create_func_`方法之后的第 4700 行。此代码用于返回 singleton 的实例，并执行 Gregorian 函数并返回其结果。这里是调用 Gregorian 函数并将结果返回给用户的地方。

***[清单 7-13](#_list13) 。*T5 添加 Create_func_gregorian 方法**

```sql
/* BEGIN CAB MODIFICATION */
/* Reason for Modification: */
/* Add gregorian singleton create method */
Create_func_gregorian Create_func_gregorian::s_singleton;

Item*
Create_func_gregorian::create(THD *thd, Item *arg1)
{
  return new (thd->mem_root) Item_func_gregorian(arg1);
}
/* END CAB MODIFICATION */
```

最后，我们必须添加格里高利符号。清单 7-14 显示了定义符号所需的代码。您必须将它放在定义以下数组的部分中。

```sql
static Native_func_registry func_array[] = {
```

我将代码放在了`GREATEST`符号定义之后，因为该数组旨在按字母顺序定义符号。

***[清单 7-14](#_list14) 。*** 添加公历符号

```sql
/* BEGIN CAB MODIFICATION */
/* Reason for Modification: */
/* Add gregorian symbol */
  { { C_STRING_WITH_LEN("GREGORIAN") }, BUILDER(Create_func_gregorian)},
/* END CAB MODIFICATION */
```

看一下符号定义。注意清单 7-14 中的[是如何用`Create_func_gregorian`类调用宏`BUILDER`的。调用宏是解析器将我们的公历代码与`GREGORIAN`符号关联起来的方式。您可能想知道当检测到符号时，如何使用这种关联来告诉解析器做什么。使用的机制被称为*词法哈希*。](#list14)

词汇散列是 Knuth 著作中的高级散列查找过程的实现。 [<sup>2</sup>](#Fn2) 它是使用实现算法的命令行实用程序生成的。实用程序`gen_lex_hash`有一个名为`gen_lex_hash.cc`的源代码文件。这个程序生成一个文件，你可以用它来替换现有的词法哈希头文件(`lex_hash.h`)。我把对`BUILDER`宏的探索留给你进一步研究。

既然 create 函数已经实现，您需要创建一个新的类来实现该函数的代码。这是大多数开发者非常困惑的地方。Oracle 提供了大量的`Item_xxx_func`基类(和派生类)供您使用。例如，对于返回字符串的函数，从`Item_str_func`派生您的类；对于返回整数的函数，从`Item_int_func`派生您的类。类似地，对于返回其他类型的函数，也有其他类。这背离了可动态加载的 UDF 接口，也是你选择创建本地函数而不是可动态加载的函数的主要原因。关于有哪些`Item_xxx_func`类的更多信息，请参见源代码树根下的`/sql`目录中的`item_func.h`文件。

由于 Gregorian 函数会返回一个字符串，所以需要从`Item_str_func`类派生，在`item_strfunc.h`中定义类，在`item_strfunc.cc`中实现类。打开`item_strfunc.h`文件，将类定义添加到头文件中，如[清单 7-15](#list15) 所示。

***[清单 7-15](#_list15) 。*T5 修改 item_strfunc.h 文件**

```sql
/* BEGIN CAB MODIFICATION */
/* Reason for Modification: */
/* Add gregorian Item function code */
class Item_func_gregorian :public Item_str_func
{
  String tmp_value;
public:
  Item_func_gregorian(Item *a) :Item_str_func(a) {}
  const char *func_name() const { return "gregorian"; }
  String *val_str(String *);
  void fix_length_and_dec()
  {
   max_length=30;
  }
};
/* END CAB MODIFICATION */
```

注意在[清单 7-15](#list15) 中的类只有四个必须声明的函数。所需的最小函数是构造函数(`Item_func_gregorian`)、包含执行转换的代码的函数(`val_str`)、返回名称的函数(`func_name`)以及设置字符串参数最大长度的函数(`fix_length_and_dec`)。您可以添加您可能需要的任何其他组件，但是这四个组件是返回字符串的函数所必需的。

其他的项目基类(和派生类)可能需要额外的函数，比如`val_int()`、`val_double()`等等。检查您需要从中派生的类的定义，以便标识必须重写的方法；这些被称为虚函数。

还要注意，我们在清单 7-15 的[中实现了一个`fix_length_and_dec()`方法，服务器用它来设置最大长度。在这种情况下，我们选择 30，这在很大程度上是任意的，但足够大，不会对我们返回的值造成问题。](#list15)

让我们添加类实现。打开`item_strfunc.cc`文件，添加如[清单 7-16](#list16) 所示的 Gregorian 类函数的实现。您需要实现主函数`val_str()`，它完成儒略历到公历的运算。在另一个`val_str()`实现之后，您可以将它放在文件的第 4030 行。

***[清单 7-16](#_list16) 。*T5 修改 item_strfunc.cc 文件**

```sql
/* BEGIN CAB MODIFICATION */
/* Reason for Modification: */
/* Add gregorian function code */
String *Item_func_gregorian::val_str(String *str)
{
  static int DAYS_IN_MONTH[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
  longlong jdate = args[0]->val_int();
  int year = 0;
  int month = 0;
  int day = 0;
  int i;
  char cstr[30];
  cstr[0] = 0;
  str->length(0);

  /* get date from value (right 4 digits */
  year = jdate - ((jdate / 10000) * 10000);

  /* get value for day of year and find current month*/
  day = (jdate - year) / 10000;
  for (i = 0; i < 12; i++)
    if (DAYS_IN_MONTH[i] < day)
      day = day - DAYS_IN_MONTH[i]; /* remainder is day of current month */
    else
    {
      month = i + 1;
      break;
    }

  /* format date string */
  sprintf(cstr, "%d", month);
  str->append(cstr);
  str->append("/");
  sprintf(cstr, "%d", day);
  str->append(cstr);
  str->append("/");
  sprintf(cstr, "%d", year);
  str->append(cstr);
  if (null_value)
    return 0;
  return str;
}
/* END CAB MODIFICATION */
```

编译和测试新的本地函数

重新编译你的服务器并重启它。如果您在编译期间遇到错误，请返回并检查您输入的语句是否有错误。一旦错误被纠正，您就有了一个新的可执行文件，停止您的服务器，将新的可执行文件复制到您的 MySQL 安装位置，然后重新启动服务器。现在可以执行本地函数 Gregorian，如[清单 7-17](#list17) 和[清单 7-18](#list18) 所示。为了测试 Gregorian 函数的正确性，首先运行`julian()`命令，并将该值作为`gregorian()`函数的输入。

***[清单 7-17](#_list17) 。*T5 运行 julian()函数**

```sql
mysql> select julian(8,15,2012);

+−−-----------------+
| julian(8,15,2012) |
+−−-----------------+
| 2272012           |
+−−-----------------+
1 row in set (0.00 sec)
```

***[清单 7-18](#_list18) 。*** 运行公历()函数

```sql
mysql> select gregorian(2272012);

+−−------------------+
| gregorian(2272012) |
+−−------------------+
| 8/15/2012          |
+−−------------------+
1 row in set (0.00 sec)
```

添加原生函数就这些了。现在您已经了解了如何创建本地函数，您可以进一步规划与 MySQL 的集成，以包括对服务器源代码的定制。

作为一个练习，考虑添加一个新函数来计算给定日期和时间之前的年数、月数、周数、天数和小时数。这个函数可以用来告诉你需要等待事件发生多长时间。从很多方面来说，这个功能是一种倒计时，比如到你下一个生日、周年纪念或者退休的倒计时。

添加 SQL 命令

如果本地 SQL 命令不能满足您的需求，并且您无法使用用户定义的函数解决问题，则可能需要向服务器添加新的 SQL 命令。本节将向您展示如何向服务器添加您自己的 SQL 命令。

许多人认为添加新的 SQL 命令是对 MySQL 服务器源代码最困难的扩展。正如您将看到的，这个过程并不复杂，也不乏味。要添加新的 SQL 命令，您必须修改解析器(在`sql/ql_yacc.yy`中)并将命令添加到 SQL 命令处理代码(在`sql/sql_parse.cc`中)，有时称为“大开关”

当客户机发出查询时，会创建一个新线程，并将 SQL 语句转发给解析器进行语法验证(或因错误而拒绝)。MySQL 解析器是使用大型的 Lex-YACC 脚本实现的，该脚本是用 Bison 编译的，使用名为 gen_lex_hash 的 MySQL 实用程序将符号转换成 hash，以便在 C 代码中使用。解析器构建一个查询结构，用于将内存中的查询语句(SQL)表示为可用于执行查询的数据结构。因此，要向解析器添加新命令，您需要一份 GNU Bison。你可以从 GNU 网站 [<sup>3</sup>](#Fn3) 下载 Bison 并安装。

什么是莱克斯和 YACC，谁是拜森？

lex 代表“词法分析器生成器”，被用作解析器来识别语言的标记、文字和语法。 YACC 代表“又一个编译器编译器”，用于识别和处理语言的语义定义。这些工具与 Bison(一个 YACC 兼容的解析器生成器，它从 Lex/YACC 代码生成 C 源代码)一起使用，提供了一个丰富的机制来创建可以解析和处理语言命令的子系统。事实上，这正是 MySQL 使用这些技术的方式。

假设您想要向服务器添加一个命令，以显示服务器中所有数据库的当前磁盘使用情况。虽然外部工具可以检索这些信息 [<sup>4</sup>](#Fn4) ，但是您希望有一个 SQL 等价函数，可以在您自己的数据库驱动的应用中轻松使用。我们还假设您想将它添加为一个`SHOW`命令。具体来说，您希望能够执行命令`SHOW DISK_USAGE`并检索一个结果集，该结果集将每个数据库列为一行，并以千字节为单位列出所有文件(表)的总大小。

添加新的 SQL 命令包括向词法分析器添加符号，向 YACC 分析器(`sql_yacc.yy`)添加`SHOW DISK_USAGE`命令语法。Bison 必须将新的解析器编译成 C 程序，然后使用前面描述的`gen_lex_hash`实用程序创建新的词法散列。解析器将控制指向新命令的代码放在`sql_parse.cc`的大 case 语句中，并带有新命令符号的 case。

让我们从向词法分析器添加符号开始。打开`lex.h`文件，找到`static SYMBOL symbols[]`数组。你可以把这个符号变成你想要的任何东西，但是它应该是有意义的东西(像所有好的变量名一样)。请确保选择一个尚未使用的符号。在这种情况下，使用符号`DISK_USAGE`。这对解析器来说就像一个标签，将它标识为一个标记。在数组中放置一条语句，指示词法分析器生成符号，并将其命名为`DISK_USAGE_SYM`。这个列表是按照字母顺序排列的，所以把它放在合适的位置。[清单 7-19](#list19) 显示了添加了符号的数组的摘录。

***[清单 7-19](#_list19) 。*** 对 SHOW DISK_USAGE 命令的 lex.h 文件的更新

```sql
static SYMBOL symbols[] = {
  { "&&",    SYM(AND_AND_SYM)},
...
  { "DISK",    SYM(DISK_SYM)},
/* BEGIN CAB MODIFICATION */
/* Reason for Modification: */
/* This section identifies the tokens for the SHOW DISK_USAGE command*/
  { "DISK_USAGE",           SYM(DISK_USAGE_SYM)},
/* END CAB MODIFICATION */
  { "DISTINCT",    SYM(DISTINCT)},
...
```

接下来您需要做的是添加一个助记符来标识该命令。该助记符将在解析器中用于分配给内部查询结构，并通过`sql_parse.cc`文件中大型 switch 语句中的 case 来控制执行流。打开`sql_cmd.h`文件，将新命令添加到`enum_sql_command`枚举中。[清单 7-20](#list20) 显示了新命令助记符的修改。

***[清单 7-20](#_list20) 。*T5【SHOW DISK _ USAGE 命令对 sql_cmd.h 文件的修改**

```sql
enum enum_sql_command {
...
  SQLCOM_SHOW_SLAVE_HOSTS, SQLCOM_DELETE_MULTI, SQLCOM_UPDATE_MULTI,
  SQLCOM_SHOW_BINLOG_EVENTS, SQLCOM_DO,
  SQLCOM_SHOW_WARNS, SQLCOM_EMPTY_QUERY, SQLCOM_SHOW_ERRORS,
  SQLCOM_SHOW_STORAGE_ENGINES, SQLCOM_SHOW_PRIVILEGES,
/* BEGIN CAB MODIFICATION */
/* Reason for Modification: */
/* Add SQLCOM_SHOW_DISK_USAGE reference */
  SQLCOM_SHOW_STORAGE_ENGINES, SQLCOM_SHOW_PRIVILEGES, SQLCOM_SHOW_DISK_USAGE,
/* END CAB MODIFICATION */
  SQLCOM_HELP, SQLCOM_CREATE_USER, SQLCOM_DROP_USER, SQLCOM_RENAME_USER,
  SQLCOM_REVOKE_ALL, SQLCOM_CHECKSUM,
  SQLCOM_CREATE_PROCEDURE, SQLCOM_CREATE_SPFUNCTION, SQLCOM_CALL,
...
```

现在您已经有了新的符号和命令助记符，向`sql_yacc.yy`文件添加代码来定义您在`lex.h`文件中使用的新令牌，并添加新的`SHOW DISK_USAGE` SQL 命令的源代码。打开`sql_yacc.yy`文件，将新令牌添加到令牌列表中(靠近顶部)。这些都是按字母顺序定义的(粗略地)，所以要按正确的顺序放置新的令牌。[清单 7-21](#list21) 显示了对`sql_yacc.yy`文件的修改。

***[清单 7-21](#_list21) 。*T5】向 sql_yacc.yy 文件添加令牌**

```sql
...
%token  DISK_SYM
/* BEGIN CAB MODIFICATION */
/* Reason for Modification: */
/* Add DISK_USAGE symbol */
%token  DISK_USAGE_SYM
/* END CAB MODIFICATION */
%token  DISTINCT                      /* SQL-2003-R */
%token  DIV_SYM
%token  DOUBLE_SYM                    /* SQL-2003-R */
...
```

您还需要将命令语法添加到解析器 YACC 代码中(也在`sql_yacc.yy`中)。找到`show:`标签并添加命令，如[清单 7-22](#list22) 所示。

***[清单 7-22](#_list22) 。*** 解析器语法源代码为 SHOW DISK_USAGE 命令

```sql
/* Show things */

show:
/* BEGIN CAB MODIFICATION */
/* Reason for Modification: */
/* Add show disk usage symbol parsing */
       SHOW DISK_USAGE_SYM
          {
              LEX *lex=Lex;
              lex->sql_command= SQLCOM_SHOW_DISK_USAGE;
         }
        |
/* END CAB MODIFICATION */
          SHOW
          {
```

![image](img/sq.jpg) **小心**别忘了原来`SHOW`语句前的`|`。

您可能想知道这段代码是做什么的。这看起来相当不错，但重要的是要把这一部分做好。事实上，这是大多数开发者放弃和添加新命令失败的阶段。

每当解析器识别出`SHOW`标记时，就会执行由`show:`标签识别的代码集。YACC 代码几乎总是这样写的。[<sup>5</sup>](#Fn5)`SHOW DISK_USAGE_SYM`语句表示出现了`SHOW`和`DISK_USAGE`标记的唯一有效语法(按此顺序)。如果您浏览代码，您会发现其他类似的语法安排。语法语句后面的代码块获得一个指向`lex`结构的指针，并将`command`属性设置为新的命令标记`SQLCOM_SHOW_DISK_USAGE`。这段代码将`SHOW`和`DISK_USAGE_SYM`符号与`SQLCOM_SHOW_DISK_USAGE`命令匹配，以便`sql_parse.cc`文件中的 SQL 命令开关能够正确地将执行路由到`SHOW DISK_USAGE`命令的实现。

还要注意，我将这段代码放在了`show:`定义的开头，并在前面的`SHOW`语法语句前面使用了竖线符号(`|`)。竖线用作语法开关的“或”。因此，当且仅当语句满足语法语句定义之一时，该语句才有效。请随意查看这个文件，感受一下代码是如何工作的。不要为学习每一个细节而焦虑。我向您展示的是创建一个新命令所需的最基本的知识。如果您决定实现更复杂的命令，请研究类似命令的示例，看看它们是如何处理令牌和变量的。

接下来，将源代码添加到`sql_parse.cc`中的大型命令语句开关中。打开文件并向 switch 语句添加一个新的 case，如清单 7-23 所示。

***[清单 7-23](#_list23) 。*T5 为新命令添加一个案例**

```sql
...
  case SQLCOM_SHOW_AUTHORS:
    res= mysqld_show_authors(thd);
    break;
/* BEGIN CAB MODIFICATION */
/* Reason for Modification: */
/* Add SQLCOM_SHOW_DISK_USAGE case statement */
 case SQLCOM_SHOW_DISK_USAGE:
   res = show_disk_usage_command(thd);
   break;
/* END CAB MODIFICATION */
  case SQLCOM_SHOW_CONTRIBUTORS:
    res= mysqld_show_contributors(thd);
    break;
...
```

注意，我刚刚添加了一个对名为`show_disk_usage_command()`的新函数的调用。您将把这个函数添加到`sql_show.cc`文件中。该函数的名称与`lex.h`文件中的标记、`sql_yacc.yy`文件中的符号以及`sql_parse.cc`文件中的命令开关相匹配。这不仅清楚地表明了正在发生什么，还有助于将已经很大的 switch 语句限制在一定范围内。请随意查看这个文件，因为它是执行命令语句流的核心。您应该能够找到所有的命令，比如`SELECT`、`CREATE`等等。

现在，让我们添加执行命令的代码。打开`sql_show.h`文件，添加新命令的函数声明，如[清单 7-24](#list24) 所示。我将函数声明放在了与在`sql_parse.cc`文件中定义的相同的函数附近。这不是必需的，但它有助于组织代码。

***[清单 7-24](#_list24) 。*的**功能声明为新命令

```sql
...
int mysqld_show_variables(THD *thd,const char *wild);
bool mysqld_show_storage_engines(THD *thd);
bool mysqld_show_authors(THD *thd);
/* BEGIN CAB MODIFICATION */
/* Reason for Modification: */
/* Add show disk usage method reference */
bool show_disk_usage_command(THD *thd);
/* END CAB MODIFICATION */
bool mysqld_show_contributors(THD *thd);
bool mysqld_show_privileges(THD *thd);
...
```

最后的修改是添加了`show_disk_usage_command()`函数的实现([清单 7-25](#list25) )。打开`sql_show.cc`文件，添加新命令的函数实现。清单 7-25 中的代码被删除。这是为了确保在我添加任何代码之前，新命令能够工作。如果您必须实现复杂的代码，这是一个很好的实践。只实现基本功能有助于确定您的代码更改正在工作，并且遇到的任何错误都与存根代码无关。每当修改或添加新的 SQL 命令时，遵循这一实践尤其重要。

***[清单 7-25](#_list25) 。*T5【show _ disk _ usage _ command】实现**

```sql
/* BEGIN CAB MODIFICATION */
/* Reason for Modification: */
/* Add show disk usage method */
bool show_disk_usage_command(THD *thd)
{
  List<Item> field_list;
  Protocol *protocol= thd->protocol;
  DBUG_ENTER("show_disk_usage");

  /* send fields */
  field_list.push_back(new Item_empty_string("Database",50));
  field_list.push_back(new Item_empty_string("Size_in_bytes",30));

  if (protocol->send_result_set_metadata(&field_list,
                            Protocol::SEND_NUM_ROWS |
                            Protocol::SEND_EOF))
    DBUG_RETURN(TRUE);

  /* send test data */
  protocol->prepare_for_resend();
  protocol->store("test_row", system_charset_info);
  protocol->store("1024", system_charset_info);
  if (protocol->write())
    DBUG_RETURN(TRUE);

  my_eof(thd);
  DBUG_RETURN(FALSE);
 }

/* END CAB MODIFICATION */
```

我想提醒大家注意一下源代码。如果您还记得，在前面的章节中，我提到过一些底层的网络函数，它们允许您构建一个结果集并将其返回给客户端。查看由`/* send fields */`注释指示的代码行。这段代码为结果集创建字段。在本例中，我创建了两个字段(或列)，名为`Database`和`Size_in_bytes`。当执行该命令时，它们将在 MySQL 客户端实用程序中显示为列标题。

请注意`protocol->XXX`语句。这是我使用`Protocol`类向客户端发送行的地方。我首先调用`prepare_for_resend()`来清空缓冲区，然后尽可能多地调用重载的`store()`方法来设置每个字段的值(按顺序)。最后，我调用`write()`方法将缓冲区写入网络。如果有任何错误，我会以 true 值退出函数(这意味着产生了错误)。结束结果集并结束与客户机通信的最后一个语句是`my_eof()`函数，它向客户机发送一个文件结束信号。您可以使用这些相同的类、方法和函数来发送命令的结果。

磁盘使用 SYM 的编译错误

如果您想编译服务器，您可以，但是您可能会遇到关于`DISK_USAGE_SYM`符号的错误。如果构建服务器时没有使用 cmake 或者跳过了 cmake 步骤，就会发生这种情况。以下内容将帮助您解决这些问题。

如果你一直在研究 MySQL 源代码，你可能已经注意到有`sql_yacc.cc`和`sql_yacc.h`文件。这些文件是由 Bison 从`sql_yacc.yy`文件生成的。让我们使用 Bison 来生成这些文件。打开一个命令窗口，导航到源代码根目录下的`/sql`目录。运行命令:

bison–y–p MySQL–d SQL _ yacc . YY

这会生成两个新文件:`y.tab.c`和`y.tab.h`。这些文件将分别取代`sql_yacc.cc`和`sql_yacc.h`文件。在复制它们之前，请备份原始文件。备份文件后，将`y.tab.c`复制到`sql_yacc.cc`，将`y.tab.h`复制到`sql_yacc.h`。

一旦`sql_yacc.cc`和`sql_yacc.h`文件正确，通过运行以下命令生成词法哈希:

gen_lex_hash > lex_hash.h

现在已经为编译服务器做好了一切准备。由于您已经修改了许多关键头文件，您可能会遇到比正常情况下更长的编译时间。如果您遇到编译错误，请在继续之前更正它们。

但是，如果使用 debug 编译代码，您可能会在`mysqld.cc`中遇到编译错误。如果出现这种情况，很可能是调用了一个`compile_time_assert()`宏。如果是这种情况，修改代码如下，以补偿`com_status_vars`枚举数的差异。

```sql
compile_time_assert(sizeof(com_status_vars)/
                                   sizeof(com_status_vars[0]) - 1 == SQLCOM_END + 8–1);
```

一旦服务器编译完成，您就有了一个新的可执行文件，停止您的服务器，将新的可执行文件复制到您的 MySQL 安装位置，然后重新启动服务器。现在，您可以在 MySQL 客户端实用程序中执行新命令。[清单 7-26](#list26) 显示了一个`SHOW DISK_USAGE`命令的例子。

***[清单 7-26](#_list26) 。*** 显示磁盘使用命令的执行示例

```sql
mysql> SHOW DISK_USAGE;

+−−--------+−−-------------+
| Database | Size_in_bytes |
+−−--------+−−-------------+
| test_row | 1024          |
+−−--------+−−-------------+
1 row in set (0.00 sec)
```

现在一切都正常了，打开`sql_show.cc`文件并添加`SHOW DISK_USAGE`命令的实际代码，如[清单 7-27](#list27) 所示。

***[清单 7-27](#_list27) 。*T5【最终展示 _ 磁盘 _ 用法 _ 命令】源代码**

```sql
/* This section adds the code to call the new SHOW DISK_USAGE command. */
/* BEGIN CAB MODIFICATION */
/* Reason for Modification: */
/* Add show disk usage method */
bool show_disk_usage_command(THD *thd)
{
  List<Item> field_list;
  List<LEX_STRING> dbs;
  LEX_STRING *db_name;
  char *path;
  MY_DIR *dirp;
  FILEINFO *file;
  longlong fsizes = 0;
  longlong lsizes = 0;
  Protocol *protocol= thd->protocol;
  DBUG_ENTER("show_disk_usage");

  /* send the fields "Database" and "Size" */
  field_list.push_back(new Item_empty_string("Database",50));
  field_list.push_back(new Item_return_int("Size_in_bytes", 7,
                       MYSQL_TYPE_LONGLONG));
  if (protocol->send_result_set_metadata(&field_list,
                                         Protocol::SEND_NUM_ROWS |
                                         Protocol::SEND_EOF))
    DBUG_RETURN(TRUE);

  /* get database directories */
  find_files_result res = find_files(thd, &dbs, 0, mysql_data_home,0,1);
  if (res != FIND_FILES_OK)
    DBUG_RETURN(1);
  List_iterator_fast<LEX_STRING> it_dbs(dbs);
  path = (char *)my_malloc(PATH_MAX, MYF(MY_ZEROFILL));
  dirp = my_dir(mysql_data_home, MYF(MY_WANT_STAT));
  fsizes = 0;
  for (int i = 0; i < (int)dirp->number_off_files; i++)
  {
    file = dirp->dir_entry + i;
    if (strncasecmp(file->name, "ibdata", 6) == 0)
      fsizes = fsizes + file->mystat->st_size;
    else if (strncasecmp(file->name, "ib", 2) == 0)
      lsizes = lsizes + file->mystat->st_size;
  }

  /* send InnoDB data to client */
  protocol->prepare_for_resend();
  protocol->store("InnoDB TableSpace", system_charset_info);
  protocol->store((longlong)fsizes);
  if (protocol->write())
    DBUG_RETURN(TRUE);
  protocol->prepare_for_resend();
  protocol->store("InnoDB Logs", system_charset_info);
  protocol->store((longlong)lsizes);
  if (protocol->write())
    DBUG_RETURN(TRUE);

  /* now send database name and sizes of the databases */
  while ((db_name = it_dbs++))
  {
    fsizes = 0;
    strcpy(path, mysql_data_home);
    strcat(path, "/");
    strcat(path, db_name->str);
    dirp = my_dir(path, MYF(MY_WANT_STAT));
    for (int i = 0; i < (int)dirp->number_off_files; i++)
    {
      file = dirp->dir_entry + i;
      fsizes = fsizes + file->mystat->st_size;
    }

    protocol->prepare_for_resend();
    protocol->store(db_name->str, system_charset_info);
    protocol->store((longlong)fsizes);
    if (protocol->write())
      DBUG_RETURN(TRUE);
  }
  my_eof(thd);

  /* free memory */
  my_free(path);
  my_dirend(dirp);
  DBUG_RETURN(FALSE);
 }

/* END CAB MODIFICATION */
```

![image](img/sq.jpg) **注意**在 Windows 上，您可能需要在`my_malloc()`调用中用`MAX_PATH`代替`PATH_MAX`，用`strnicmp`代替`strncasecmp`。

当您编译并加载服务器，然后运行该命令时，您应该会看到类似于清单 7-28 中的示例。

***[清单 7-28](#_list28) 。*** 新 SHOW DISK_USAGE 命令的执行示例

```sql
mysql> show disk_usage;
+−−------------------+−−-------------+
| Database           | Size_in_bytes |
+−−------------------+−−-------------+
| InnoDB TableSpace  |  77594624     |
| InnoDB Logs        |  10485760     |
| mtr                |     33423     |
| mysql              |    844896     |
| performance_schema |    493595     |
| test               |      8192     |
+−−------------------+−−-------------+
6 rows in set (0.00 sec)

mysql>
```

该列表显示了 MySQL 数据目录中服务器上每个数据库的累积大小。您可能想做的一件事是添加一行，返回所有已用磁盘空间的总和(很像一个`WITH ROLLUP`子句)。我将这一修改留给您，让您在尝试实现该函数时完成。

我希望这篇关于创建新 SQL 命令的短文已经帮助消除了围绕 MySQL SQL 命令处理源代码的一些困惑和困难。现在您已经有了这些信息，您可以规划您自己的 MySQL 命令扩展来满足您自己的独特需求。

添加到信息模式

本章中我想讨论的最后一个领域是向信息模式中添加信息。*信息模式*是内存中逻辑表的集合，包含关于服务器及其环境的状态和其他相关数据(也称为*元数据*)。版本 5.0.2 中引入的信息模式已经成为管理和调试 MySQL 服务器、其环境和数据库的重要工具。 [<sup>6</sup>](#Fn6) 例如，通过使用以下 SQL 命令，信息模式可以轻松显示数据库中所有表的所有列:

```sql
SELECT table_name, column_name, data_type FROM information_schema.columns
WHERE table_schema = 'test';
```

元数据被分组到逻辑表中，允许您对它们发出`SELECT`命令。创建一个`INFORMATION_SCHEMA`视图的最大优势之一是使用`SELECT`命令。具体来说，您可以使用一个`WHERE`子句将输出限制为匹配的行。这提供了一种获取服务器信息的独特而有用的方法。[表 7-2](#Tab2) 列出了一些逻辑表及其用途。

[表 7-2](#_Tab2) 。信息模式逻辑表

| 名字 | 描述 |
| --- | --- |
| 概要 | 提供有关数据库的信息。 |
| 桌子 | 提供有关所有数据库中的表的信息。 |
| 列 | 提供有关所有表中的列的信息。 |
| 统计数字 | 提供了有关表索引的信息。 |
| 用户 _ 权限 | 提供了有关数据库权限的信息。它封装了 mysql.db grant 表。 |
| 表 _ 权限 | 提供了有关表权限的信息。它封装了 mysql.tables_priv grant 表。 |
| 列 _ 权限 | 提供了有关列权限的信息。它封装了 mysql.columns_priv grant 表。 |
| 校对 | 提供有关字符集排序规则的信息。 |
| 关键字 _ 列 _ 用途 | 提供有关键列的信息。 |
| 例行公事 | 提供有关过程和函数的信息(不包括用户定义的函数)。 |
| 视图 | 提供有关所有数据库中视图的信息。 |
| 扳机 | 提供有关所有数据库中触发器的信息。 |

因为 disk-usage 命令属于元数据的范畴，所以我将向您展示如何将它添加到服务器的信息模式机制中。这个过程实际上非常简单，不需要修改`sql_yacc.yy`代码或词法哈希。相反，您可以在为磁盘使用函数创建数据(行)的函数中为 switch 语句添加一个枚举和一个 case，定义一个结构来保存表的列，然后添加源代码来执行它。

让我们从修改新枚举的头文件开始。打开`handler.h`文件并找到`enum_schema_tables`枚举。向列表中添加一个名为`SCH_DISKUSAGE`的新枚举。清单 7-29 显示了添加了新枚举的枚举摘录。

***[清单 7-29](#_list29) 。*T5 对 enum_schema_tables 枚举的修改**

```sql
enum enum_schema_tables
{
...
  SCH_COLLATION_CHARACTER_SET_APPLICABILITY,
  SCH_COLUMNS,
  SCH_COLUMN_PRIVILEGES,
/* BEGIN CAB MODIFICATION */
/* Reason for Modification: */
/* Add case enum for the new SHOW DISK_USAGE view. */
  SCH_DISKUSAGE,
/* END CAB MODIFICATION */
  SCH_ENGINES,
  SCH_EVENTS,
  SCH_FILES,
...
```

现在您需要在创建新模式表的`prepare_schema_tables()`函数中添加 switch 命令的案例。打开`sql_parse.cc`文件，添加清单 7-30 中[所示的 case 语句。请注意，我只是添加了没有中断语句的案例。这允许代码落入满足所有情况的代码。这是大多数源代码中冗长的`if-then-else-if`语句的优雅替代。](#list30)

***[清单 7-30](#_list30) 。*** 对 prepare_schema_table 函数的修改

```sql
int prepare_schema_table(THD *thd, LEX *lex, Table_ident *table_ident,
                         enum enum_schema_tables schema_table_idx)
{
...
  DBUG_ENTER("prepare_schema_table");

  switch (schema_table_idx) {
/* BEGIN CAB MODIFICATION */
/* Reason for Modification: */
/* Add case statement for the new SHOW DISK_USAGE view. */
  case SCH_DISKUSAGE:
/* END CAB MODIFICATION */
  case SCH_SCHEMATA:
#if defined(DONT_ALLOW_SHOW_COMMANDS)
    my_message(ER_NOT_ALLOWED_COMMAND,
...
```

您可能已经注意到，我将磁盘使用模式表称为`DISKUSAGE`。我这样做是因为已经在解析器和词法哈希中定义了`DISK_USAGE`标记。如果我使用`DISK_USAGE`并发出命令`SELECT * FROM DISK_USAGE`，我会得到一个错误。这是因为解析器将`DISK_USAGE`标记与`SHOW`命令相关联，而不是与`SELECT`命令相关联。

现在我们到了最后一组代码更改。您需要添加一个结构，信息模式函数可以用它来创建表的字段列表。打开`sql_show.cc`文件并添加一个类型为`ST_FIELD_INFO`的新数组，如[清单 7-31](#list31) 所示。请注意，这些列的名称和类型与`show_disk_usage_command()`中的相同。

***[清单 7-31](#_list31) 。*T5【磁盘使用模式表】新字段信息结构**

```sql
/* BEGIN CAB MODIFICATION */
/* Reason for Modification: */
/* This section adds the code to call the new SHOW DISK_USAGE command. */
ST_FIELD_INFO disk_usage_fields_info[]=
{
  {"DATABASE", 40, MYSQL_TYPE_STRING, 0, 0, NULL, SKIP_OPEN_TABLE},
  {"Size_in_bytes", 21 , MYSQL_TYPE_LONG, 0, 0, NULL, SKIP_OPEN_TABLE },
  {0, 0, MYSQL_TYPE_STRING, 0, 0, 0, SKIP_OPEN_TABLE}
};
/* END CAB MODIFICATION */
```

您需要做的下一个更改是在`schema_tables`数组中添加一行(也在`sql_show.cc`中)。找到数组并添加一个类似于清单 7-32 所示的语句。这说明新表名为 DISKUSAGE，列定义由 disk_usage_fields_info 指定，Create_schema_table 将用于创建表，fill_disk_usage 将用于填充表。`make_old_format`告诉代码确保显示列名。最后四个参数是一个指针，指向一个对表进行一些额外处理的函数、两个索引字段和一个表示它是一个隐藏表的`bool`变量。在示例中，我将指向函数的指针设置为`NULL (0)`；`–1`表示索引未使用，`0`表示表格未隐藏。

***[清单 7-32](#_list32) 。*T5 对 schema_tables 数组的修改**

```sql
ST_SCHEMA_TABLE schema_tables[]=
{
...
  {"ENGINES", engines_fields_info, create_schema_table,
   fill_schema_engines, make_old_format, 0, -1, -1, 0, 0},
/* BEGIN CAB MODIFICATION */
/* Reason for Modification: */
/* This section adds the code to call the new SHOW DISK_USAGE command. */
  {"DISKUSAGE", disk_usage_fields_info, create_schema_table,
   fill_disk_usage, make_old_format, 0, -1, -1, 0, 0},
/* END CAB MODIFICATION */
 #ifdef HAVE_EVENT_SCHEDULER
 {"EVENTS", events_fields_info, create_schema_table,
   fill_schema_events, make_old_format, 0, -1, -1, 0, 0},
...
```

好了，我们到了最后阶段。剩下的就是实现`fill_disk_usage()`函数了。从`schema_tables`数组 [<sup>7</sup>](#Fn7) 向上滚动，插入`fill_disk_usage()`函数的实现，如[清单 7-33](#list33) 所示。

***[清单 7-33](#_list33) 。*T5【fill _ disk _ usage】函数实现**

```sql
/* BEGIN CAB MODIFICATION */
/* Reason for Modification: */
/* Add code to fill the output for the new SHOW DISK_USAGE view. */
int fill_disk_usage(THD *thd, TABLE_LIST *tables, Item *cond)
{
  TABLE *table= tables->table;
  CHARSET_INFO *scs= system_charset_info;
  List<Item> field_list;
  List<LEX_STRING> dbs;
  LEX_STRING *db_name;
  char *path;
  MY_DIR *dirp;
  FILEINFO *file;
  longlong fsizes = 0;
  longlong lsizes = 0;
  DBUG_ENTER("fill_disk_usage");

  find_files_result res = find_files(thd, &dbs, 0, mysql_data_home,0,1);
  if (res != FIND_FILES_OK)
    DBUG_RETURN(1);
  List_iterator_fast<LEX_STRING> it_dbs(dbs);
  path = (char *)my_malloc(PATH_MAX, MYF(MY_ZEROFILL));
  dirp = my_dir(mysql_data_home, MYF(MY_WANT_STAT));
  fsizes = 0;
  for (int i = 0; i < (int)dirp->number_off_files; i++)
  {
    file = dirp->dir_entry + i;
    if (strncasecmp(file->name, "ibdata", 6) == 0)
      fsizes = fsizes + file->mystat->st_size;
    else if (strncasecmp(file->name, "ib", 2) == 0)
      lsizes = lsizes + file->mystat->st_size;
  }

  /* send InnoDB data to client */
  table->field[0]->store("InnoDB TableSpace",
                         strlen("InnoDB TableSpace"), scs);
  table->field[1]->store((longlong)fsizes, TRUE);
  if (schema_table_store_record(thd, table))
    DBUG_RETURN(1);
  table->field[0]->store("InnoDB Logs", strlen("InnoDB Logs"), scs);
  table->field[1]->store((longlong)lsizes, TRUE);
  if (schema_table_store_record(thd, table))
    DBUG_RETURN(1);

  /* now send database name and sizes of the databases */
  while ((db_name = it_dbs++))
  {
    fsizes = 0;
    strcpy(path, mysql_data_home);
    strcat(path, "/");
    strcat(path, db_name->str);
    dirp = my_dir(path, MYF(MY_WANT_STAT));
    for (int i = 0; i < (int)dirp->number_off_files; i++)
    {
      file = dirp->dir_entry + i;
      fsizes = fsizes + file->mystat->st_size;
    }
    restore_record(table, s->default_values);

    table->field[0]->store(db_name->str, db_name->length, scs);
    table->field[1]->store((longlong)fsizes, TRUE);
    if (schema_table_store_record(thd, table))
      DBUG_RETURN(1);
  }

  /* free memory */
  my_free(path);
  DBUG_RETURN(0);
}
/* END CAB MODIFICATION */
```

![image](img/sq.jpg) **注意**在 Windows 上，用`MAX_PATH`代替`my_malloc()`调用中的`PATH_MAX`，用`strnicmp`代替`strncasecmp`。

我复制了前面的`DISK_USAGE`命令的代码，删除了创建字段的调用(通过`disk_usage_fields_info array`处理)和向客户端发送行的代码。相反，我使用了一个`TABLE`类/结构的实例来存储`fields`数组中的值，从第一列的零开始。对函数`schema_table_store_record()`的调用将值转储到网络协议。

现在已经为编译服务器做好了一切准备。由于您已经修改了其中一个关键头文件(`handler.h`)，您可能会遇到比正常情况下更长的编译时间，因为可能需要编译`mysqld`项目的一些依赖项。如果您遇到编译错误，请在继续之前更正它们。

一旦服务器编译完成，您就有了一个新的可执行文件，停止您的服务器，将新的可执行文件复制到您的 MySQL 安装位置，然后重新启动服务器。现在，您可以在 MySQL 客户端实用程序中执行新命令。清单 7-34 展示了一个使用信息模式的例子，显示所有可用的模式表，并转储新的`DISKUSAGE`表的内容。

***[清单 7-34](#_list34) 。*T5】示例信息模式与新磁盘使用模式一起使用表**

```sql
mysql> use INFORMATION_SCHEMA;
Database changed

mysql> SHOW TABLES LIKE 'DISK%';
+−−------------------------------------+
| Tables_in_information_schema (DISK%) |
+−−------------------------------------+
| DISKUSAGE                            |
+−−------------------------------------+
1 row in set (0.00 sec)

mysql> SELECT * from DISKUSAGE;
+−−------------------+−−-------------+
| DATABASE           | Size_in_bytes |
+−−------------------+−−-------------+
| InnoDB TableSpace  |  77594624     |
| InnoDB Logs        |  10485760     |
| mtr                |     33423     |
| mysql              |    844896     |
| performance_schema |    493595     |
| test               |      8192     |
+−−------------------+−−-------------+
6 rows in set (0.00 sec)

mysql>
```

既然您已经知道了如何添加到信息模式中，那么您可以添加的内容就没有限制了，这样您的数据库专业人员就可以更密切地监控和调优您的 MySQL 服务器。

摘要

在这一章中，我已经向你展示了如何通过添加你自己的新函数和命令来扩展 MySQL 服务器的功能。

您了解了如何构建一个可以在运行时加载和卸载的 UDF 库，如何向服务器源代码添加一个本机函数，以及如何向解析器和查询执行代码添加一个新的`SHOW`命令。您还学习了如何向信息模式添加视图。

以这种方式扩展服务器的能力使得 MySQL 非常灵活。UDF 机制是最容易编码的机制之一，它在复杂性和开发速度方面远远超过了竞争对手。该服务器是开源的，这意味着您也可以直接进入源代码，并为您的特定环境添加自己的 SQL 命令。不管您是否使用这些工具，您都应该知道您不会受到“开箱即用”功能和命令的限制。

下一章将探讨 MySQL 最受欢迎的特性之一——MySQL 复制。我将介绍复制的基础知识，并带您浏览复制源代码。接下来是复制的示例扩展，您可以使用这些扩展来了解复制的内部原理，并了解可以用来增强您自己的高可用性解决方案的扩展。

词汇分析器和 yacc 文件——不要和经常被称为 Lexx 的古怪科幻程序混淆。(注:加州大学 YACC 分校？)

[<sup>2</sup>](#_Fn2) Knuth，d . e .*计算机编程的艺术。第二版。*(艾迪森-韦斯利，1997)。

[<sup>3</sup>](#_Fn3) Linux/Unix 用户既可以使用他们的软件包管理器并安装它，也可以从 GNU 网站下载(`www.gnu.org/software/bison`)。Windows 用户可以从`http://gnuwin32.sourceforge.net/packages/bison.htm`下载 Win32 版本。

[<sup>4</sup>](#_Fn4) 例如，MySQL Utilities 实用程序 mysqldiskusage。MySQL 工具是 MySQL 工作台的一个子项目。你可以从 dev.mysql.com 的*下载 MySQL Workbench。*

[<sup>5</sup>](#_Fn5) 要了解更多关于 YACC 解析器以及如何编写 YACC 代码的信息，请参见`http://dinosaur.compilertools.net/`。

[<sup>6</sup>](#_Fn6) 关于信息模式的更多信息，请参见在线 MySQL 参考手册。

[<sup>7</sup>](#_Fn7) 记住，如果你不使用函数声明，你必须把函数的代码放在引用它的代码的前面。