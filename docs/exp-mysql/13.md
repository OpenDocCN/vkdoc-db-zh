# 十三、查询优化

第 12 章中显示的查询树类是为 DBXP 构建实验性查询优化和执行引擎的起点。在本章中，我将向您展示如何将优化器添加到查询树类中。我首先解释优化器中使用的试探法(或规则)的基本原理，然后开始编写代码。因为一些函数的代码很长，所以本章中的例子是摘录的。如果您正在编写示例代码，请下载本章的源代码，而不是从头开始输入代码。

查询优化器的类型

第一批查询优化器是为早期的数据库系统设计的，比如 System R [<sup>1</sup>](#Fn1) 和 INGRES 。 [<sup>2</sup>](#Fn2) 这些优化器是为关系模型的特定实现而开发的，它们经受住了时间的考验，是如何实现优化器的例证。许多商业上可用的数据库系统都是基于这些工作。从那时起，优化器已经被创建用于关系模型的扩展，以包括面向对象和分布式数据库系统。

一个例子是火山优化器 ，它使用动态编程算法 [<sup>3</sup>](#Fn3) 在面向对象的数据库系统中生成基于成本优化的查询计划。另一个例子是关于如何在异构数据库系统中执行优化(类似于分布式系统，但是没有公共共享的组织概念)。在这些环境中，可以使用统计方法来推导优化策略。

查询优化需求产生独特需求的另一个领域是内存数据库系统。这些系统被设计成包含整个系统和计算机辅助存储器(即磁盘)中的所有数据。虽然这些应用中的大多数是作为嵌入式系统实现的，但是一些由系统集合组成的大型分布式系统使用内存数据库来加速内存数据库系统中的信息检索优化，这需要高效的算法，因为与处理查询本身的需要相比，优化检索的需要是微不足道的。[<sup>4</sup>T4】](#Fn4)

所有对传统和非传统优化的研究都是基于系统优化器的领域。System R optimizer 是一个基于成本的优化器,它使用收集到的关于数据库和数据的信息，或者统计数据，来形成对查询如何执行的成本估计。此外，将查询的内部表示安排成不同但等价的内部表示(它们生成相同的答案)的概念提供了一种存储替代形式的机制。这些可选形式中的每一种都被称为一个*查询计划* 。成本最低的计划被选为执行查询的最有效方式。

系统 R 工作中确定的一个关键特性是选择性的概念——基于包含属性及其值的引用的表达式的评估来预测结果。选择性是决定合取选择中的简单表达式测试顺序的核心。最具选择性的表达式(即具有最小选择性的表达式)将检索最少数量的元组(行)。因此，该表达式应该是查询中第一个操作的基础。合取选择可以被认为是“交集”条件。相反，析取选择是“联合”条件。在析取条件中，顺序没有影响。

某些查询优化器，比如 System R，并不处理所有可能的连接顺序。相反，它们将搜索限制在某些类型的连接顺序上，已知这些连接顺序会产生更有效的执行。例如，可以对多路连接进行排序，以便首先执行生成最少可能结果的条件。类似地，System R 优化器只考虑那些连接顺序，其中每个连接的右操作数是初始关系之一。这种连接顺序称为左深连接顺序。左深连接顺序对于流水线执行特别方便，因为右操作数通常是一个关系(相对于中间关系)，因此每个连接只有一个输入被流水线化。管道的使用是数据库实验项目的优化器和执行引擎的一个关键元素。

基于成本的优化器

基于成本的优化器通过使用等价规则从给定的查询生成一系列查询评估计划,并根据收集的关于执行查询所需的关系和操作的度量(或统计)选择成本最低的计划。对于一个复杂的查询，许多等价的计划是可能的。

基于成本的优化的目标是利用从过去的查询中收集的索引和统计信息来安排查询执行和表访问。微软 SQL Server 和甲骨文等系统使用基于成本的优化器。

数据库系统中负责获取和处理统计数据(以及许多其他实用功能)的部分被称为*数据库目录* 。该目录维护关于引用关系和每个引用关系上可用的访问路径的统计信息。这些将在后面的访问路径选择中使用，以选择最有效的计划(成本最低)。例如，System R 为以下每个表维护统计信息:

*   每个关系的基数
*   段中包含每个关系的元组的页数
*   段中包含关系元组(阻塞因子或填充)的数据页的比例
*   对于每个索引:

*   每个索引中不同键的数量
*   每个索引中的页数

这些统计数据来自系统内的几个来源。加载关系和创建索引时会创建统计信息。然后由用户命令 [<sup>5</sup>](#Fn5) 定期更新，该命令可由任何用户运行。System R 不会实时更新这些统计数据，因为这会在系统编目中产生额外的数据库操作和锁定瓶颈。统计数据的动态更新倾向于对修改关系内容的访问进行串行化，从而限制了系统在多用户环境中处理同时查询的能力。

在基于成本的优化中使用统计数据并不复杂。大多数受访的数据库专业人员似乎认为统计数据的收集和应用是查询优化的一个复杂而重要的元素。尽管基于成本的查询优化甚至混合优化方案使用成本和/或排名的统计，但优化方案既不复杂也不关键。例如，在属性中均匀分布值的概念。这个概念本身就证明了统计学应用的不精确性。统计计算在本质上很大程度上是分类的，它们不是为了生成精确的值而设计的。它们只是帮助确定一个查询执行计划是否通常比另一个更昂贵。

属性值的频率分布是预测查询结果大小的常用方法。通过形成属性的可能(或实际 [<sup>6</sup>](#Fn6) )值的分布，数据库系统可以使用该分布，通过预测计划必须处理的元组(或行)的数量来计算给定查询计划的成本。然而，现代数据库系统只处理单个属性的频率分布，因为考虑所有可能的属性组合是非常昂贵的。这实质上对应于所谓的属性值独立性假设，尽管这很少是真的，但几乎所有的关系数据库系统都采用这种假设。

收集分布数据需要不断更新统计数据或对数据进行预测分析。另一个策略是使用均匀分布,其中属性值的分布被假设为对于所有不同的值都是相等的。例如，给定 5000 个元组和给定属性的 50 个可能值，均匀分布假设每个值表示 100 次。这种情况很少发生，而且通常是不正确的。尽管没有任何统计数据，但在许多情况下，这仍然是现实的合理近似值。

在最坏的情况下，动态编程的内存需求和运行时间随着查询大小(即连接的数量)呈索引增长，因为在每个步骤中生成的所有可行的部分计划都必须存储起来，以便在下一个步骤中使用。事实上，许多现代系统对可以提交的查询的大小有限制(通常在 15 个连接左右)，因为对于较大的查询，优化器会由于非常高的内存需求而崩溃。然而，实践中看到的大多数查询包含的连接少于 10 个，并且该算法已被证明在这种情况下是有效的。它被认为是查询优化搜索策略的标准。收集的关于表(或关系)中的行(或元组)的统计数据包括:

*   表中元组的数量
*   包含行的块数(块数)
*   以字节为单位的行的大小
*   每个属性(或列)的不同值的数量
*   每个属性的选择基数(有时表示为均匀分布)
*   索引内部节点的扇出(产生子树的子节点数)
*   索引的 B 树的高度
*   索引叶级别的块数

将操作的最终结果写回磁盘的开销被忽略。不管使用什么样的查询评估计划，这个成本都不会改变；因此，不将其包括在计算中并不影响计划的选择。

今天大多数数据库系统使用一种形式的动态编程来生成所有可能的查询计划。虽然动态编程为成本优化提供了良好的性能，但它是一种复杂的算法，对于更复杂的查询可能需要更多的资源。虽然大多数数据库系统不会遇到这些类型的查询，但分布式数据库系统和高性能计算领域的研究人员已经探索了动态编程技术的替代方案和变体。Kossmann 和 Stocker 最近的研究表明，我们开始看到传统查询优化方法的局限性。 [<sup>7</sup>](#Fn7) 我们需要的是更高效的优化技术，这些技术能够生成遵循良好实践的执行计划，而不是穷尽式的探索。换句话说，我们需要在各种通用环境中表现良好的优化器，也需要在独特的数据库环境中表现良好的优化器。

启发式优化器

启发式优化的目标是应用确保查询执行良好实践的规则。使用启发式优化器的系统包括 INGRES 和各种学术变体。大多数系统通常使用启发式优化作为避免真正糟糕的计划的手段，而不是作为优化的主要手段。

启发式优化器在选择替代实现之前，使用关于如何将查询塑造成最佳形式的规则。试探法或规则的应用可以消除可能低效的查询。使用试探法作为形成查询计划的基础确保了查询计划在评估之前最有可能(但不总是)得到优化。这种试探法包括:

*   尽可能早地执行选择操作。通常最好在投影之前执行选择，因为这样可以减少沿树向上发送的元组数量。
*   尽早进行预测。
*   确定哪些选择操作和连接操作产生最小的结果集，并首先使用这些操作(最左边的深度)。
*   用连接操作替换笛卡尔积。
*   在树中尽可能向下移动投影属性。
*   识别其操作可以被流水线化的子树。

启发式优化器不是新技术。研究人员已经为各种专门目的创建了基于规则的优化器。一个例子是基于 Prairie 规则的查询优化器。这个基于规则的优化器允许根据给定的语言符号创建规则。使用控制优化器执行方式的规则来处理查询。在这种情况下，Prairie 优化器主要是一个基于成本的优化器，它使用规则来调整优化器。

除了 Prairie 和 INGRES 等早期原语之外，没有任何商业数据库系统实现纯粹的启发式优化器。对于那些具有启发式或基于规则的优化步骤的优化，它通常作为经典的基于成本的优化器的附加或预处理器来实现，或者作为优化中的预处理步骤来实现。

语义优化器

语义优化的目标是形成查询执行计划，该计划使用数据库的语义或拓扑以及其中的关系和索引来形成查询，以确保在给定数据库中执行查询的最佳实践。语义查询优化使用模式的知识(例如，完整性约束)来将查询转换成可以比原始版本更有效地回答的形式。

虽然还没有在商业数据库系统中作为主要的优化技术来实现，但是语义优化目前是大量研究的焦点。语义优化的前提是优化器对实际的数据库模式有基本的了解。当提交一个查询时，优化器使用它对系统约束的了解来简化或忽略一个特定的查询，如果它保证返回一个空的结果集的话。这项技术很有希望在未来的关系数据库系统中进一步提高查询处理效率。

参数优化器

Ioannidis 在他关于参数化查询优化的工作中描述了一种查询优化方法，该方法将启发式方法的应用与基于成本的优化相结合。生成的查询优化器提供了一种方法来生成一个较小的有效查询计划集，根据该计划可以估计成本，从而可以执行该计划集中成本最低的计划。 [<sup>8</sup>](#Fn8) 查询计划生成是使用一种随机算法创建的，称为 sipR。这允许利用参数查询优化的系统选择可以包括参数变化的不确定性(例如缓冲区大小)的查询计划，以选择在运行中或从存储中形成的最佳计划。

有趣的是，在他的工作中，Ioannidis 认为可能不需要使用动态编程算法，因此可以避免使用这些技术的开销。此外，他发现，在应用动态编程算法进行查询优化之前，使用试探法来修剪或调整查询的数据库系统通常是 System R 的原始算法的增强版本。Ioannidis 表明，对于小型查询(大约多达 10 个连接)，动态编程优于随机化算法，而对于大型查询，情况正好相反。

启发式优化再探

启发式优化过程 使用一组已定义的规则来保证良好的执行计划。因此，启发式优化器产生良好计划的有效性仅仅基于其规则的有效性和完整性。

以下段落描述了用于创建 DBXP 查询优化器的规则。尽管这些规则非常基本，但是当它们应用于典型的查询时，最终的执行是接近最优的，具有快速的性能和准确的结果。

最初使用一些基本策略来构建查询树。具体来说，所有的执行都发生在查询树节点中。限制和投影是在分支上处理的，不会生成中间关系。连接总是作为两条路径的交集来处理。多路连接将使用一系列双向连接来形成。以下规则代表了形成一组启发式规则以生成良好的执行计划的最佳实践。DBXP 优化器被设计来应用这些规则，以便将查询树转换成确保高效执行的形式。 [<sup>9</sup>](#Fn9)

1.  拆分包含项目的任何节点并连接或限制并连接。这一步是必要的，因为一些查询在`WHERE`子句 [<sup>10</sup>](#Fn10) 中指定了连接条件，从而可以“欺骗”优化器形成连接节点，这些节点的表达式部分不属于连接条件。
2.  把所有的限制都推到树叶上。表达式根据它们各自的关系被分组到单独的查询树节点中。虽然有些复杂的表达式不能简化，但大多数可以很容易地简化为一个单一的关系式。通过在叶子上设置限制，减少了必须沿树向上传递的结果元组的数量。
3.  将所有投影放置在树的最低点。投影应该放在高于限制的节点中，并且它们将通过从结果元组中消除不需要的属性来进一步减少通过树传递的数据量。应当注意，可以修改投影以包括操作所需的属性，例如驻留在投影查询树节点的父代中的连接。
4.  将所有连接放在 join 子句中包含的关系的投影或限制的交叉点上。 [<sup>11</sup>](#Fn11) 这确保了对最昂贵的操作——连接——评估最少量的元组。对来自子节点的结果元组进行排序的中间查询树节点可能是必要的。这些中间节点称为实用操作，可以根据连接的类型对元组进行排序或分组，它们可以大大提高连接的性能。

![image](img/sq.jpg) **注意**可以使用其他启发式方法。前面的列表包含那些产生最大性能增益的。

Lee、Shih 和 Chen 对将选择和限制推下树的做法给出了一个有趣的反驳。 [<sup>12</sup>](#Fn12) 他们提出，在某些条件下，有些选择和投射可能比联结的代价更大。他们的论点提出了一种基于图论的查询优化器，可以更准确地预测复杂选择和投影情况下的查询优化。然而，一般情况下，可以使用我列出的规则为大多数查询构建“高效”的执行计划。

DBXP 查询优化器

尽管这些规则为形成最佳查询树提供了一整套操作，但它们并没有解决平衡多路连接或应用索引的问题。这些步骤被认为是基于成本的优化。由于这个原因，大多数启发式优化器被实现为两阶段优化，第一阶段生成优化的查询路径，第二阶段应用成本优化策略。

![image](img/sq.jpg) **注意** DBXP 优化器是作为两遍操作实现的。第一个操作使用启发式算法重新排列树以供执行。第二遍遍历树，改变与被操作的属性上可用的索引有关系的节点的访问方法。我将成本优化过程的实现留给读者作为练习。

为启发式优化器创建全面的测试需要编写涵盖优化器中所有可能路径的 SQL 语句。本质上，您需要创建一个测试来测试所有可能的查询，包括有效的和无效的(无效的查询通常在 SQL 解析器代码中被捕获)。然而，实现启发式优化器只是 DBXP 引擎的第二部分。在前一章中，我们创建了基本的查询树内部表示，并删除了执行方法。在本章中，我们将创建优化器，但不能执行查询。您可以继续使用存根执行来测试优化器，但是您可以重用前一章中的代码来显示查询计划而不是查询结果，而不是显示查询结果。

记住这一点，让我们设计几个基本的查询来测试优化器，以显示它正在处理这些查询。我们将在下一章关注查询的执行。清单 13-1 展示了一个测试查询优化器的示例。

[***清单 13-1。***](#_list1) 示例 DBXP 查询优化器测试(Ch13.test)

```sql
#
# Sample test to test the DBXP_SELECT optimizer
#

# Test 1:
DBXP_SELECT * FROM staff;

# Test 2:
DBXP_SELECT id FROM staff WHERE staff.id = '123456789';

# Test 3:
DBXP_SELECT id, dir_name FROM staff, directorate
WHERE staff.dno = directorate.dnumber;

# Test 4:
DBXP_SELECT * FROM staff JOIN tasking ON staff.id = tasking.id
WHERE staff.id = '123456789';
```

![image](img/sq.jpg) **提示**这些例子中使用的数据库包含在附录中。

您可以使用这个测试作为指南，并添加您自己的命令来探索新代码。有关如何使用 MySQL 测试套件创建和运行该测试的更多详细信息，请参考[第 4 章](04.html)。

清除 DBXP_SELECT 命令

由于没有查询执行功能，查询命令可以优化，但不能执行。show plan 机制(`EXPLAIN`命令)可以作为演示优化器的一种手段。要添加这个功能，您可以打开`sql_dbxp_parse.cc`文件并改变`DBXP_select_command()`方法，如[清单 13-2](#list2) 所示。

[***清单 13-2。***](#_list2) 对查询优化器进行测试

```sql
int DBXP_explain_select_command(THD *thd);

/*
  Perform DBXP_SELECT Command

  SYNOPSIS
    DBXP_select_command()
    THD *thd            IN the current thread

  DESCRIPTION
    This method executes the SELECT command using the query tree and optimizer.

  RETURN VALUE
    Success = 0
    Failed = 1
*/
int DBXP_select_command(THD *thd)
{
  DBUG_ENTER("DBXP_select_command");
  DBXP_explain_select_command(thd);
  DBUG_RETURN(0);
}
```

这些变化改变了调用`EXPLAIN`命令代码的代码，而不是执行查询。这允许测试返回有效的结果集(查询计划)，这样我们就可以在没有查询执行部分的情况下测试优化器。

![image](img/sq.jpg) **注意**我在`DBXP_select_command()`方法上面用了一个函数声明。这允许代码在不使用头文件的情况下向前调用`DBXP_explain_select_command()`方法。

还有一个对`DBXP_explain_select_command()`方法的必要改变。您需要添加对新优化方法的调用。这包括`heuristic_optimization()` 和`cost_optimization()`方法。我将在接下来的小节中更详细地讨论启发式优化。[清单 13-3](#list3) 显示了对`EXPLAIN`代码的修改。

[***清单 13-3。***](#_list3) 修改解释命令代码

```sql
/*
  Perform EXPLAIN command.

  SYNOPSIS
    DBXP_explain_select_command()
    THD *thd            IN the current thread

  DESCRIPTION
    This method executes the EXPLAIN SELECT command.

  RETURN VALUE
    Success = 0
    Failed = 1
*/
int DBXP_explain_select_command(THD *thd)
{
  bool res= 0;

  DBUG_ENTER("DBXP_explain_select_command");

  /* Prepare the tables (check access, locks) */
  res = check_table_access(thd, SELECT_ACL, thd->lex->query_tables, 0, 1, 1);
  if (res)
    DBUG_RETURN(1);
  res = open_and_lock_tables(thd, thd->lex->query_tables, 0,
                             MYSQL_LOCK_IGNORE_TIMEOUT);
  if (res)
    DBUG_RETURN(1);

  /* Create the query tree and optimize it */
  Query_tree *qt = build_query_tree(thd, thd->lex,
           (TABLE_LIST*) thd->lex->select_lex.table_list.first);
  qt->heuristic_optimization();
  qt->cost_optimization();

  /* create a field list for returning the query plan */
  List<Item> field_list;

  /* use the protocol class to communicate to client */
  Protocol *protocol= thd->protocol;

  /* write the field to the client */
  field_list.push_back(new Item_empty_string("Execution Path",NAME_LEN));
  if (protocol->send_result_set_metadata(&field_list,
                            Protocol::SEND_NUM_ROWS | Protocol::SEND_EOF))
    DBUG_RETURN(TRUE);
  protocol->prepare_for_resend();

  /* generate the query plan and send it to client */
  show_plan(protocol, qt->root, qt->root, false);
  my_eof(thd); /* end of file tells client no more data is coming */

  /* unlock tables and cleanup memory */
  mysql_unlock_read_tables(thd, thd->lock);
  delete qt;
  DBUG_RETURN(0);
}
```

重要的 MySQL 结构和类

MySQL 源代码中有许多关键的结构和类。到目前为止，您已经在示例中看到了许多。一些更重要的问题记录在 MySQL 内部手册中。不幸的是，没有任何文件将它们全部列出。下面几节描述了在使用 DBXP 查询优化器(以及后面的查询执行代码)时会遇到的一些结构和类。这些包括`TABLE`结构、`Field`类和一些常见的`Item`迭代器(在[第 3 章](03.html)中讨论了`Item`类)。

表格结构

在编写优化器时，最重要的 MySQL 结构是`TABLE`结构。

这个结构很重要，因为它包含了一个表的所有相关数据。它包含所有内容，从指向适当存储处理程序类的指针，到执行查询时用于存储行的字段、键和临时缓冲区的列表。

虽然这个结构非常庞大(就像 MySQL 中最重要的结构一样)，但是你会反复看到一些关键的属性。[表 13-1](#Tab1) 列出了`TABLE`结构的一些更重要的属性。关于`TABLE`结构的详细检查，参见`handler.h`文件。

[表 13-1](#_Tab1) 。表结构概述

| 属性 | 描述 |
| --- | --- |
| 文件 | 对存储引擎对象的引用。 |
| 领域 | 表的字段数组。 |
| 田地（复数）；场；域；字段 | 字段数组中的字段数。 |
| 然后 | 指向表列表中下一个表的指针。 |
| 上一个 | 指向表列表中上一个表的指针。 |

字段类

`Field`类包含创建、赋值和操作数据库中表的字段(或属性)的所有属性和方法。`Field`类在`/sql/field.h`文件中定义，在`/sql/field.cc`文件中实现。`Field`类实际上是一个基类，几种类型的字段都是从这个基类派生出来的。这些名为`Field_XXX,`的派生类可以在 MySQL 源代码的几个地方找到。

由于它只是一个基类， [<sup>13</sup>](#Fn13) 类中的许多方法都打算被派生类覆盖(它们被定义为`virtual`)。然而，许多派生类具有相同的基本属性和方法。表 13-2 列出了你在使用 DBXP 源代码时会遇到的属性和方法。对于`Field`类的详细检查，参见`field.h`文件。

[表 13-2](#_Tab2) 。字段类

| 属性/方法 | 描述 |
| --- | --- |
| 光电带读数机(photoelectric tape reader) | 指向记录缓冲区中字段的指针。 |
| 空值 ptr | 指向记录缓冲区中一个(或多个)字节的指针，指示哪些属性可以包含 NULL。 |
| 表名 | 与该字段关联的表名。 |
| 字段名称 | 该字段的属性名。 |
| 字段长度 | 字段的长度。指示可以存储的字节数。 |
| is_null() | 检查字段是否为空。 |
| move_field() | 将内存中字段的指针更改为指向不同的位置。 |
| 商店() | 用于将值存储到字段中的一系列重载方法。 |
| val_str() | 以字符串形式获取字段的值。 |
| val_int（） | 以整数形式获取字段的值。 |
| 结果类型() | 获取字段的数据类型。 |
| 化学机械抛光() | 返回字段与传递的值的比较结果。 |

迭代器

MySQL 源代码中有三种类型的迭代器。在前面的章节中，你已经看到了这些迭代器。迭代器是一种特殊的结构，它使得创建和浏览对象列表变得很容易，它们通常以链表或数组的形式出现。MySQL 中的迭代器是作为模板类实现的，它将列表操作的数据类型作为参数。MySQL 迭代器是链表，但有些更像队列和堆栈。以下部分描述了 MySQL 中一些可用的迭代器类。这些迭代器在`sql/sql_list.h`头文件中定义。

模板<>班级列表

`List`模板类被实现为一个队列或堆栈，使用`push_back()`方法将项目推到列表的后面，或者使用`push_front()`方法将项目推到列表的前面。可以使用`pop()`方法检索项目，或者使用`remove()`方法删除项目。您可以通过使用数据项的`next`属性来循环遍历列表，但是列表通常用于形成项目的链表(例如`List<Item> item_list`)，然后使用`List_iterator`类中的一个来快速循环遍历列表。这个类从`base_list`类派生而来(也在`/sql/sql_list.h`中定义)。

模板<>类列表 _ 迭代器

`List_iterator`类被实现为一个链表，该链表具有使用重载的`++`操作符在列表中移动的方法。可以使用`ref()`方法检索项目，或者使用`remove()`方法删除项目。可以通过发出`rewind()`方法从前面重新开始列表。该类从`base_list`类派生而来(也在`/sql/sql_list.h`中定义)。

模板<>类列表 _ 迭代器 _ 快速

`List_iterator_fast`类本质上与`List_iterator`类相同，但它是为快速向前遍历而优化的。它被实现为一个链表，并带有使用重载的`++`操作符在列表中移动的方法。可以使用`ref()`方法检索项目，或者使用`remove()`方法删除项目。该类从`base_list`类派生而来(也在`/sql/sql_list.h`中定义)。

例子

使用迭代器很容易。如果你想使用一个列表来操作条目，一个简单的列表，比如`List<Item_field>,` 将是最好的选择。如果想快速遍历字段列表，可以创建一个列表迭代器作为`List_iterator<Item_field>`或`List_iterator_fast<Item_field>`。循环结构的例子如[清单 13-4](#list4) 所示。

[***清单 13-4。***](#_list4) 示例迭代器

```sql
  /* create a list and populate with some items */
  List<Item> item_list;
  item_list.push_back(new Item_int((int32)
             join->select_lex->select_number));
  item_list.push_back(new Item_string(join->select_lex->type,
    strlen(join->select_lex->type), cs));
  item_list.push_back(new Item_string(message,strlen(message),cs));

../* start a basic list iterator to iterate through the item_list */
  List_iterator<Item_field> item_list_it(*item_list);

  /* control the iteration using an offset */
  while ((curr_item= item_list_it++))
  {
    /* do something */
  }

../* start a fast list iterator to iterate through the item_list */
  List_iterator_fast<Item_field> li(item_equal->fields);

  /* control the iteration using an offset */
  while ((item= li++))
  {
    /* do something */
  }
```

DBXP 助手类

我在[第 11 章](11.html)中提到了 DBXP 引擎中使用的两个额外的类(属性和表达式)。这些类旨在使优化器更容易编码和理解。它们是现有 MySQL 类(和结构)的封装，并且重用了 MySQL 代码中的许多可用方法。

第一个助手类是封装查询中使用的属性的类。这些属性在 MySQL 代码中表示为`Item`类。名为`Attribute`的助手类通过提供访问项目的公共接口，使得访问这些类变得更加容易。清单 13-5 显示了`Attribute`类的头文件。

[***清单 13-5。***](#_list5) 属性类表头

```sql
#include "sql_priv.h"
#include "sql_class.h"
#include "table.h"

class Attribute
{
public:
  Attribute(void);
  int remove_attribute(int num);
  Item *get_attribute(int num);
  int add_attribute(bool append, Item *new_item);
  int num_attributes();
  int index_of(char *table, char *value);
  int hide_attribute(Item *item, bool hide);
  char *to_string();
private:
  List<Item> attr_list;
  bool hidden[256];
};
```

第二个助手类封装了查询中使用的表达式。像属性一样，表达式在 MySQL 代码中表示为`Item`类实例。名为`Expression`的助手类为`Item`类提供了一个公共(且简化的)接口。[清单 13-6](#list6) 显示了`Expression`类的头文件。

[***清单 13-6。***](#_list6) 表达式类表头

```sql
#include "sql_priv.h"
#include "sql_class.h"
#include "table.h"
#include <sql_string.h>

struct expr_node
{
  Item      *left_op;
  Item      *operation;
  Item      *right_op;
  Item      *junction;
  expr_node *next;
};

class Expression
{
public:
  Expression(void);
  int remove_expression(int num, bool free);
  expr_node *get_expression(int num);
  int add_expression(bool append, expr_node *new_item);
  int num_expressions();
  int index_of(char *table, char *value);
  int reduce_expressions(TABLE *table);
  bool has_table(char *table);
  int convert(THD *thd, Item *mysql_expr);
  char *to_string();
  bool evaluate(TABLE *table 1);
  int compare_join(expr_node *expr, TABLE *t1, TABLE *t2);
  int get_join_expr(Expression *where_expr);
private:
  expr_node *root;
  Field *find_field(TABLE *tbl, char *name);
  bool compare(expr_node *expr, TABLE *t1);
  int num_expr;
};
```

我使用一个结构来包含左操作数、运算符和右操作数形式的表达式。这是一种比 MySQL 类表示的表达式树更简化的方法，使得阅读优化器代码更容易。更简单的方法也使得在交互式调试器中评估条件更容易。

![image](img/sq.jpg) **注意**我在正文中省略了这些助手类的一些细节，因为它们是调用用于`TABLE`结构的 MySQL 方法以及`Item`和`Field`类的非常简单的抽象。然而，这些文件包含在在线章节源代码中。这本书的源代码可以在 http://www.apress.com[的源代码部分下载。](http://www.apress.com)

这些助手类和头文件应该放在`/sql`目录中，并添加到 CMakeLists.txt 文件中。我将在“编译和测试代码”一节中向您展示如何做到这一点。

对现有代码的修改

实现优化器还需要一个小的修改:我们需要添加代码来使用新的`Attribute`和`Expression`类。打开`query_tree.h`头文件，进行清单 13-7 所示的修改。正如你所看到的，我已经改变了`where_expr`和`join_expr`属性来使用新的`Expression`类。同样，我更改了`attributes`属性以使用新的`Attribute`类。

[***清单 13-7。***](#_list7) 对查询树类的修改

```sql
#include "attribute.h"
#include "expression.h"
#include "sql_priv.h"
#include "sql_class.h"
#include "table.h"
#include "records.h"

const int MAXNODETABLES = 4;
const int LEFTCHILD = 0;
const int RIGHTCHILD = 1;

class Query_tree
{
public:
  enum query_node_type          //this enumeration lists the available
  {                              //query node (operations)
    qntUndefined = 0,
    qntRestrict = 1,
    qntProject = 2,
    qntJoin = 3,
    qntSort = 4,
    qntDistinct = 5
  };

  enum join_con_type            //this enumeration lists the available
  {                              //join operations supported
    jcUN = 0,
    jcNA = 1,
    jcON = 2,
    jcUS = 3
  };

  enum type_join                //this enumeration lists the available
  {                              //join types supported.
    jnUNKNOWN      = 0,          //undefined
    jnINNER        = 1,
    jnLEFTOUTER    = 2,
    jnRIGHTOUTER   = 3,
    jnFULLOUTER    = 4,
    jnCROSSPRODUCT = 5,
    jnUNION        = 6,
    jnINTERSECT    = 7
  };

    enum AggregateType          //used to add aggregate functions
    {
        atNONE      = 0,
        atCOUNT     = 1
    };

  /*
    STRUCTURE query_node

    DESCRIPTION
      This this structure contains all of the data for a query node:

      NodeId -- the internal id number for a node
      ParentNodeId -- the internal id for the parent node (used for insert)
      SubQuery -- is this the start of a subquery?
      Child -- is this a Left or Right child of the parent?
      NodeType -- synonymous with operation type
      JoinType -- if a join, this is the join operation
      join_con_type -- if this is a join, this is the "on" condition
      Expressions -- the expressions from the "where" clause for this node
      Join Expressions -- the join expressions from the "join" clause(s)
      Relations[] -- the relations for this operation (at most 2)
      PreemptPipeline -- does the pipeline need to be halted for a sort?
      Fields -- the attributes for the result set of this operation
      Left -- a pointer to the left child node
      Right -- a pointer to the right child node
*/
  struct query_node
  {
    query_node();
    ∼query_node();
    int                 nodeid;
    int                 parent_nodeid;
    bool                sub_query;
    int                 child;
    query_node_type     node_type;
    type_join           join_type;
    join_con_type       join_cond;
    Expression          *where_expr;
    Expression          *join_expr;
    TABLE_LIST          *relations[MAXNODETABLES];
    int                 eof[MAXNODETABLES];
    int                 ndx[MAXNODETABLES];
    bool                preempt_pipeline;
    Attribute           *attributes;
    query_node          *left;
    query_node          *right;
  };

  struct record_buff
  {
    uchar *field_ptr;
    long field_length;
    record_buff *next;
    record_buff *prev;
    READ_RECORD *record;
  };
```

许多方法也需要添加到查询树类中。我没有描述每个方法及其实现的细节，而是在清单 13-8 中包含了查询树定义的其余部分。这段代码也被添加到`query_tree.h`文件中。

[***清单 13-8。***](#_list8) 查询-树类的新方法

```sql
  query_node *root;              //The ROOT node of the tree

  Query_tree(void);
  ∼Query_tree(void);
  int init_node(query_node *qn);
  int heuristic_optimization();
  int cost_optimization();
  int insert_attribute(query_node *qn, Item *c);
  bool distinct;
  int prepare(query_node *qn);
  int cleanup(query_node *qn);
  bool Eof(query_node *qn);
  READ_RECORD *get_next(query_node *qn);
  List <Item> result_fields;

private:
  bool h_opt;              //has query been optimized (rules)?
  bool c_opt;              //has query been optimized (cost)?
  READ_RECORD *lbuff;
  READ_RECORD *rbuff;
  record_buff *left_record_buff;
  record_buff *right_record_buff;
  record_buff *left_record_buffer_ptr;
  record_buff *right_record_buffer_ptr;

  int push_projections(query_node *qn, query_node *pNode);
  query_node *find_projection(query_node *qn);
  bool is_leaf(query_node *qn);
  bool has_relation(query_node *qn, char *Table);
  bool has_attribute(query_node *qn, Item *a);
  int del_attribute(query_node *qn, Item *a);
  int push_restrictions(query_node *qn, query_node *pNode);
  query_node *find_restriction(query_node *qn);
  query_node *find_join(query_node *qn);
  int push_joins(query_node *qn, query_node *pNode);
  int prune_tree(query_node *prev, query_node *cur_node);
  int balance_joins(query_node *qn);
  int split_restrict_with_project(query_node *qn);
  int split_restrict_with_join(query_node *qn);
  int split_project_with_join(query_node *qn);
  bool find_table_in_tree(query_node *qn, char *tbl);
  bool find_table_in_expr(Expression *expr, char *tbl);
  bool find_attr_in_expr(Expression *expr, char *tbl, char *value);
  int apply_indexes(query_node *qn);
  bool do_restrict(query_node *qn, READ_RECORD *t);
  READ_RECORD *do_project(query_node *qn, READ_RECORD *t);
  READ_RECORD *do_join(query_node *qn);
  int find_index_in_expr(Expression *e, char *tbl);
  TABLE *get_table(query_node *qn);
  int insertion_sort(bool left, Field *field, READ_RECORD *rcd);
  int check_rollback(record_buff *cur_left, record_buff *curr_left_prev,
    record_buff *cur_right, record_buff *cur_right_prev);
};
```

注意有几个公共方法，包括`heuristic_optimization()` 和`cost_optimization()`。我还添加了一个公共属性`distinct,`，你可以用它来帮助实现不同的操作(参见本章末尾的练习)。其余的方法是优化代码的助手方法。我解释了一些更有趣的，并把平凡的留给你去探索。

现在我们有了一些助手类来使优化器更容易实现，我们需要将它们合并到将 MySQL 内部查询表示转换为 DBXP 查询树的转换代码中。打开`sql_dbxp_parse.cc`文件，定位`build_query_tree()`方法 。清单 13-9 显示了添加新的`Attribute`和`Expression`类所必需的改变。

[***清单 13-9。***](#_list9) 对构建-查询-树方法的修改

```sql

/*
  Build Query Tree

  SYNOPSIS
    build_query_tree()
    THD *thd            IN the current thread
    LEX *lex            IN the pointer to the current parsed structure
    TABLE_LIST *tables  IN the list of tables identified in the query

  DESCRIPTION
    This method returns a converted MySQL internal representation (IR) of a
    query as a query_tree.

  RETURN VALUE
    Success = Query_tree * -- the root of the new query tree.
    Failed = NULL
*/
Query_tree *build_query_tree(THD *thd, LEX *lex, TABLE_LIST *tables)
{
  DBUG_ENTER("build_query_tree");
  Query_tree *qt = new Query_tree();
  Query_tree::query_node *qn =
    (Query_tree::query_node *)my_malloc(sizeof(Query_tree::query_node),
    MYF(MY_ZEROFILL | MY_WME));
  TABLE_LIST *table;
  int i = 0;
  Item *w;
  int num_tables = 0;

  /* create a new restrict node */
  qn->parent_nodeid = −1;
  qn->child = false;
  qn->join_type = (Query_tree::type_join) 0;
  qn->nodeid = 0;
  qn->node_type = (Query_tree::query_node_type) 2;
  qn->left = NULL;
  qn->right = NULL;
  qn->attributes = new Attribute();
  qn->where_expr = new Expression();
  qn->join_expr = new Expression();

  /* Get the tables (relations) */
  i = 0;
  for(table = tables; table; table = table->next_local)
  {
    num_tables++;
    qn->relations[i] = table;
    i++;
  }

  /* prepare the fields (find associated tables) for query */
  List <Item> all_fields;
  Name_resolution_context context;
  List_iterator <Item> it(thd->lex->select_lex.item_list);
  it++;
  if (lex->select_lex.with_wild)
  {
    bool found = FALSE;
    Field_iterator_table_ref field_iterator;
    for(table = tables; table; table = table->next_local)
    {
      field_iterator.set(table);
      for (; !field_iterator.end_of_fields(); field_iterator.next())
      {
        Item *item= field_iterator.create_item(thd);
        if (!found)
        {
          found= TRUE;
          it.replace(item); /* Replace '*' with the first found item. */
        }
        else
        {
          it.after(item);   /* Add 'item' to the SELECT list. */
        }
      }
    }
  }
if (setup_fields(thd, lex->select_lex.ref_pointer_array,
                   lex->select_lex.item_list, thd->mark_used_columns,
                   &all_fields, 1))
    DBUG_RETURN(NULL);
  qt->result_fields = lex->select_lex.item_list;

  /* get the attributes from the raw query */
  w = lex->select_lex.item_list.pop();
  while (w != 0)
  {
    uint unused_field_idx= NO_CACHED_FIELD_INDEX;
    TABLE_LIST *dummy;
    Field *f = NULL;
    for(table = tables; table; table = table->next_local)
    {
      f = find_field_in_table_ref(thd, table, ((Field *)w)->field_name,
                                  strlen(((Field *)w)->field_name),
                                  ((Field *)w)->field_name, NULL, NULL, NULL,
                                  FALSE, FALSE, &unused_field_idx, FALSE,
                                  &dummy);
      if (f)
      {
        qn->attributes->add_attribute(true, (Item *)f);
        break;
      }
    }
    w = lex->select_lex.item_list.pop();
  }

  /* get the joins from the raw query */
  if (num_tables > 0)  //indicates more than 1 table processed
    for(table = tables; table; table = table->next_local)
    {
      if (table->join_cond() != 0)
        qn->join_expr->convert(thd, (Item *)table->join_cond());
    }

  /* get the expressions for the where clause */
  qn->where_expr->convert(thd, lex->select_lex.where);

  /* get the join conditions for the joins */
  qn->join_expr->get_join_expr(qn->where_expr);

  /* if there is a where clause, set node to restrict */
  if (qn->where_expr->num_expressions() > 0)
    qn->node_type = (Query_tree::query_node_type) 1;

  qt->root = qn;
  DBUG_RETURN(qt);
}
```

此时，需要调整包含文件，以确保我们包含了编译代码所需的所有内容。例如，以下语句出现在`query_tree.cc`文件的顶部:

```sql
#include "query_tree.h"
```

query_tree.h 头文件包括属性和表达式头文件，以及所需的 MySQL includes 文件，如下所示。

```sql
#include "query_tree.h"
#include "sql_base.h"
#include "sql_acl.h"
#include "sql_parse.h"
#include "lock.h"
```

![image](img/sq.jpg) **注意**如果在编译时遇到奇怪的错误，请检查您的 CMakeLists.txt 文件中没有包含`attribute`、`expression`和`query_tree`头文件。编译器将按照 include 指令自动包含这些文件。

启发式优化器的详细信息

启发式优化器是使用前面描述的规则模型实现的。启发式优化器中使用的每个方法都实现一些或所有规则。这些方法在[表 13-3](#Tab3) 中列出。

[表 13-3](#_Tab3) 。启发式优化器中的启发式方法

| 方法 | 描述 |
| --- | --- |
| split_restrict_with_join() | 在树中搜索具有限制(有表达式)和连接表达式的节点。它将节点分为两个节点:一个用于限制，另一个用于连接。 |
| split_project_with_join() | 在树中搜索具有投影(具有属性)和连接表达式的节点。它将节点分为两个节点:一个用于投影，一个用于连接。 |
| split _ restrict _ with _ project() | 在树中搜索具有限制(有表达式)和投影(有属性)的节点。它将节点分为两个节点:一个用于限制，另一个用于投影。 |
| find_restriction() | 在树中搜索不在叶节点上的限制节点。 |
| push_restrictions() | 将限制沿树向下推至尽可能低的节点。它寻找限制可以驻留在叶子上的情况。这个方法在一个循环中与 find_restrictions()一起使用(当没有找到更多已经不在叶子上的限制时，循环结束)。 |
| find_projection() | 在树中搜索不在叶子上的投影节点。 |
| push_projections() | 将投影沿树向下推至可能的最低节点。它寻找投影可以驻留在叶子上或作为限制的父对象的情况。此方法在循环中与 find_projections()一起使用(当没有发现更多已经不在叶或作为限制的叶的父级的投影时，循环结束)。 |
| find_join() | 在树中搜索联接节点。 |
| push_joins() | 将联接沿树向下推至节点，作为合格限制和/或投影(在联接中的表上操作的那些)的父级。 |
| prune_tree() | 识别树中已经优化掉并且不再有效的节点(没有属性或表达式，也没有连接或排序)，并删除它们。 |

启发式优化器的实现读起来非常容易。清单 13-10 展示了`heuristic_optimization()`方法的源代码实现。

[***清单 13-10。***](#_list10)DBXP 启发式优化方法 [<sup>14</sup>](#Fn14)

```sql
/*
  Perform heuristic optimization

  SYNOPSIS
    heuristic_optimization()

  DESCRIPTION
    This method performs heuristic optimization on the query tree. The
    operation is destructive in that it rearranges the original tree.

  RETURN VALUE
    Success = 0
    Failed = 1
*/
int Query_tree::heuristic_optimization()
{
  DBUG_ENTER("heuristic_optimization");
  query_node       *pNode;
  query_node       *nNode;

  h_opt = true;
  /*
    First, we have to correct the situation where restrict and
    project are grouped together in the same node.
  */
  split_restrict_with_join(root);
  split_project_with_join(root);
  split_restrict_with_project(root);

  /*
    Find a node with restrictions and push down the tree using
    a recursive call. continue until you get the same node twice.
    This means that the node cannot be pushed down any further.
  */
  pNode = find_restriction(root);
  while(pNode != 0)
  {
    push_restrictions(root, pNode);
    nNode = find_restriction(root);
    /*
      If a node is found, save a reference to it unless it is
      either the same node as the last node found or
      it is a leaf node. This is done so that we can ensure we
      continue searching down the tree visiting each node once.
    */
    if(nNode != 0)
    {
      if(nNode->nodeid == pNode->nodeid)
        pNode = 0;
      else if(is_leaf(nNode))
        pNode = 0;
      else
        pNode = nNode;
    }
  }

  /*
    Find a node with projections and push down the tree using
    a recursive call. Continue until you get the same node twice.
    This means that the node cannot be pushed down any further.
  */
  pNode = find_projection(root);
  while(pNode != 0)
  {
    push_projections(root, pNode);
    nNode = find_projection(root);
    /*
      If a node is found, save a reference to it unless it is
      either the same node as the last node found or
      it is a leaf node. This is done so that we can ensure we
      continue searching down the tree visiting each node once.
    */
    if(nNode != 0)
    {
      if(nNode->nodeid == pNode->nodeid)
        pNode = 0;
      else if(is_leaf(nNode))
        pNode = 0;
      else
        pNode = nNode;
    }
  }

  /*
    Find a join node and push it down the tree using
    a recursive call. Continue until you get the same node twice.
    This means that the node cannot be pushed down any further.
  */
  pNode = find_join(root);
  while(pNode != 0)
  {
    push_joins(root, pNode);
    nNode = find_join(root);
    /*
      If a node is found, save a reference to it unless it is
      either the same node as the last node found or
      it is a leaf node. This is done so that we can ensure we
      continue searching down the tree visiting each node once.
    */
    if(nNode != 0)
    {
      if(nNode->nodeid == pNode->nodeid)
        pNode = 0;
      else if(is_leaf(nNode))
        pNode = 0;
      else
        pNode = nNode;
    }
    else
      pNode = nNode;
  }

  /*
    Prune the tree of "blank" nodes
    Blank Nodes are:
     1) projections without attributes that have at least 1 child
     2) restrictions without expressions
     BUT...Can't delete a node that has TWO children!
  */
  prune_tree(0, root);

  /*
    Lastly, check to see if this has the DISTINCT option.
    If so, create a new node that is a DISTINCT operation.
  */
  if(distinct && (root->node_type != qntDistinct))
  {
    int i;
    pNode = (query_node*)my_malloc(sizeof(query_node),
            MYF(MY_ZEROFILL | MY_WME));
    init_node(pNode);
    pNode->sub_query = 0;
    pNode->attributes = 0;
    pNode->join_cond = jcUN;  /* (join_con_type) 0; */
    pNode->join_type = jnUNKNOWN;  /* (type_join) 0; */
    pNode->left = root;
    pNode->right = 0;
    for(i = 0; i < MAXNODETABLES; i++)
      pNode->relations[i] = NULL;
    pNode->nodeid = 90125;  // sentinel value to indicate node is not set
    pNode->child = LEFTCHILD;
    root->parent_nodeid = 90125;  // sentinel value to indicate node is not set
    root->child = LEFTCHILD;
    pNode->parent_nodeid = −1;
    pNode->node_type = qntDistinct;
    pNode->attributes = new Attribute();
    pNode->where_expr = new Expression();
    pNode->join_expr = new Expression();
    root = pNode;
  }
  DBUG_RETURN(0);
}
```

请注意用于定位限制、投影和连接的循环。该代码被设计为使用前序遍历遍历树，应用规则，直到不再有违反规则的条件(即，没有“坏的”节点放置)。

下面的清单显示了前面描述的`heuristic_optimization()`方法中主要方法的一些源代码。为了节省空间，我没有列出次要的助手方法，因为它们是 MySQL 结构和类方法的简单抽象。您应该下载本章的源代码，并研究其他帮助器方法，看看它们是如何工作的。

`split_restrict_with_join()`方法在树中搜索具有`where`表达式的连接(因此既是连接又是限制)，并将它们分成两个节点:一个连接和一个限制节点。清单 13-11 显示了这个方法的源代码。

[***清单 13-11。***](#_list11) 分割制约合并

```sql
/*
  Split restrictions that have joins.

  SYNOPSIS
    split_restrict_with_join()
    query_node *QN IN the node to operate on

  DESCRIPTION
     This method looks for joins that have where expressions (thus are both
     joins and restrictions) and breaks them into two nodes.

  NOTES
    This is a RECURSIVE method!

  RETURN VALUE
    Success = 0
    Failed = 1
*/
int Query_tree::split_restrict_with_join(query_node *QN)
{
  int j = 0;
  int i = 0;

  DBUG_ENTER("split_restrict_with_join");
  if(QN != 0)
  {
    if(((QN->join_expr->num_expressions() > 0) &&
      (QN->where_expr->num_expressions() > 0)) &&
       ((QN->node_type == qntJoin) || (QN->node_type == qntRestrict)))
    {
      bool isleft = true;
      /*
        Create a new node and:
          1) Move the where expressions to the new node.
          2) Set the new node's children = current node children
          3) Set the new node's relations = current node relations.
          4) Set current node's left or right child = new node;
          5) Set new node's id = current id + 200;
           6) set parent id, etc.
          7) determine which table needs to be used for the
             restrict node.
      */
      query_node *new_node = (query_node*)my_malloc(sizeof(query_node),
                             MYF(MY_ZEROFILL | MY_WME));
      init_node(new_node);
      new_node->node_type = qntRestrict;
      new_node->parent_nodeid = QN->nodeid;
      new_node->nodeid = QN->nodeid + 200;
      new_node->where_expr = QN->where_expr;
      new_node->join_expr = new Expression();
      QN->where_expr = new Expression();

      /*
        Loop through tables and move table that matches
        to the new node
      */
      for(i = 0; i < MAXNODETABLES; i++)
      {
        if (QN->relations[i] != NULL)
        {
          if (find_table_in_expr(new_node->where_expr,
                QN->relations[i]->table_name))
          {
            new_node->relations[j] = QN->relations[i];
            j++;
            if (i != 0)
              isleft = false;
            QN->relations[i] = NULL;
          }
        }
      }

      /* set children to point to balance of tree */
      new_node->right = 0;
      if (isleft)
      {
        new_node->child = LEFTCHILD;
        new_node->left = QN->left;
        QN->left = new_node;
      }
      else
      {
        new_node->child = RIGHTCHILD;
        new_node->left = QN->right;
        QN->right = new_node;
      }
      if (new_node->left)
        new_node->left->parent_nodeid = new_node->nodeid;
      j = QN->attributes->num_attributes();
      if ((QN->node_type == qntJoin) && (j > 0))
      {
        Attribute *attribs = 0;
        Item * attr;
        int ii = 0;
        int jj = 0;
        if ((QN->attributes->num_attributes() == 1) &&
            (strcasecmp("*",
            ((Field *)QN->attributes->get_attribute(0))->field_name) == 0))
        {
          new_node->attributes = new Attribute();
          new_node->attributes->add_attribute(j,
            QN->attributes->get_attribute(0));
        }
        else
        {
          attribs = new Attribute();
          for (i = 0; i < (int)new_node->relations[0]->table->s->fields; i++)
          {
            Item *f = (Item *)new_node->relations[0]->table->field[i];
            attribs->add_attribute(true, (Item *)f);
          }
          j = attribs->num_attributes();
          new_node->attributes = new Attribute();
          for (i = 0; i < j; i++)
          {
            attr = attribs->get_attribute(i);
            jj = QN->attributes->index_of(
              (char *)((Field *)attr)->table->s->table_name.str,
              (char *)((Field *)attr)->field_name);
            if (jj > −1)
            {
              new_node->attributes->add_attribute(ii, attr);
              ii++;
              QN->attributes->remove_attribute(jj);
            }
            else if (find_attr_in_expr(QN->join_expr,
             (char *)((Field *)attr)->table->s->table_name.str,
             (char *)((Field *)attr)->field_name))
            {
              new_node->attributes->add_attribute(ii, attr);
              new_node->attributes->hide_attribute(attr, true);
              ii++;
            }
          }
        }
      }
      else
      {
        QN->node_type = qntJoin;
        QN->join_type = jnINNER;
        new_node->attributes = new Attribute();
      }
    }
    split_restrict_with_join(QN->left);
    split_restrict_with_join(QN->right);
  }
  DBUG_RETURN(0);
}
```

`split_project_with_join()`方法在树中搜索具有属性的连接(因此既是连接又是投影),并将它们分成两个节点:一个连接和一个项目节点。[清单 13-12](#list12) 显示了这个方法的源代码。

[***清单 13-12。***](#_list12) 拆分项目合并

```sql
/*
  Split projections that have joins.

  SYNOPSIS
    split_project_with_join()
    query_node *QN IN the node to operate on

  DESCRIPTION
     This method looks for joins that have attributes (thus are both
     joins and projections) and breaks them into two nodes.

  NOTES
    This is a RECURSIVE method!

  RETURN VALUE
    Success = 0
    Failed = 1
*/
int Query_tree::split_project_with_join(query_node *QN)
{
  int j = 0;
  int i;

  DBUG_ENTER("split_project_with_join");
  if(QN != 0)
  {
    if((QN->join_expr->num_expressions() > 0) &&
       ((QN->node_type == qntJoin) || (QN->node_type == qntProject)))
    {
      /*
        Create a new node and:
          1) Move the where expressions to the new node.
          2) Set the new node's children = current node children
          3) Set the new node's relations = current node relations.
          4) Set current node's left or right child = new node;
          5) Set new node's id = current id + 300;
          6) set parent id, etc.
      */
      QN->node_type = qntJoin;
      QN->join_type = jnINNER;
      if (QN->left == 0)
      {
        query_node *new_node = (query_node*)my_malloc(sizeof(query_node),
                               MYF(MY_ZEROFILL | MY_WME));
        init_node(new_node);
        new_node->node_type = qntProject;
        new_node->parent_nodeid = QN->nodeid;
        new_node->nodeid = QN->nodeid + 300;
        for(i = 0; i < MAXNODETABLES; i++)
          new_node->relations[i] = 0;
        new_node->relations[0] = QN->relations[0];
        QN->relations[0] = 0;
        new_node->left = QN->left;
        QN->left = new_node;
        new_node->right = 0;
        new_node->child = LEFTCHILD;
        if (new_node->left != 0)
           new_node->left->parent_nodeid = new_node->nodeid;
        j = QN->attributes->num_attributes();
        new_node->attributes = new Attribute();
        new_node->where_expr = new Expression();
        new_node->join_expr = new Expression();
        if ((j == 1) &&
            (strcasecmp("*", ((Field *)QN->attributes->get_attribute(0))->field_name)==0))
        {
          new_node->attributes = new Attribute();
          new_node->attributes->add_attribute(j, QN->attributes->get_attribute(0));
          if (QN->right != 0)
            QN->attributes->remove_attribute(0);
        }
        else if (j > 0)
        {
          Attribute *attribs = 0;
          Item * attr;
          int ii = 0;
          int jj = 0;
          attribs = new Attribute();
          for (i = 0; i < (int)new_node->relations[0]->table->s->fields; i++)
          {
            Field *f = new_node->relations[0]->table->field[i];
            attribs->add_attribute(true, (Item *)f);
          }
          j = attribs->num_attributes();
          for (i = 0; i < j; i++)
          {
            attr = attribs->get_attribute(i);
            jj = QN->attributes->index_of(
              (char *)((Field *)attr)->table->s->table_name.str,
              (char *)((Field *)attr)->field_name);
            if (jj > −1)
            {
              new_node->attributes->add_attribute(ii, attr);
              ii++;
              QN->attributes->remove_attribute(jj);
            }
            else if (find_attr_in_expr(QN->join_expr,
              (char *)((Field *)attr)->table->s->table_name.str,
              (char *)((Field *)attr)->field_name))
            {
              new_node->attributes->add_attribute(ii, attr);
              new_node->attributes->hide_attribute(attr, true);
              ii++;
            }
          }
        }
      }
      if (QN->right == 0)
      {
        query_node *new_node = (query_node*)my_malloc(sizeof(query_node),
                               MYF(MY_ZEROFILL | MY_WME));
        init_node(new_node);
        new_node->node_type = qntProject;
        new_node->parent_nodeid = QN->nodeid;
        new_node->nodeid = QN->nodeid + 400;
        for(i = 0; i < MAXNODETABLES; i++)
          new_node->relations[0] = 0;
        new_node->relations[0] = QN->relations[1];
        QN->relations[1] = 0;
        new_node->left = QN->right;
        QN->right = new_node;
        new_node->right = 0;
        new_node->child = RIGHTCHILD;
        if (new_node->left != 0)
          new_node->left->parent_nodeid = new_node->nodeid;
        j = QN->attributes->num_attributes();
        new_node->attributes = new Attribute();
        new_node->where_expr = new Expression();
        new_node->join_expr = new Expression();
        if ((j == 1) &&
            (strcasecmp("*", ((Field *)QN->attributes->get_attribute(0))->field_name)==0))
        {
          new_node->attributes = new Attribute();
          new_node->attributes->add_attribute(j, QN->attributes->get_attribute(0));
          QN->attributes->remove_attribute(0);
        }
        else
        {
          Attribute *attribs = 0;
          Item * attr;
          int ii = 0;
          int jj = 0;
          attribs = new Attribute();
          for (i = 0; i < (int)new_node->relations[0]->table->s->fields; i++)
          {
            Field *f = new_node->relations[0]->table->field[i];
            attribs->add_attribute(true, (Item *)f);
            if (j == 0)
            {
              new_node->attributes->hide_attribute((Item *)f, true);
            }
          }
          j = attribs->num_attributes();
          new_node->attributes = new Attribute();
          for (i = 0; i < j; i++)
          {
            attr = attribs->get_attribute(i);
            jj = QN->attributes->index_of(
              (char *)((Field *)attr)->table->s->table_name.str,
              (char *)((Field *)attr)->field_name);
            if (jj > −1)
            {
              new_node->attributes->add_attribute(ii, attr);
              ii++;
              QN->attributes->remove_attribute(jj);
            }
            else if (find_attr_in_expr(QN->join_expr,
              (char *)((Field *)attr)->table->s->table_name.str,
              (char *)((Field *)attr)->field_name))
            {
              new_node->attributes->add_attribute(ii, attr);
              new_node->attributes->hide_attribute(attr, true);
              ii++;
            }
          }
        }
      }
    }
    split_project_with_join(QN->left);
    split_project_with_join(QN->right);
  }
  DBUG_RETURN(0);
}
```

`split_restrict_with_project()`方法在树中搜索具有属性的限制(因此既是投影又是限制),并将它们分成两个节点:一个限制节点和一个项目节点。[清单 13-13](#list13) 显示了这个方法的源代码。

[***清单 13-13。***](#_list13) 用项目分割制约

```sql
/*
  Split restrictions that have attributes (projections).

  SYNOPSIS
    split_restrict_with_project()
    query_node *QN IN the node to operate on

  DESCRIPTION
    This method looks for restrictions that have attributes (thus are both
    projections and restrictions) and breaks them into two nodes.

  NOTES
    This is a RECURSIVE method!

  RETURN VALUE
    Success = 0
    Failed = 1
*/
int Query_tree::split_restrict_with_project(query_node *QN)
{
  DBUG_ENTER("split_restrict_with_project");
  if(QN != 0)
  {
    if(((QN->attributes->num_attributes() > 0) &&
      (QN->where_expr->num_expressions() > 0)) &&
      ((QN->node_type == qntProject) || (QN->node_type == qntRestrict)))
    {
      /*
        Create a new node and:
          1) Move the expressions to the new node.
           2) Set the new node's children = current node children
          3) Set the new node's relations = current node relations.
          4) Set current node's left child = new node;
          5) Set new node's id = current id + 1000;
          6) set parent id, etc.
      */
      query_node *new_node = (query_node*)my_malloc(sizeof(query_node),
                             MYF(MY_ZEROFILL | MY_WME));
      init_node(new_node);
      new_node->child = LEFTCHILD;
      new_node->node_type = qntRestrict;
      if(new_node->node_type == qntJoin)
      {
        new_node->join_cond = QN->join_cond;
        new_node->join_type = QN->join_type;
      }
      QN->node_type = qntProject;
      new_node->attributes = new Attribute();
      new_node->where_expr = QN->where_expr;
      new_node->join_expr = new Expression();
      QN->where_expr = new Expression();
      new_node->left = QN->left;
      new_node->right = QN->right;
      new_node->parent_nodeid = QN->nodeid;
      new_node->nodeid = QN->nodeid + 1000;
      if(new_node->left)
        new_node->left->parent_nodeid = new_node->nodeid;
      if(new_node->right)
        new_node->right->parent_nodeid = new_node->nodeid;
      for(int i = 0; i < MAXNODETABLES; i++)
      {
        new_node->relations[i] = QN->relations[i];
        QN->relations[i] = NULL;
      }
      QN->left = new_node;
      QN->right = 0;
    }
    split_restrict_with_project(QN->left);
    split_restrict_with_project(QN->right);
  }
  DBUG_RETURN(0);
}
```

`find_restriction()`方法从起始节点(`QN`)开始在树中搜索下一个限制。如果找到限制，则返回指向该节点的指针；否则，该方法返回`NULL`。[清单 13-14](#list14) 显示了这个方法的源代码。

[***清单 13-14。***](#_list14) 寻找制约

```sql
/*
  Find a restriction in the subtree.
  SYNOPSIS
    find_restriction()
    query_node *QN IN the node to operate on

  DESCRIPTION
    This method looks for a node containing a restriction and returns the node
    pointer.

  NOTES
    This is a RECURSIVE method!
    This finds the first restriction and is biased to the left tree.

  RETURN VALUE
    Success = query_node * the node located
    Failed = NULL
*/
Query_tree::query_node *Query_tree::find_restriction(query_node *QN)
{
  DBUG_ENTER("find_restriction");
  query_node   *N;

  N = 0;
  if(QN != 0)
  {
    /*
      A restriction is a node marked as restrict and
      has at least one expression
    */
    if (QN->where_expr->num_expressions() > 0)
      N = QN;
    else
    {
      N = find_restriction(QN->left);
      if(N == 0)
        N = find_restriction(QN->right);
    }
  }
  DBUG_RETURN(N);
}
```

`push_restriction()`方法 从起始节点(`QN`)开始搜索树，并将约束节点(`pNode`)向下推到包含约束中指定的关系的节点。清单 13-15 显示了这个方法的源代码。

[***清单 13-15。***](#_list15) 推送限制

```sql
/*
  Push restrictions down the tree.

  SYNOPSIS
    push_restrictions()
    query_node *QN IN the node to operate on
    query_node *pNode IN the node containing the restriction attributes

  DESCRIPTION
    This method looks for restrictions and pushes them down the tree to nodes
    that contain the relations specified.

  NOTES
    This is a RECURSIVE method!
    This finds the first restriction and is biased to the left tree.

  RETURN VALUE
    Success = 0
    Failed = 1
*/
int Query_tree::push_restrictions(query_node *QN, query_node *pNode)
{
  query_node       *NewQN=0;

  DBUG_ENTER("push_restrictions");
  if((QN != 0) && (pNode != 0) && (pNode->left != 0))
  {
    /*
      Conditions:
        1) QN is a join node
        2) QN is a project node
        3) QN is a restrict node
        4) All other nodes types are ignored.

      Methods:
        1) if join or project and the children are not already restrictions
           add a new node and put where clause in new node else
           see if you can combine the child node and this one
        2) if the node has the table and it is a join,
           create a new node below it and push the restriction
           to that node.
        3) if the node is a restriction and has the table,
           just add the expression to the node's expression list
    */

    /* if projection, move node down tree */
    if((QN->nodeid != pNode->nodeid) && (QN->node_type == qntProject))
    {
      if (QN->left != 0)
      {
        QN->left = (query_node*)my_malloc(sizeof(query_node),
                   MYF(MY_ZEROFILL | MY_WME));
        init_node(QN->left);
        NewQN = QN->left;
        NewQN->left = 0;
      }
      else
      {
        NewQN = QN->left;
        QN->left = (query_node*)my_malloc(sizeof(query_node),
                   MYF(MY_ZEROFILL | MY_WME));
        QN->left->left = NewQN;
        NewQN = QN->left;
      }
      NewQN->sub_query = 0;
      NewQN->join_cond = jcUN;  /* (join_con_type) 0; */
      NewQN->join_type = jnUNKNOWN;  /* (type_join) 0; */
      NewQN->right = 0;
      for(long i = 0; i < MAXNODETABLES; i++)
        NewQN->relations[i] = 0;
      NewQN->nodeid = QN->nodeid + 1;
      NewQN->parent_nodeid = QN->nodeid;
      NewQN->node_type = qntRestrict;
      NewQN->attributes = new Attribute();
      NewQN->where_expr = new Expression();
      NewQN->join_expr = new Expression();
      if (pNode->relations[0])
        NewQN->where_expr->reduce_expressions(pNode->relations[0]->table);
      if ((QN->relations[0] != NULL) && (QN->relations[0] == pNode->relations[0]))
      {
        if (QN->relations[0])
        {
          if (find_table_in_expr(pNode->where_expr, QN->relations[0]->table_name))
          {
            NewQN->relations[0] = QN->relations[0];
            QN->relations[0] = 0;
          }
        }
      }
      else
      {
        if (pNode->relations[0])
          if (find_table_in_tree(QN->left, pNode->relations[0]->table_name))
            NewQN->relations[0] = 0;
        pNode->where_expr = NULL;
        pNode->relations[0] = 0;
      }
    }
    /* if join, move restrict node down tree */
    else if((QN->nodeid != pNode->nodeid) &&
      ((QN->left == 0) || (QN->right == 0)) &&
      (QN->node_type == qntJoin))
    {
      if(QN->relations[0] != 0)
      {
        QN->left = (query_node*)my_malloc(sizeof(query_node),
                   MYF(MY_ZEROFILL | MY_WME));
        NewQN = QN->left;
        NewQN->sub_query = 0;
        NewQN->join_cond = jcUN;  /* (join_con_type) 0; */
        NewQN->join_type = jnUNKNOWN;  /* (type_join) 0; */
        NewQN->left = 0;
        NewQN->right = 0;
        for(long i = 0; i < MAXNODETABLES; i++)
          NewQN->relations[i] = 0;
        NewQN->nodeid = QN->nodeid + 1;
        NewQN->parent_nodeid = QN->nodeid;
        NewQN->node_type = qntRestrict;
        NewQN->attributes = new Attribute();
        NewQN->where_expr = new Expression();
        NewQN->join_expr = new Expression();
        NewQN->relations[0] = QN->relations[0];
        QN->relations[0] = 0;
        if (pNode->relations[0])
          NewQN->where_expr->reduce_expressions(pNode->relations[0]->table);
      }
      else if(QN->relations[1] != 0)
      {
        QN->right = (query_node*)my_malloc(sizeof(query_node),
                    MYF(MY_ZEROFILL | MY_WME));
        NewQN = QN->left;
        NewQN->sub_query = 0;
        NewQN->join_cond = jcUN;  /* (join_con_type) 0; */
        NewQN->join_type = jnUNKNOWN;  /* (type_join) 0; */
        NewQN->left = 0;
        NewQN->right = 0;
        for(long i = 0; i < MAXNODETABLES; i++)
          NewQN->relations[i] = 0;
      }
      NewQN->nodeid = QN->nodeid + 1;
      NewQN->parent_nodeid = QN->nodeid;
      NewQN->node_type = qntRestrict;
      NewQN->attributes = new Attribute();
      NewQN->where_expr = new Expression();
      NewQN->join_expr = new Expression();
      NewQN->relations[0] = QN->relations[1];
      QN->relations[1] = 0;
      NewQN->where_expr->reduce_expressions(pNode->relations[0]->table);
    }
    push_restrictions(QN->left, pNode);
    push_restrictions(QN->right, pNode);
  }
   DBUG_RETURN(0);
}
```

`find_projection()`方法从起始节点(`QN`)开始搜索树，寻找树中的下一个投影。如果找到投影，则返回指向该节点的指针；否则，该方法返回`NULL`。清单 13-16 显示了这个方法的源代码。

[***清单 13-16。***](#_list16) 寻找投影

```sql
/*
  Find a projection in the tree

  SYNOPSIS
    find_projection()
    query_node *QN IN the node to operate on

  DESCRIPTION
    This method looks for a node containing a projection and returns the node
    pointer.

  NOTES
    This finds the first projection and is biased to the left tree.
    This is a RECURSIVE method!

  RETURN VALUE
    Success = query_node * the node located or NULL for not found
    Failed = NULL
*/
Query_tree::query_node *Query_tree::find_projection(query_node *QN)
{
  DBUG_ENTER("find_projection");
  query_node   *N;

  N = 0;
  if(QN != 0)
  {
    /*
      A projection is a node marked as project and
      has at least one attribute
    */
    if((QN->node_type == qntProject) &&
       (QN->attributes != 0))
      N = QN;
    else
    {
      N = find_projection(QN->left);
      if(N == 0)
        N = find_projection(QN->right);
    }
  }
  DBUG_RETURN(N);
}
```

`push_projection()`方法 从起始节点(`QN`)开始搜索树，并将投影节点(`pNode`)向下推到包含投影中指定的关系的节点。清单 13-17 显示了这个方法的源代码。

[***清单 13-17。***](#_list17) 推投影

```sql
/*
  Push projections down the tree.

  SYNOPSIS
    push_projections()
    query_node *QN IN the node to operate on
    query_node *pNode IN the node containing the projection attributes

  DESCRIPTION
    This method looks for projections and pushes them down the tree to nodes
    that contain the relations specified.

  NOTES
    This is a RECURSIVE method!

  RETURN VALUE
    Success = 0
    Failed = 1
*/
int Query_tree::push_projections(query_node *QN, query_node *pNode)
{
  DBUG_ENTER("push_projections");
  Item *   a;
  int         i;
  int         j;

  if((QN != 0) && (pNode != 0))
  {
    if((QN->nodeid != pNode->nodeid) &&
       (QN->node_type == qntProject))
    {
      i = 0;
      j = QN->attributes->num_attributes();
      /* move attributes to new node */
      while(i < j)
      {
        a = QN->attributes->get_attribute(i);
        if(has_relation(QN,
          (char *)((Field *)a)->table->s->table_name.str))
        {
          if(!has_attribute(QN, a))
            insert_attribute(QN, a);
          del_attribute(pNode, a);
        }
        i++;
      }
    }
    if(pNode->attributes->num_attributes() != 0)
    {
      push_projections(QN->left, pNode);
      push_projections(QN->right, pNode);
    }
  }
  DBUG_RETURN(0);
}
```

`find_join ()`方法 从起始节点(`QN`)开始在树中搜索下一个连接。如果找到一个连接，则返回一个指向该节点的指针；否则，该方法返回`NULL`。清单 13-18 显示了这个方法的源代码。

[***清单 13-18。***](#_list18) 寻找加入

```sql
/*
  Find a join in the subtree.
  SYNOPSIS
    find_restriction()
    query_node *QN IN the node to operate on

  DESCRIPTION
    This method looks for a node containing a join and returns the
    node pointer.

  NOTES
    This is a RECURSIVE method!
    This finds the first restriction and is biased to the left tree.

  RETURN VALUE
    Success = query_node * the node located
    Failed = NULL
*/
Query_tree::query_node *Query_tree::find_join(query_node *QN)
{
  DBUG_ENTER("find_join");
  query_node               *N;
  N = 0;

  if(QN != 0)
  {
    /*
      if this is a restrict node or a restrict node with
      at least one expression it could be an unprocessed join
      because the default node type is restrict
    */
    if(((QN->node_type == qntRestrict) ||
      (QN->node_type == qntRestrict)) && (QN->join_expr->num_expressions() > 0))
      N = QN;
    else
    {
      N = find_join(QN->left);
      if(N == 0)
        N = find_join(QN->right);
    }
  }
  DBUG_RETURN(N);
}
```

`push_joins()`方法 从起始节点(`QN`)开始搜索树，并将连接节点(`pNode`)沿树向下推到一个位置，在该位置，连接是两个节点的父节点，这两个节点包含连接的子节点中指定的关系。清单 13-19 显示了这个方法的源代码。

[***清单 13-19。***](#_list19) 推归附

```sql
/*
  Push joins down the tree.

  SYNOPSIS
    push_restrictions()
    query_node *QN IN the node to operate on
    query_node *pNode IN the node containing the join

  DESCRIPTION
    This method looks for theta joins and pushes them down the tree to the
    parent of two nodes that contain the relations specified.

  NOTES
    This is a RECURSIVE method!

  RETURN VALUE
    Success = 0
    Failed = 1
*/
int Query_tree::push_joins(query_node *QN, query_node *pNode)
{
  DBUG_ENTER("push_joins");
  Item *lField;
  Item *rField;
  expr_node *node;

  if(!pNode->join_expr)
    DBUG_RETURN(0);
  node = pNode->join_expr->get_expression(0);
  if (!node)
    DBUG_RETURN(0);
  lField = node->left_op;
  rField = node->right_op;

  /* Node must have expressions and not be null */
  if((QN != NULL) && (pNode != NULL) &&
     (pNode->join_expr->num_expressions() > 0))
  {
    /* check to see if tables in join condition exist */
    if((QN->nodeid != pNode->nodeid) &&
       (QN->node_type == qntJoin) &&
        QN->join_expr->num_expressions() == 0 &&
       ((has_relation(QN->left,
         (char *)((Field *)lField)->table->s->table_name.str) &&
       has_relation(QN->right,
         (char *)((Field *)rField)->table->s->table_name.str)) ||
      (has_relation(QN->left,
        (char *)((Field *)rField)->table->s->table_name.str) &&
       has_relation(QN->right,
         (char *)((Field *)lField)->table->s->table_name.str))))
    {
      /* move the expression */
      QN->join_expr = pNode->join_expr;
      pNode->join_expr = new Expression();
      QN->join_type = jnINNER;
      QN->join_cond = jcON;
    }
    push_joins(QN->left, pNode);
    push_joins(QN->right, pNode);
  }
  DBUG_RETURN(0);
}
```

`prune_tree()`方法 在树上搜索作为对树执行启发式优化的结果的空白节点(不再具有任何操作或功能的节点)并删除它们。清单 13-20 显示了这个方法的源代码。

[***清单 13-20。***](#_list20) 修枝树

```sql
/*
  Prune the tree of dead limbs.

  SYNOPSIS
    prune_tree()
    query_node *prev IN the previous node (parent)
    query_node *cur_node IN the current node pointer (used to delete).

  DESCRIPTION
    This method looks for nodes blank nodes that are a result of performing
    heuristic optimization on the tree and deletes them.

  NOTES
    This is a RECURSIVE method!

  RETURN VALUE
    Success = 0
    Failed = 1
*/
int Query_tree::prune_tree(query_node *prev, query_node *cur_node)
{
  DBUG_ENTER("prune_tree");
  if(cur_node != 0)
  {
    /*
      Blank Nodes are 1) projections without attributes
      that have at least 1 child, or 2) restrictions
      without expressions
    */
    if((((cur_node->node_type == qntProject) &&
       (cur_node->attributes->num_attributes() == 0)) ||
      ((cur_node->node_type == qntRestrict) &&
       (cur_node->where_expr->num_expressions() == 0))) &&
       ((cur_node->left == 0) || (cur_node->right == 0)))
    {
      /*
        Redirect the pointers for the nodes above and
        below this node in the tree.
      */
      if(prev == 0)
      {
         if(cur_node->left == 0)
        {
          cur_node->right->parent_nodeid = −1;
          root = cur_node->right;
        }
        else
        {
          cur_node->left->parent_nodeid = −1;
          root = cur_node->left;
        }
        my_free(cur_node);
        cur_node = root;
      }
      else
      {
        if(prev->left == cur_node)
        {
          if(cur_node->left == 0)
          {
            prev->left = cur_node->right;
            if (cur_node->right != NULL)
              cur_node->right->parent_nodeid = prev->nodeid;
          }
          else
          {
            prev->left = cur_node->left;
            if (cur_node->left != NULL)
              cur_node->left->parent_nodeid = prev->nodeid;
          }
          my_free(cur_node);
          cur_node = prev->left;
        }
        else
        {
          if(cur_node->left == 0)
          {
            prev->right = cur_node->right;
            if (cur_node->right != NULL)
              cur_node->right->parent_nodeid = prev->nodeid;
          }
          else
          {
            prev->right = cur_node->left;
            if (cur_node->left != NULL)
              cur_node->left->parent_nodeid = prev->nodeid;
          }
          my_free(cur_node);
          cur_node = prev->right;
        }
      }
      prune_tree(prev, cur_node);
    }
    else
    {
      prune_tree(cur_node, cur_node->left);
      prune_tree(cur_node, cur_node->right);
    }
  }
  DBUG_RETURN(0);
}
```

编译和测试代码

如果还没有，下载本章的源代码，并将文件放在源代码根目录下的`/sql`目录中。在示例代码中，您还会发现一个差异文件(ch13.diff ),您可以使用它将更改应用到服务器源代码文件(例如 mysqld.cc sql_cmd.h 等)。).或者，您可以使用第 12 章中的修改，因为对服务器代码的修改是相同的。

花一些时间浏览源代码，以便熟悉这些方法。如果您需要调试代码以使用您的配置，或者如果您想要添加其他增强功能或进行练习，现在花时间浏览代码将会有所帮助。

一旦下载了所有的源代码文件并检查了代码，就将这些文件添加到 CMakeLists.txt 文件中。详见第 12 章中[的“将文件添加到 CMakeLists.txt 文件中”。您将添加`attribute`和`expression`辅助源文件(attribute.cc 和 expression.cc)。将文件添加到项目后，导航到源代码树的根目录，运行 cmake，并发出如下所示的命令。确保代码编译时没有编译错误。](12.html)

```sql
cmake .
make
```

一旦安装并编译了新代码，运行服务器并执行测试。您可以运行之前创建的测试，也可以在 MySQL 客户端实用程序中输入命令。清单 13-21 显示了运行测试中列出的命令的预期输出。

[***清单 13-21。***](#_list21) 示例测试运行

```sql
DBXP_SELECT * FROM staff' at line 1
+−−------------------------+
| Execution Path           |
+−−------------------------+
|      expert_mysql.staff  |
|           |              |
|           |              |
|           |              |
|           V              |
|      ------------------- |
|      |    RESTRICT     | |
|      ------------------- |
|      | Access Method:  | |
|      |    iterator     | |
|      ------------------- |
|           |              |
|           |              |
|           |              |
|           V              |
|      ------------------- |
|      |     PROJECT     | |
|      ------------------- |
|      | Access Method:  | |
|      |    iterator     | |
|      ------------------- |
|              |           |
|              |           |
|              V           |
|          Result Set      |
+−−------------------------+
25 rows in set (0.00 sec)

+−−--------------------------------------------------+
| Execution Path                                     |
+−−--------------------------------------------------+
|      expert_mysql.staff                            |
|           |                                        |
|           |                                        |
|           |                                        |
|           V                                        |
|      -------------------                           |
|      |     PROJECT     |                           |
|      -------------------                           |
|      | Access Method:  |                           |
|      |    iterator     |                           |
|      -------------------                           |
|           |               expert_mysql.directorate |
|           |                    |                   |
|           |                    |                   |
|           |                    |                   |
|           |                    V                   |
|           |               -------------------      |
|           |               |     PROJECT     |      |
|           |               -------------------      |
|           |               | Access Method:  |      |
|           |               |    iterator     |      |
|           |               -------------------      |
|           |                              |         |
|           |   ----------------------------         |
|           |   |                                    |
|           V   V                                    |
|      -------------------                           |
|      |      JOIN       |                           |
|      -------------------                           |
|      | Access Method:  |                           |
|      |    iterator     |                           |
|      -------------------                           |
|              |                                     |
|              |                                     |
|              V                                     |
|          Result Set                                |
+−−--------------------------------------------------+
36 rows in set (0.00 sec)

+−−----------------------------------------------+
| Execution Path                                 |
+−−----------------------------------------------+
|      expert_mysql.staff                        |
|           |                                    |
|           |                                    |
|           |                                    |
|           V                                    |
|      -------------------                       |
|      |    RESTRICT     |                       |
|      -------------------                       |
|      | Access Method:  |                       |
|      |    iterator     |                       |
|      -------------------                       |
|           |               expert_mysql.tasking |
|           |                    |               |
|           |                    |               |
|           |                    |               |
|           |                    V               |
|           |               -------------------  |
|           |               |     PROJECT     |  |
|           |               -------------------  |
|           |               | Access Method:  |  |
|           |               |    iterator     |  |
|           |               -------------------  |
|           |                              |     |
|           |   ----------------------------     |
|           |   |                                |
|           V   V                                |
|      -------------------                       |
|      |      JOIN       |                       |
|      -------------------                       |
|      | Access Method:  |                       |
|      |    iterator     |                       |
|      -------------------                       |
|              |                                 |
|              |                                 |
|              V                                 |
|          Result Set                            |
+−−----------------------------------------------+
36 rows in set (0.00 sec)

Query OK, 4 rows affected (0.00 sec)
mysql >
```

请注意输入的每个语句的查询计划有何不同。花些时间研究其他查询语句，看看优化器如何优化其他形式的查询。

![image](img/sq.jpg) **注意**`DBXP_SELECT`命令的输出一开始可能看起来有点奇怪(它们是查询计划)，但是回想一下之前我们在`sql_dbxp_parser.cc`文件中删除了`DBXP_select_command()`方法以重定向到`DBXP_explain_select_command()`方法。我们将在下一章添加查询的执行。

摘要

在本章中，我介绍了最复杂的数据库内部技术——优化器。您了解了如何扩展查询树的概念，以包含一个在优化过程中使用树结构的查询优化器。更重要的是，您发现了如何构建启发式查询优化器。启发式优化器的知识应该让您更好地理解 DBXP 引擎，以及如何使用它来更深入地研究数据库技术。没有比优化器更深入的了！

在下一章中，我将通过一个查询树优化策略的示例实现向您展示更多关于查询执行的内容。下一章将通过使用查询树类将启发式查询优化器链接到一个也使用查询树结构的执行过程来完成 DBXP 引擎。

练习

下面列出了几个需要进一步探索的领域。它们代表了您可能希望作为实验(或作为课堂作业)来探索关系数据库技术的活动类型。

1.  完成`balance_joins()`方法的代码。提示:您需要创建一个可以移动合取连接的算法，以便首先执行限制性最强的连接(位于树的最底层)。
2.  完成`cost_optimization()`方法的代码。提示:您需要遍历树并指出可以使用索引的节点。
3.  检查启发式优化器的代码。它涵盖了所有可能的查询吗？如果不是，有没有其他规则可以用来完成保险？
4.  检查查询树和启发式优化器的代码。如何实现查询树类中列出的 distinct 节点类型？提示:参见`heuristic_optimization()`方法中`prune_tree()`方法后面的代码。
5.  如何更改代码来识别无效查询？确定查询无效的条件是什么？如何测试这些条件？
6.  (高级)MySQL 目前不支持 intersect 操作(按日期定义)。更改 MySQL 解析器以识别新的关键字并处理查询，例如`SELECT * FROM A INTERSECT B`。这个操作有什么限制吗，它们在优化器中有反映吗？
7.  (高级)你将如何实现`GROUP BY`、`ORDER BY`和`HAVING`子句？对优化器进行更改以启用这些子句。

[<sup>1</sup>](#_Fn1) P. G .塞林格、M. M .阿斯特拉姆、D. D .钱伯林、R. A .洛里斯、T. G .普莱斯。1979."关系数据库管理系统中的访问路径选择."*ACM SIGMOD 数据管理国际会议记录*，苏格兰阿伯丁:23–34。被一些人认为是“查询优化的圣经”

[<sup>2</sup>](#_Fn2) M .斯通布雷克，e .黄，p .克雷普斯。1976." INGRES 的设计和实现."*数据库系统上的 ACM 事务*1(3):189–222。

[<sup>3</sup>](#_Fn3)T0】

[<sup>4</sup>](#_Fn4) 传统系统中的查询执行不仅包括处理查询，还包括从物理介质中访问数据。然而，内存系统没有与从物理介质中检索相关联的长访问时间。

这种做法至今仍被大多数商业数据库系统所采用。

[<sup>6</sup>](#_Fn6) 实时统计的累加称为捎带统计生成。

[<sup>7</sup>](#_Fn7) D .科斯曼和 k .斯托克。2000."迭代动态规划:一类新的查询优化算法." *ACM 数据库系统汇刊*25(1):43–82。

[<sup>8</sup>](#_Fn8) Y. E .约安尼迪斯、R. T. Ng、K. Shim 和 T. Sellis。1997.“参数查询优化。” *VLDB 日报*6:132–151。

[<sup>9</sup>](#_Fn9) 在这种情况下，高效的执行未必是最优方案。

[<sup>10</sup>](#_Fn10) 数据库新手常用的技巧。

[<sup>11</sup>](#_Fn11) 可能不允许使用索引进行连接操作。

[<sup>12</sup>](#_Fn12) 李政道、施振荣、陈奕奕。2001."优化包含方法的查询的图论模型."LDB 日报 9:327–343。

[<sup>13</sup>](#_Fn13) 它不是一个真正的抽象类，因为它包含了一些在源代码中定义的方法。一个真正的抽象类将所有方法定义为`virtual`，因此它们被用作接口而不是基类。

[<sup>14</sup>](#_Fn14) 这段代码中的哨兵值来源于一张经典摇滚专辑。你知道乐队的名字吗？