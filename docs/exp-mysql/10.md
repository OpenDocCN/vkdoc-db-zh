# 十、构建您自己的存储引擎

MySQL 可插拔架构支持使用多个存储引擎，这是 MySQL 系统最重要的特性之一。许多数据库专业人员已经改进了调整关系数据库系统的逻辑结构的高级技能，以满足数据及其应用的需要。使用 MySQL，数据库专业人员还可以通过选择最佳存储方法来优化数据库的访问方法，从而优化数据库系统的物理层。与只使用单一存储机制的关系数据库系统相比，这是一个巨大的优势。 [<sup>1</sup>](#Fn1)

本章将指导您完成创建自己的存储引擎的过程。我首先详细解释构建存储引擎插件的细节，然后带您浏览构建示例存储引擎的教程。如果你一直渴望得到 MySQL 源代码，并让它做一些真正酷的事情，现在是时候卷起袖子重新灌满饮料了。如果你对做这种修改有点担心，请通读这一章并按照例子来做，直到你对这个过程感到满意为止。

MySQL 存储引擎概述

存储引擎插件是 MySQL 服务器架构中的一个软件层。它负责将物理数据层从服务器的逻辑层中抽象出来，并为服务器提供底层输入/输出(I/O)操作。当一个系统在分层架构中开发时，它提供了一种机制来简化和标准化各层之间的接口(T2)。这个质量衡量了分层架构的成功。分层体系结构的一个强大特性是能够修改一个层，并且如果接口没有改变，也不会改变相邻的层。

Oracle 重新设计了 MySQL 的架构(从版本 5.0 开始)，以纳入这种分层架构方法。插件架构是在版本 5.1 中添加的，可插拔存储引擎是这一努力最明显的形式。存储引擎插件使系统集成商和开发者能够在数据读写需要特殊处理的环境中使用 MySQL。此外，插件架构允许您创建自己的存储引擎。

这样做而不是将数据转换成 MySQL 可以接受的格式的一个原因是转换的成本。例如，假设您有一个您的组织已经使用了很长时间的遗留应用。应用使用的数据对您的组织来说非常有价值，不可复制。此外，您可能需要使用旧的应用。您可以创建一个能够以旧格式读写数据的存储引擎，而不是将数据转换为新格式。其他示例包括数据及其访问方法需要特殊的数据处理以确保最有效地读写数据的情况。

此外，也许是最重要的，存储引擎插件可以连接通常不与数据库系统连接的数据。也就是说，您可以创建存储引擎来读取流数据(例如 RSS)或其他非传统的、非磁盘存储的数据。无论您需要什么，MySQL 都可以满足您的需求，它允许您创建自己的存储引擎，使您能够为自己的环境创建高效、专用的关系数据库系统。

您可以使用 MySQL 服务器作为您的关系数据库处理引擎，并通过提供一个直接插入服务器的特殊存储引擎，将其直接连接到您的遗留数据。这听起来不像是一件容易的事情，但它确实是。

最重要的架构元素是使用单个对象的数组来访问存储引擎(每个存储引擎一个对象)。这些单个对象的控制是以一种叫做 handlerton 的复杂结构的形式出现的(就像在 singleton 中一样——参见关于 singletons 的侧栏)。称为 handler 的特殊类是一个基类，它使用 handlerton 来完成接口，并提供基本的连接来启用存储引擎。我将在本章后面的[图 10-1](#Fig1) 中演示这一点。

![9781430246596_Fig10-01.jpg](img/9781430246596_Fig10-01.jpg)

[图 10-1。](#_Fig1)可插拔存储引擎类派生

所有存储引擎都派生自 base-handler 类，该类充当警察，将常见的访问方法和函数调用封送到存储引擎，以及从存储引擎封送到服务器。换句话说，处理程序和 handlerton 结构充当存储引擎和服务器之间的中介(或黑盒)。只要您的存储引擎符合处理程序接口和可插拔架构，您就可以将其插入服务器。所有的连接、认证、解析和优化仍然由服务器以通常的方式执行。不同的存储引擎只是以一种通用的格式将数据传入和传出服务器，并在专用存储介质之间进行转换。

Oracle 很好地记录了创建新存储引擎的过程。在撰写本文时,《MySQL 参考手册》的第 14 章包含了对存储引擎以及处理程序接口所支持和要求的所有功能的完整解释。我建议您在阅读完本章并构建了示例存储引擎之后，再阅读 MySQL 参考手册。在这种情况下，MySQL 参考手册最好用作参考。

什么是独生子女？

在面向对象编程的某些情况下，您可能需要限制对象创建，以便对于给定的类只进行一次对象实例化。原因之一可能是该类保护一组共享的操作或数据。例如，如果有一个 manager 类被设计为访问特定资源或数据的看门人，您可能会尝试创建一个对该对象的静态或全局引用，因此在整个应用中只允许一个实例。然而，使用全局实例和常量结构或访问函数违背了面向对象的原则。您可以不这样做，而是创建一个特殊形式的对象，将创建限制为仅创建一个实例，以便它可以由应用中的所有区域(对象)共享。这些特殊的、一次性创建的对象被称为单件。(有关单件的更多信息，请参见`http://www.codeproject.com/Articles/1921/Singleton-Pattern-its-implementation-with-C`)。创建单件有多种方法:

*   静态变量
*   堆注册
*   运行时类型信息(RTTI)
*   自动注册
*   智能单件(像智能指针)

现在你知道什么是单身了，你可能在想你在整个职业生涯中一直在创造这些，但却不知道！

存储引擎开发流程

开发新存储引擎的过程可以描述为一系列阶段。毕竟，存储引擎不仅仅由几行代码组成；因此，开发这种规模和复杂性的东西的最自然的方式是通过迭代过程，在转移到另一个更复杂的部分之前，开发和测试系统的一小部分。在接下来的教程中，我将从最基本的功能开始，逐步添加功能，直到出现一个功能完整的存储引擎。

前几个阶段创建并添加基本的数据读写机制。后期阶段添加索引和事务支持。根据您要向自己的存储引擎添加的功能，您可能不需要完成所有阶段。一个正常运行的存储引擎至少应该支持前四个阶段中定义的功能。 [<sup>2</sup>](#Fn2) 这些阶段是:

1.  *停止引擎*—该过程的第一步是创建可插入服务器的基本存储引擎。创建基本的源代码文件，将存储引擎建立为处理程序基类的派生，并将存储引擎本身插入服务器源代码。
2.  *使用表格*—如果存储引擎没有创建、打开、关闭和删除文件的方法，它就不会很有趣。在此阶段，您将设置基本的文件处理例程，并确定引擎正在正确处理文件。
3.  *读写数据*—要完成最基本的存储引擎，您必须实现读写方法，以便从存储介质中读写数据。 [<sup>3</sup>](#Fn3) 这个阶段是您添加这些方法来读取存储介质格式的数据并将其转换为 MySQL 内部数据格式的阶段。同样，将数据从 MySQL 内部数据格式写到存储介质中。
4.  *更新和删除数据*—要使存储引擎能够在应用中使用，您还必须实现那些允许更改存储引擎中数据的方法。这个阶段是实现数据更新和删除的解决方案的阶段。
5.  *索引数据*—一个全功能的存储引擎还应该包括允许快速随机读取和范围查询的能力。在这一阶段，您将实现文件访问方法中第二复杂的操作—索引。我已经提供了一个索引类，可以让您更容易地自己探索这一步。
6.  *添加事务支持*—该过程的最后一个阶段是向存储引擎添加事务支持。在这个阶段，存储引擎变成了一个真正的关系数据库存储机制，适合在事务环境中使用。这是文件访问方法中最复杂的操作。

在整个过程中，您应该在每个阶段进行测试和调试。在接下来的小节中，我将向您展示调试存储引擎和编写测试来测试各个阶段的例子。所有正常的调试和跟踪机制都可以在存储引擎中使用。您还可以使用交互式调试器来查看运行中的代码！

需要源文件

您将使用的源文件通常被创建为一个单独的代码(或类)文件和一个头文件。这些文件分别被命名为`ha_<engine name>.cc`和`ha_<engine name>.h`。 [<sup>4</sup>](#Fn4) 存储引擎源代码位于主源代码树的`storage`目录下。该文件夹中是各种存储引擎的源代码文件。除了这两个文件，这就是你需要开始！

意外的帮助

MySQL 参考手册提到了几个源代码文件，它们对学习存储引擎很有帮助。事实上，我在这里所包含的大部分内容都来自于对这些资源的研究。Oracle 提供了一个示例存储引擎(名为`example`),它为在第 1 阶段创建存储引擎提供了一个很好的起点。事实上，我用它来帮助你开始学习教程。

归档引擎是第三阶段引擎的一个例子，它提供了读写数据的好例子。如果您想查看更多关于如何读取、写入和更新文件的示例，CSV 引擎是一个不错的选择。CSV 引擎是第 4 阶段引擎的一个例子(CSV 可以读写数据，也可以更新和删除数据)。CSV 引擎不同于命名约定，因为它是最先实现的引擎之一。源文件被命名为`ha_tina.cc`和`ha_tina.h`。最后，要查看 Stage 5 和 Stage 6 存储引擎的示例，请查看 MyISAM 和 InnoDB 存储引擎。

在开始创建自己的存储引擎之前，请花点时间专门研究一下这些存储引擎。因为源代码中嵌入了一些关于存储引擎应该如何工作的宝贵建议和指导。有时学习、扩展或模拟一个系统的最好方法是检查它的内部工作方式。

手柄按钮

正如我前面提到的，所有存储引擎的标准接口是 handlerton 结构。它是在`sql`目录下的`handler.cc`和`handler.h`文件中实现的，它使用许多其他结构来组织支持插件接口和抽象接口所需的所有元素。

您可能想知道在这种机制中如何确保并发性。答案是——另一种结构！每个存储引擎负责创建一个共享结构，该结构从所有线程中处理程序的每个实例引用。自然，这意味着一些代码必须受到保护。好消息是，不仅有互斥(mutex)保护方法可用，而且 handlerton 源代码已经被设计为最小化对这些保护的需求。

handlerton 结构是一个很大的结构，有许多数据项和方法。数据项被表示为它们在结构中定义的普通数据类型，但是方法是使用函数指针实现的。函数指针的使用是高级开发者用来允许运行时多态性的那些巧妙构造的机制之一。可以使用函数指针将执行重定向到不同的(但等效的接口)函数。这是 handlerton 如此成功的技术之一。

清单 10-1 是 handlerton 结构定义的简略清单，[表 10-1](#Tab1) 包括了对更重要元素的描述。

[***清单 10-1。***](#_list1)MySQL 的 Handlerton 结构

```sql
struct handlerton
{
  SHOW_COMP_OPTION state;
  enum legacy_db_type db_type;
   uint slot;
   uint savepoint_offset;
   int  (*close_connection)(handlerton *hton, THD *thd);
   int  (*savepoint_set)(handlerton *hton, THD *thd, void *sv);
   int  (*savepoint_rollback)(handlerton *hton, THD *thd, void *sv);
   int  (*savepoint_release)(handlerton *hton, THD *thd, void *sv);
   int  (*commit)(handlerton *hton, THD *thd, bool all);
   int  (*rollback)(handlerton *hton, THD *thd, bool all);
   int  (*prepare)(handlerton *hton, THD *thd, bool all);
   int  (*recover)(handlerton *hton, XID *xid_list, uint len);
   int  (*commit_by_xid)(handlerton *hton, XID *xid);
   int  (*rollback_by_xid)(handlerton *hton, XID *xid);
   void *(*create_cursor_read_view)(handlerton *hton, THD *thd);
   void (*set_cursor_read_view)(handlerton *hton, THD *thd, void *read_view);
   void (*close_cursor_read_view)(handlerton *hton, THD *thd, void *read_view);
   handler *(*create)(handlerton *hton, TABLE_SHARE *table, MEM_ROOT *mem_root);
   void (*drop_database)(handlerton *hton, char* path);
   int (*panic)(handlerton *hton, enum ha_panic_function flag);
   int (*start_consistent_snapshot)(handlerton *hton, THD *thd);
   bool (*flush_logs)(handlerton *hton);
   bool (*show_status)(handlerton *hton, THD *thd, stat_print_fn *print, enum ha_stat_type stat);
   uint (*partition_flags)();
   uint (*alter_table_flags)(uint flags);
   int (*alter_tablespace)(handlerton *hton, THD *thd, st_alter_tablespace *ts_info);
   int (*fill_is_table)(handlerton *hton, THD *thd, TABLE_LIST *tables,
                        class Item *cond,
                        enum enum_schema_tables);
   uint32 flags;                                /* global handler flags */
   int (*binlog_func)(handlerton *hton, THD *thd, enum_binlog_func fn, void *arg);
   void (*binlog_log_query)(handlerton *hton, THD *thd,
                            enum_binlog_command binlog_command,
                            const char *query, uint query_length,
                            const char *db, const char *table_name);
   int (*release_temporary_latches)(handlerton *hton, THD *thd);
   enum log_status (*get_log_status)(handlerton *hton, char *log);
   enum handler_create_iterator_result
     (*create_iterator)(handlerton *hton, enum handler_iterator_type type,
                        struct handler_iterator *fill_this_in);
   int (*discover)(handlerton *hton, THD* thd, const char *db,
                   const char *name,
                   uchar **frmblob,
                   size_t *frmlen);
   int (*find_files)(handlerton *hton, THD *thd,
                     const char *db,
                     const char *path,
                     const char *wild, bool dir, List<LEX_STRING> *files);
   int (*table_exists_in_engine)(handlerton *hton, THD* thd, const char *db,
                                 const char *name);
   int (*make_pushed_join)(handlerton *hton, THD* thd,
                           const AQP::Join_plan* plan);
  const char* (*system_database)();
  bool (*is_supported_system_table)(const char *db,
                                    const char *table_name,
                                    bool is_sql_layer_system_table);

   uint32 license; /* Flag for Engine License */
   void *data; /* Location for engines to keep personal structures */
};
```

[表 10-1](#_Tab1) 。handler ton-结构定义

| 元素 | 描述 |
| --- | --- |
| 显示 _ 组件 _ 选项状态 | 确定存储引擎是否可用。 |
| const char *comment | 描述存储引擎的注释，也由 SHOW 命令返回。 |
| 枚举传统数据库类型数据库类型 | 保存在中的枚举值。指示哪个存储引擎创建了该文件的 frm 文件。该值用于确定与表相关联的处理程序类。 |
| uint 插槽 | 处理程序数组中引用此句柄的位置。 |
| uint savepoint_offset | 为存储引擎创建保存点所需的内存大小。 |
| int (*close_connection)(。。。) | 用于关闭连接的方法。 |
| int (*savepoint_set)(。。。) | 将保存点设置为 savepoint_offset 元素中指定的保存点偏移量的方法。 |
| int (*savepoint_rollback)(。。。) | 回滚(撤消)保存点的方法。 |
| int(*savepoint_release)(。。。) | 释放(忽略)保存点的方法。 |
| int(*commit)(。。。) | 提交挂起事务的提交方法。 |
| int(*rollback)(。。。) | 回滚挂起事务的回滚方法。 |
| int(*prepare)(。。。) | 为提交准备事务准备方法。 |
| int(*recover)(。。。) | 返回正在准备的事务列表的方法。 |
| int(*commit_by_xid)(。。。) | 通过事务 ID 提交事务的方法。 |
| int(*rollback_by_xid)(。。。) | 按事务 ID 回滚事务的方法。 |
| void *(*create_cursor_read_view)() | 用于创建光标的方法。 |
| void(* set _ 游标 _read_view)(void *) | 用于切换到特定光标视图的方法。 |
| void(* close _ cursor _ read _ view)(void *) | 用于关闭特定光标视图的方法。 |
| 处理程序*(创建)(表共享*表) | 用于创建此存储引擎的处理程序实例的方法。 |
| int (*panic)(枚举 ha_panic_function 标志) | 在服务器关闭和崩溃期间调用的方法。 |
| int(*启动一致快照)(…) | 为开始一致读取(并发)而调用的方法。 |
| bool (*flush_logs)() | 用于将日志刷新到磁盘的方法。 |
| 布尔 （*show_status）（. .. | 返回存储引擎状态信息的方法。 |
| uint (*partition_flags)() | 用于返回分区标志的方法。 |
| uint (*alter_table_flags)(。。。) | 用于返回 ALTER TABLE 命令的标志集的方法。 |
| int (*alter_tablespace)()。.) | 用于返回 ALTER TABLESPACE 命令的标志集的方法。 |
| int (*fill_is_table)(。。。) | 服务器机制用来填充信息模式视图(表)的方法。 |
| uint32 标志 | 指示处理程序支持哪些功能的标志。 |
| int (*binlog_func)()。。。） | 回调二进制对数函数的方法。 |
| void (*binlog_log_query)(。。。) | 用于查询二进制日志的方法。 |
| int (*release_temporary_latches)(。。。) | InnoDB 特定用途(参见 InnoDB 引擎的文档)。 |

![image](img/sq.jpg) **注意**为了节省空间，我省略了代码中的注释。为了简洁，我还跳过了结构中不太重要的项目。有关 handlerton 结构的更多信息，请参见`handler.h`文件。

处理程序类

理解存储引擎插件接口的另一部分是`handler`类。`handler`类源自`Sql_alloc` ，这意味着所有的内存分配例程都是通过继承提供的。`handler`类被设计成存储处理程序的实现。它通过 handlerton 结构提供了一组与服务器接口的一致方法。handlerton 和 handler 实例作为一个单元工作，以实现存储引擎体系结构的抽象层。[图 10-1](#Fig1) 描述了这些类以及它们是如何被派生出来形成一个新的存储引擎的。该图将 handlerton 结构显示为处理程序和新存储引擎之间的接口。

对`handler`类的完整详细的研究超出了本书的范围。相反，我展示了实现样本存储引擎的最重要和最常用的方法。我将在本章的后面以更加叙述性的格式解释每一个实现和调用的方法。

作为对`handler`类的介绍，我提供了[清单 10-2](#list2) 中`handler`类定义的摘录。现在花点时间浏览一下课程。请注意，有许多方法可用于各种各样的任务，例如创建、删除、修改表，以及操作字段和索引的方法。甚至还有崩溃保护、恢复和备份的方法。

尽管`handler`类令人印象深刻，并且涵盖了存储引擎的所有可能情况，但是大多数存储引擎并不使用完整的方法列表。如果您想实现一个具有一些高级特性的存储引擎，请花些时间探索 MySQL 参考手册中对`handler`类的精彩介绍。一旦您习惯了创建存储引擎，您就可以使用参考手册将您的存储引擎提升到更高的水平。

[***清单 10-2。***](#_list2)Handler-class 定义

```sql
class handler :public Sql_alloc
{
...
  const handlerton *ht;                 /* storage engine of this handler */
  uchar *ref;                            /* Pointer to current row */
  uchar *dupp_ref;                       /* Pointer to dupp row */
...

  handler(const handlerton *ht_arg, TABLE_SHARE *share_arg)
    :table_share(share_arg), ht(ht_arg),
    ref(0), data_file_length(0), max_data_file_length(0), index_file_length(0),
    delete_length(0), auto_increment_value(0),
    records(0), deleted(0), mean_rec_length(0),
    create_time(0), check_time(0), update_time(0),
    key_used_on_scan(MAX_KEY), active_index(MAX_KEY),
    ref_length(sizeof(my_off_t)), block_size(0),
    ft_handler(0), inited(NONE), implicit_emptied(0),
    pushed_cond(NULL)
    {}
...
  int ha_index_init(uint idx, bool sorted)
...
  int ha_index_end()
...
  int ha_rnd_init(bool scan)
...
  int ha_rnd_end()
...
  int ha_reset()
...
...
  virtual int exec_bulk_update(uint *dup_key_found)
...
  virtual void end_bulk_update() { return; }
...
  virtual int end_bulk_delete()
...
  virtual int index_read(uchar * buf, const uchar * key,
       uint key_len, enum ha_rkey_function find_flag)
...
  virtual int index_read_idx(uchar * buf, uint index, const uchar * key,
           uint key_len, enum ha_rkey_function find_flag);
  virtual int index_next(uchar * buf)
   { return  HA_ERR_WRONG_COMMAND; }
  virtual int index_prev(uchar * buf)
   { return  HA_ERR_WRONG_COMMAND; }
  virtual int index_first(uchar * buf)
   { return  HA_ERR_WRONG_COMMAND; }
  virtual int index_last(uchar * buf)
   { return  HA_ERR_WRONG_COMMAND; }
  virtual int index_next_same(uchar *buf, const uchar *key, uint keylen);
  virtual int index_read_last(uchar * buf, const uchar * key, uint key_len)
...

virtual int read_range_first(const key_range *start_key,
                               const key_range *end_key,
                               bool eq_range, bool sorted);
  virtual int read_range_next();
  int compare_key(key_range *range);
  virtual int ft_init() { return HA_ERR_WRONG_COMMAND; }
  void ft_end() { ft_handler=NULL; }
  virtual FT_INFO *ft_init_ext(uint flags, uint inx,String *key)
    { return NULL; }
  virtual int ft_read(uchar *buf) { return HA_ERR_WRONG_COMMAND; }
  virtual int rnd_next(uchar *buf)=0;
  virtual int rnd_pos(uchar * buf, uchar *pos)=0;
  virtual int read_first_row(uchar *buf, uint primary_key);
...
  virtual int restart_rnd_next(uchar *buf, uchar *pos)
    { return HA_ERR_WRONG_COMMAND; }
  virtual int rnd_same(uchar *buf, uint inx)
    { return HA_ERR_WRONG_COMMAND; }
  virtual ha_rows records_in_range(uint inx, key_range *min_key,
                                   key_range *max_key);
    { return (ha_rows) 10; }
  virtual void position(const uchar *record)=0;
  virtual void info(uint)=0; // see my_base.h for full description
  virtual void get_dynamic_partition_info(PARTITION_INFO *stat_info,
                                          uint part_id);
  virtual int extra(enum ha_extra_function operation)
  { return 0; }
  virtual int extra_opt(enum ha_extra_function operation, ulong cache_size)
  { return extra(operation); }
...
  virtual int delete_all_rows()
...
  virtual ulonglong get_auto_increment();
  virtual void restore_auto_increment();
...
  virtual int reset_auto_increment(ulonglong value)
...
  virtual void update_create_info(HA_CREATE_INFO *create_info) {}
...
  int ha_repair(THD* thd, HA_CHECK_OPT* check_opt);
...
  virtual bool check_and_repair(THD *thd) { return TRUE; }
  virtual int dump(THD* thd, int fd = −1) { return HA_ERR_WRONG_COMMAND; }
  virtual int disable_indexes(uint mode) { return HA_ERR_WRONG_COMMAND; }
  virtual int enable_indexes(uint mode) { return HA_ERR_WRONG_COMMAND; }
  virtual int indexes_are_disabled(void) {return 0;}
  virtual void start_bulk_insert(ha_rows rows) {}
  virtual int end_bulk_insert() {return 0; }
  virtual int discard_or_import_tablespace(my_bool discard)
...
  virtual uint referenced_by_foreign_key() { return 0;}
  virtual void init_table_handle_for_HANDLER()
...
  virtual void free_foreign_key_create_info(char* str) {}
...
  virtual const char *table_type() const =0;
  virtual const char **bas_ext() const =0;
...
  virtual uint max_supported_record_length() const { return HA_MAX_REC_LENGTH; }
  virtual uint max_supported_keys() const { return 0; }
  virtual uint max_supported_key_parts() const { return MAX_REF_PARTS; }
  virtual uint max_supported_key_length() const { return MAX_KEY_LENGTH; }
  virtual uint max_supported_key_part_length() const { return 255; }
  virtual uint min_record_length(uint options) const { return 1; }
...
  virtual bool is_crashed() const  { return 0; }
...
  virtual int rename_table(const char *from, const char *to);
  virtual int delete_table(const char *name);
  virtual void drop_table(const char *name);

  virtual int create(const char *name, TABLE *form, HA_CREATE_INFO *info)=0;
...
  virtual int external_lock(THD *thd __attribute__((unused)),
                            int lock_type __attribute__((unused)))
...
  virtual int write_row(uchar *buf __attribute__((unused)))
...
  virtual int update_row(const uchar *old_data __attribute__((unused)),
                         uchar *new_data __attribute__((unused)))
...
  virtual int delete_row(const uchar *buf __attribute__((unused)))
...
};
```

MySQL 存储引擎简介

观看处理程序工作的最佳方式是观看它的运行。因此，在我们开始构建一个存储引擎之前，让我们检查一个正在使用的真实存储引擎。如果您还没有编译您的服务器，请继续使用 debug 进行编译。继续启动您的服务器和调试器，然后将您的调试工具连接到正在运行的服务器，如第 5 章中的[所述。](05.html)

我想向您展示一个运行中的简单存储引擎。在这种情况下，我使用归档存储引擎。在调试器打开且服务器运行的情况下，打开`ha_archive.cc`文件，并在方法的第一个可执行行上放置一个断点:

```sql
int ha_archive::create(...)
static ARCHIVE_SHARE *ha_archive::get_share(...)
int ha_archive::write_row(...)int ha_tina::rnd_next(...)
int ha_archive::rnd_next(...)
```

一旦设置了断点，启动命令行 MySQL 客户端，切换到测试数据库，并发出以下命令:

```sql
CREATE TABLE testarc (a int, b varchar(20), c int) ENGINE=ARCHIVE;
```

您应该立即看到在`create()`方法中调试器停止。这个方法是创建基本数据表的地方。事实上，这是首先要执行的事情之一。调用`my_create()`方法来创建文件。注意，代码正在寻找一个设置了(在方法的顶部)的`AUTO_INCREMENT_FLAG`字段；如果找到该字段，代码将设置一个错误并退出。这是因为归档存储引擎不支持自动递增字段。您还可以看到，该方法正在创建一个元文件，并检查压缩例程是否正常工作。

单步执行代码并观察迭代器。您可以在任何时候继续执行，或者，如果您真的很好奇，继续一步一步地返回到调用函数。

现在，让我们看看当我们插入数据时会发生什么。回到您的 MySQL 客户端，输入以下命令:

```sql
INSERT INTO testarc VALUES (10, "test", -1);
```

这一次，代码在`get_share()`方法中停止。此方法负责创建共享结构(存储为。frm 文件)用于存档处理程序的所有实例。当您逐步执行此方法时，您可以看到代码在何处设置全局变量和其他初始化类型的任务。继续，让调试器继续执行。

代码下一个停止的地方是在`write_row()`方法中。这个方法是将通过`buf`参数传递的数据写入磁盘的地方。记录缓冲区`(uchar *buf)`是 MySQL 用来在系统中传递行的机制。它是一个包含行数据和其他元数据的二进制缓冲区。这就是 MySQL 文档中提到的“内部格式”当您一步一步地阅读这段代码时，您会看到引擎设置了一些统计数据，做了一些错误检查，并最终使用方法末尾的方法`real_write_row()`写入数据。继续并逐步完成该方法。

在`real_write_row()`方法中，可以看到另一个字段迭代器。这个迭代器遍历二进制大对象(BLOB)字段，并使用压缩方法将它们写入磁盘。如果您需要支持 BLOB 字段，这是一个很好的例子——只需用低级 IO 调用代替压缩方法。继续，让代码继续；然后返回 MySQL 客户端，输入命令:

```sql
SELECT * FROM testarc;
```

代码下一个停止的地方是在`rnd_next()`方法中。这是处理程序读取数据文件并将数据返回到记录缓冲区`(uchar *buf)`的地方。再次注意，代码设置了一些统计数据，进行错误检查，然后使用`get_row()`方法读取数据。单步执行这段代码，然后让它继续。

真是个惊喜！代码在`rnd_next()`方法处再次停止。这是因为`rnd_next()`方法是对表扫描的一系列调用之一。该方法不仅负责读取数据，还负责检测文件的结尾。因此，在您正在处理的示例中，应该有对该方法的两次调用。第一个检索第一行数据，第二个检测文件的结尾(您只插入了一行)。下面列出了表格扫描的典型调用序列,使用了您一直在研究的例子:

```sql
ha_spartan::info
ha_spartan::rnd_init
ha_spartan::extra
ha_spartan::rnd_next
ha_spartan::rnd_next
ha_spartan::extra

+−−----+−−----+−−----+
| a    | b    | c    |
+−−----+−−----+−−----+
| 10   | test | -1   |
+−−----+−−----+−−----+
1 row in set (26.25 sec)
```

![image](img/sq.jpg) **注意**查询返回的时间是服务器记录的实际运行时间，而不是执行时间。因此，花费在调试上的时间也很重要。

花些时间在你可能感兴趣的其他方法上设置断点。您还可以花一些时间阅读这个存储引擎中的注释，因为它们为如何使用一些处理程序方法提供了很好的线索。

斯巴达存储引擎

我为存储引擎教程选择了基本存储引擎的概念，它具有普通存储引擎的所有特性。这包括在索引支持下读写数据。也就是说是 5 级发动机。我将这个示例存储引擎称为 Spartan 存储引擎，因为在许多方面，它只实现了可行的数据库存储机制的基本需求。

我将指导您使用示例(`ha_example` ) MySQL 存储引擎构建 Spartan 存储的过程。在本教程中，我建议您参考其他存储引擎来了解更多信息。虽然你可能会发现你认为可以改进的地方(确实有几个)，但在你成功实现第五阶段之前，不要对 Spartan 引擎进行任何改进。

让我们从检查 Spartan 存储引擎的支持类文件开始。

低级输入/输出类

存储引擎旨在使用一种专门的机制来读写数据，这种机制为用户提供了一些独特的好处。这意味着存储引擎本质上不支持相同的功能。

大多数存储引擎要么使用其他源文件中定义的 C 函数，要么使用类头文件和源文件中定义的 C++类。对于 Spartan 引擎，我选择使用后一种方法。我创建了一个数据文件类和一个索引文件类。忠于本章和 Spartan-engine 项目的意图，这两个类都没有针对性能进行优化。相反，它们提供了一种创建工作存储引擎的方法，并演示了创建自己的存储引擎需要做的大部分事情。

本节在概述中描述了每个类。您可以跟随代码，看看这些类是如何工作的。尽管低级类只是基础，可能需要一些微调，但我认为您会发现这些类非常有用，甚至可能会将它们作为您自己的存储引擎 I/O 的基础。

斯巴达 _ 数据类

Spartan 存储引擎的主要低级 I/O 类是`Spartan_data`类。这个类负责封装 Spartan 存储引擎的数据。清单 10-3 包含了这个类的完整头文件。正如您在标题中看到的，这个类的方法非常简单。我只实现了基本的打开、关闭、读取和写入操作。

[***清单 10-3。***](#_list3) 斯巴达 _ 数据类头

```sql
/*
  Spartan_data.h

  This header defines a simple data file class for writing and reading raw
  data to and from disk. The data written is in uchar format so it can be
  anything you want it to be. The write_row and read_row accept the
  length of the data item to be written/read.
*/
#include "my_global.h"
#include "my_sys.h"

class Spartan_data
{
public:
  Spartan_data(void);
  ∼Spartan_data(void);
  int create_table(char *path);
  int open_table(char *path);
  long long write_row(uchar *buf, int length);
  long long update_row(uchar *old_rec, uchar *new_rec,
                       int length, long long position);
  int read_row(uchar *buf, int length, long long position);
  int delete_row(uchar *old_rec, int length, long long position);
  int close_table();
  long long cur_position();
  int records();
  int del_records();
  int trunc_table();
  int row_size(int length);
private:
  File data_file;
  int header_size;
  int record_header_size;
  bool crashed;
  int number_records;
  int number_del_records;
  int read_header();
  int write_header();
};
```

清单 10-4 包含了 Spartan 存储引擎数据类的完整源代码。请注意，在代码中，我包含了适当的`DBUG`调用，以确保我的源代码可以写入跟踪文件，如果我希望使用`--with-debug`开关调试系统的话。还要注意，使用的读写方法是 Oracle 提供的`my_xxx`平台安全实用方法。

[***清单 10-4。***](#_list4) 斯巴达 _ 数据类源代码

```sql
/*
  Spartan_data.cc

  This class implements a simple data file reader/writer. It
  is designed to allow the caller to specify the size of the
  data to read or write. This allows for variable length records
  and the inclusion of extra fields (like blobs). The data are
  stored in an uncompressed, unoptimized fashion.
*/
#include "spartan_data.h"
#include <my_dir.h>
#include <string.h>

Spartan_data::Spartan_data(void)
{
  data_file = −1;
  number_records = −1;
  number_del_records = −1;
  header_size = sizeof(bool) + sizeof(int) + sizeof(int);
  record_header_size = sizeof(uchar) + sizeof(int);
}

Spartan_data::∼Spartan_data(void)
{
}

/* create the data file */
int Spartan_data::create_table(char *path)
{
  DBUG_ENTER("SpartanIndex::create_table");
  open_table(path);
  number_records = 0;
  number_del_records = 0;
  crashed = false;
  write_header();
  DBUG_RETURN(0);
}

/* open table at location "path" = path + filename */
int Spartan_data::open_table(char *path)
{
  DBUG_ENTER("Spartan_data::open_table");
  /*
    Open the file with read/write mode,
    create the file if not found,
    treat file as binary, and use default flags.
  */
  data_file = my_open(path, O_RDWR | O_CREAT | O_BINARY | O_SHARE, MYF(0));
  if(data_file == −1)
    DBUG_RETURN(errno);
  read_header();
  DBUG_RETURN(0);
}

/* write a row of length uchars to file and return position */
long long Spartan_data::write_row(uchar *buf, int length)
{
  long long pos;
  int i;
  int len;
  uchar deleted = 0;

  DBUG_ENTER("Spartan_data::write_row");
  /*
    Write the deleted status uchar and the length of the record.
    Note: my_write() returns the uchars written or −1 on error
  */
  pos = my_seek(data_file, 0L, MY_SEEK_END, MYF(0));
  /*
    Note: my_malloc takes a size of memory to be allocated,
    MySQL flags (set to zero fill and with extra error checking).
    Returns number of uchars allocated -- <= 0 indicates an error.
  */
  i = my_write(data_file, &deleted, sizeof(uchar), MYF(0));
  memcpy(&len, &length, sizeof(int));
  i = my_write(data_file, (uchar *)&len, sizeof(int), MYF(0));
  /*
    Write the row data to the file. Return new file pointer or
    return −1 if error from my_write().
  */
  i = my_write(data_file, buf, length, MYF(0));
  if (i == −1)
    pos = i;
  else
    number_records++;
  DBUG_RETURN(pos);
}

/* update a record in place */
long long Spartan_data::update_row(uchar *old_rec, uchar *new_rec,
                                   int length, long long position)
{
  long long pos;
  long long cur_pos;
  uchar *cmp_rec;
  int len;
  uchar deleted = 0;
  int i = −1;

  DBUG_ENTER("Spartan_data::update_row");
  if (position == 0)
    position = header_size; //move past header
  pos = position;
  /*
    If position unknown, scan for the record by reading a row
    at a time until found.
  */
  if (position == −1) //don't know where it is...scan for it
  {
    cmp_rec = (uchar *)my_malloc(length, MYF(MY_ZEROFILL | MY_WME));
    pos = 0;
    /*
      Note: my_seek() returns pos if no errors or −1 if error.
    */
    cur_pos = my_seek(data_file, header_size, MY_SEEK_SET, MYF(0));
    /*
      Note: read_row() returns current file pointer if no error or
      -1 if error.
    */
    while ((cur_pos != −1) && (pos != −1))
    {
      pos = read_row(cmp_rec, length, cur_pos);
      if (memcmp(old_rec, cmp_rec, length) == 0)
      {
        pos = cur_pos;      //found it!
        cur_pos = −1;       //stop loop gracefully
      }
      else if (pos != −1)   //move ahead to next rec
        cur_pos = cur_pos + length + record_header_size;
    }
    my_free(cmp_rec);
  }
  /*
    If position found or provided, write the row.
  */
  if (pos != −1)
  {
    /*
      Write the deleted uchar, the length of the row, and the data
      at the current file pointer.
      Note: my_write() returns the uchars written or −1 on error
    */
    my_seek(data_file, pos, MY_SEEK_SET, MYF(0));
    i = my_write(data_file, &deleted, sizeof(uchar), MYF(0));
    memcpy(&len, &length, sizeof(int));
    i = my_write(data_file, (uchar *)&len, sizeof(int), MYF(0));
    pos = i;
    i = my_write(data_file, new_rec, length, MYF(0));
  }
  DBUG_RETURN(pos);
}

/* delete a record in place */
int Spartan_data::delete_row(uchar *old_rec, int length,
                             long long position)
{
  int i = −1;
  long long pos;
  long long cur_pos;
  uchar *cmp_rec;
  uchar deleted = 1;

  DBUG_ENTER("Spartan_data::delete_row");
  if (position == 0)
    position = header_size; //move past header
  pos = position;
  /*
    If position unknown, scan for the record by reading a row
    at a time until found.
  */
  if (position == −1) //don't know where it is...scan for it
  {
    cmp_rec = (uchar *)my_malloc(length, MYF(MY_ZEROFILL | MY_WME));
    pos = 0;
    /*
      Note: my_seek() returns pos if no errors or −1 if error.
    */
    cur_pos = my_seek(data_file, header_size, MY_SEEK_SET, MYF(0));
    /*
      Note: read_row() returns current file pointer if no error or
      -1 if error.
    */
    while ((cur_pos != −1) && (pos != −1))
    {
      pos = read_row(cmp_rec, length, cur_pos);
      if (memcmp(old_rec, cmp_rec, length) == 0)
      {
        number_records--;
        number_del_records++;
        pos = cur_pos;
        cur_pos = −1;
      }
      else if (pos != −1)   //move ahead to next rec
        cur_pos = cur_pos + length + record_header_size;
    }
    my_free(cmp_rec);
  }
  /*
    If position found or provided, write the row.
  */
  if (pos != −1)            //mark as deleted
  {
    /*
      Write the deleted uchar set to 1 which marks row as deleted
      at the current file pointer.
      Note: my_write() returns the uchars written or −1 on error
    */
    pos = my_seek(data_file, pos, MY_SEEK_SET, MYF(0));
    i = my_write(data_file, &deleted, sizeof(uchar), MYF(0));
    i = (i > 1) ? 0 : i;
  }
  DBUG_RETURN(i);
}

/* read a row of length uchars from file at position */
int Spartan_data::read_row(uchar *buf, int length, long long position)
{
  int i;
  int rec_len;
  long long pos;
  uchar deleted = 2;

  DBUG_ENTER("Spartan_data::read_row");
  if (position <= 0)
    position = header_size; //move past header
  pos = my_seek(data_file, position, MY_SEEK_SET, MYF(0));
  /*
    If my_seek found the position, read the deleted uchar.
    Note: my_read() returns uchars read or −1 on error
  */
  if (pos != −1L)
  {
    i = my_read(data_file, &deleted, sizeof(uchar), MYF(0));
    /*
      If not deleted (deleted == 0), read the record length then
      read the row.
    */
    if (deleted == 0) /* 0 = not deleted, 1 = deleted */
    {
      i = my_read(data_file, (uchar *)&rec_len, sizeof(int), MYF(0));
      i = my_read(data_file, buf,
                 (length < rec_len) ? length : rec_len, MYF(0));
    }
    else if (i == 0)
      DBUG_RETURN(−1);
    else
      DBUG_RETURN(read_row(buf, length, cur_position() +
                           length + (record_header_size - sizeof(uchar))));
  }
  else
    DBUG_RETURN(−1);
  DBUG_RETURN(0);
}

/* close file */
int Spartan_data::close_table()
{
  DBUG_ENTER("Spartan_data::close_table");
  if (data_file != −1)
  {
    my_close(data_file, MYF(0));
    data_file = −1;
  }
  DBUG_RETURN(0);
}

/* return number of records */
int Spartan_data::records()
{
  DBUG_ENTER("Spartan_data::num_records");
  DBUG_RETURN(number_records);
}

/* return number of deleted records */
int Spartan_data::del_records()
{
  DBUG_ENTER("Spartan_data::num_records");
  DBUG_RETURN(number_del_records);
}

/* read header from file */
int Spartan_data::read_header()
{
  int i;
  int len;

  DBUG_ENTER("Spartan_data::read_header");
  if (number_records == −1)
  {
    my_seek(data_file, 0l, MY_SEEK_SET, MYF(0));
    i = my_read(data_file, (uchar *)&crashed, sizeof(bool), MYF(0));
    i = my_read(data_file, (uchar *)&len, sizeof(int), MYF(0));
    memcpy(&number_records, &len, sizeof(int));
    i = my_read(data_file, (uchar *)&len, sizeof(int), MYF(0));
    memcpy(&number_del_records, &len, sizeof(int));
  }
  else
    my_seek(data_file, header_size, MY_SEEK_SET, MYF(0));
  DBUG_RETURN(0);
}

/* write header to file */
int Spartan_data::write_header()
{
  DBUG_ENTER("Spartan_data::write_header");
  if (number_records != −1)
  {
    my_seek(data_file, 0l, MY_SEEK_SET, MYF(0));
    i = my_write(data_file, (uchar *)&crashed, sizeof(bool), MYF(0));
    i = my_write(data_file, (uchar *)&number_records, sizeof(int), MYF(0));
    i = my_write(data_file, (uchar *)&number_del_records, sizeof(int), MYF(0));
  }
  DBUG_RETURN(0);
}

/* get position of the data file */
long long Spartan_data::cur_position()
{
  long long pos;

  DBUG_ENTER("Spartan_data::cur_position");
  pos = my_seek(data_file, 0L, MY_SEEK_CUR, MYF(0));
  if (pos == 0)
    DBUG_RETURN(header_size);
  DBUG_RETURN(pos);
}

/* truncate the data file */
int Spartan_data::trunc_table()
{
  DBUG_ENTER("Spartan_data::trunc_table");
  if (data_file != −1 )
  {
    my_chsize(data_file, 0, 0, MYF(MY_WME));
    write_header();
  }
  DBUG_RETURN(0);
}

/* determine the row size of the data file */
int Spartan_data::row_size(int length)
{
  DBUG_ENTER("Spartan_data::row_size");
  DBUG_RETURN(length + record_header_size);
}
```

注意用于存储数据的格式。该类旨在支持从磁盘读取数据以及将内存中的数据写入磁盘。我使用 uchar 指针分配一块内存来存储这些行。这非常有用，因为它提供了使用内部 MySQL 行格式将表中的行写入磁盘的能力。同样，我可以从磁盘读取数据，将它们写入内存缓冲区，并简单地将`handler`类指向要返回给优化器的内存块。

但是，我可能无法预测存储一行所需的确切内存量。存储引擎的一些用途可能是拥有可变字段或者甚至二进制大对象(blob)的表。为了解决这个问题，我选择在每行的开头存储一个整数长度的字段。这允许我通过首先读取 length 字段，然后读取内存缓冲区中指定的 uchars 数量来扫描文件和读取可变长度的行。

![image](img/sq.jpg) **提示**每当为 MySQL 服务器编写扩展时，总是使用`my_xxx`实用程序方法。`my_xxx`实用方法是许多基本操作系统功能的封装，提供了更好的跨平台支持。

数据类相当简单，可用于实现存储引擎所需的基本读写操作。但是，我想让存储引擎更加高效。为了让我的数据文件获得良好的性能，我需要添加一个索引机制。这就是事情变得更加复杂的地方。

![image](img/sq.jpg) **注意**虽然我们不会在前四个阶段使用 index 类，但提前理解这段代码是有好处的。

斯巴达 _ 索引类

为了解决索引数据文件的问题，我实现了一个名为`Spartan_index`的独立索引类。index 类负责允许执行点查询(通过特定记录的索引进行查询)和范围查询(一系列升序或降序的键)，以及缓存索引以进行快速搜索的能力。[清单 10-5](#list5) 包含了`Spartan_index`类的完整头文件。

[***清单 10-5。***](#_list5) 斯巴达 _ 索引类表头

```sql
/*
  Spartan_index.h

  This header file defines a simple index class that can
  be used to store file pointer indexes (long long). The
  class keeps the entire index in memory for fast access.
  The internal-memory structure is a linked list. While
  not as efficient as a btree, it should be usable for
  most testing environments. The constructor accepts the
  max key length. This is used for all nodes in the index.

  File Layout:
    SOF                              max_key_len (int)
    SOF + sizeof(int)                crashed (bool)
    SOF + sizeof(int) + sizeof(bool) DATA BEGINS HERE
*/
#include "my_global.h"
#include "my_sys.h"

const long METADATA_SIZE = sizeof(int) + sizeof(bool);
/*
  This is the node that stores the key and the file
  position for the data row.
*/
struct SDE_INDEX
{
  uchar key[128];
  long long pos;
  int length;
};

/* defines (doubly) linked list for internal list */
struct SDE_NDX_NODE
{
  SDE_INDEX key_ndx;
  SDE_NDX_NODE *next;
  SDE_NDX_NODE *prev;
};

class Spartan_index
{
public:
  Spartan_index(int keylen);
  Spartan_index();
  ∼Spartan_index(void);
  int open_index(char *path);
  int create_index(char *path, int keylen);
  int insert_key(SDE_INDEX *ndx, bool allow_dupes);
  int delete_key(uchar *buf, long long pos, int key_len);
  int update_key(uchar *buf, long long pos, int key_len);
  long long get_index_pos(uchar *buf, int key_len);
  long long get_first_pos();
  uchar *get_first_key();
  uchar *get_last_key();
  uchar *get_next_key();
  uchar *get_prev_key();
  int close_index();
  int load_index();
  int destroy_index();
  SDE_INDEX *seek_index(uchar *key, int key_len);
  SDE_NDX_NODE *seek_index_pos(uchar *key, int key_len);
  int save_index();
  int trunc_index();
private:
  File index_file;
  int max_key_len;
  SDE_NDX_NODE *root;
  SDE_NDX_NODE *range_ptr;
  int block_size;
  bool crashed;
  int read_header();
  int write_header();
  long long write_row(SDE_INDEX *ndx);
  SDE_INDEX *read_row(long long Position);
  long long curfpos();
};
```

请注意，该类实现了创建、打开、关闭、读取和写入方法的预期形式。`load_index()`方法将整个索引文件读入内存，将索引存储为双向链表。所有的索引扫描和引用方法都是访问内存中的链表，而不是访问磁盘。这节省了大量时间，并提供了一种将整个索引保存在内存中以便快速插入和删除的方法。一个相应的方法`save_index()` ，允许你将索引从内存写回磁盘。这些方法的使用方式应该是在表打开时调用`load_index()`，然后在表关闭时调用`save_index()`。

您可能想知道这种方法是否有大小限制。根据索引的大小、创建的索引数量以及条目数量，这种实现可能会有一些限制。然而，对于本教程和 Spartan 存储引擎的可预见使用来说，这不是问题。

您可能关心的另一个领域是双向链表的使用。这种实现不太可能成为高速索引存储的首选。您更可能使用 B 树或 B 树的某种变体来创建有效的索引访问方法。然而，链表很容易使用，它使得大量源代码的实现更容易管理。这个例子演示了如何将一个索引类合并到您的引擎中——而不是如何编码一个 B 树结构。这使得代码更简单，因为链表更容易编码。出于本教程的目的，链表结构将表现得非常好。事实上，您甚至可能想用它来组成自己的存储引擎，直到您让存储引擎的其余部分工作起来，然后将注意力转向更好的索引类。

清单 10-6 展示了`Spartan_index`类实现的完整源代码。代码相当长，所以要么花点时间研究这些方法，要么把代码留到以后阅读，直接跳到如何开始构建 Spartan 存储引擎的描述。

[***清单 10-6。***](#_list6) 斯巴达 _index 类源代码

```sql
/*
  Spartan_index.cc

  This class reads and writes an index file for use with the Spartan data
  class. The file format is a simple binary storage of the
  Spartan_index::SDE_INDEX structure. The size of the key can be set via
  the constructor.
*/
#include "spartan_index.h"
#include <my_dir.h>
#include <string.h>

/* constuctor takes the maximum key length for the keys */
Spartan_index::Spartan_index(int keylen)
{
  root = NULL;
  crashed = false;
  max_key_len = keylen;
  index_file = −1;
  block_size = max_key_len + sizeof(long long) + sizeof(int);
}

/* constuctor (overloaded) assumes existing file */
Spartan_index::Spartan_index()
{
  root = NULL;
  crashed = false;
  max_key_len = −1;
  index_file = −1;
  block_size = −1;
}

/* destructor */
Spartan_index::∼Spartan_index(void)
{
}

/* create the index file */
int Spartan_index::create_index(char *path, int keylen)
{
  DBUG_ENTER("Spartan_index::create_index");
  DBUG_PRINT("info", ("path: %s", path));
  open_index(path);
  max_key_len = keylen;
  /*
    Block size is the key length plus the size of the index
    length variable.
  */
  block_size = max_key_len + sizeof(long long);
  write_header();
DBUG_RETURN(0);
 }

/* open index specified as path (pat+filename) */
int Spartan_index::open_index(char *path)
{
  DBUG_ENTER("Spartan_index::open_index");
  /*
    Open the file with read/write mode,
    create the file if not found,
    treat file as binary, and use default flags.
  */
  index_file = my_open(path, O_RDWR | O_CREAT | O_BINARY | O_SHARE, MYF(0));
  if(index_file == −1)
    DBUG_RETURN(errno);
  read_header();
  DBUG_RETURN(0);
}

/* read header from file */
int Spartan_index::read_header()
{
  DBUG_ENTER("Spartan_index::read_header");
  if (block_size == −1)
  {
    /*
      Seek the start of the file.
      Read the maximum key length value.
    */
    my_seek(index_file, 0l, MY_SEEK_SET, MYF(0));
    i = my_read(index_file, (uchar *)&max_key_len, sizeof(int), MYF(0));
    /*
      Calculate block size as maximum key length plus
      the size of the key plus the crashed status byte.
    */
    block_size = max_key_len + sizeof(long long) + sizeof(int);
    i = my_read(index_file, (uchar *)&crashed, sizeof(bool), MYF(0));
  }
  else
  {
    i = (int)my_seek(index_file, sizeof(int) + sizeof(bool), MY_SEEK_SET, MYF(0));
  }
  DBUG_RETURN(0);
}

/* write header to file */
int Spartan_index::write_header()
{
  int i;

  DBUG_ENTER("Spartan_index::write_header");
  if (block_size != −1)
  {
    /*
      Seek the start of the file and write the maximum key length
      then write the crashed status byte.
    */
    my_seek(index_file, 0l, MY_SEEK_SET, MYF(0));
    i = my_write(index_file, (uchar *)&max_key_len, sizeof(int), MYF(0));
    i = my_write(index_file, (uchar *)&crashed, sizeof(bool), MYF(0));
  }
  DBUG_RETURN(0);
}

/* write a row (SDE_INDEX struct) to the index file */
long long Spartan_index::write_row(SDE_INDEX *ndx)
{
  long long pos;
  int i;
  int len;

  DBUG_ENTER("Spartan_index::write_row");
  /*
     Seek the end of the file (always append)
  */
  pos = my_seek(index_file, 0l, MY_SEEK_END, MYF(0));
  /*
    Write the key value.
  */
  i = my_write(index_file, ndx->key, max_key_len, MYF(0));
  memcpy(&pos, &ndx->pos, sizeof(long long));
  /*
    Write the file position for the key value.
  */
  i = i + my_write(index_file, (uchar *)&pos, sizeof(long long), MYF(0));
  memcpy(&len, &ndx->length, sizeof(int));
  /*
    Write the length of the key.
  */
  i = i + my_write(index_file, (uchar *)&len, sizeof(int), MYF(0));
  if (i == −1)
    pos = i;
  DBUG_RETURN(pos);
}

/* read a row (SDE_INDEX struct) from the index file */
SDE_INDEX *Spartan_index::read_row(long long Position)
{
  int i;
  long long pos;
  SDE_INDEX *ndx = NULL;

  DBUG_ENTER("Spartan_index::read_row");
  /*
    Seek the position in the file (Position).
  */
  pos = my_seek(index_file,(ulong) Position, MY_SEEK_SET, MYF(0));
  if (pos != −1L)
  {
    ndx = new SDE_INDEX();
    /*
      Read the key value.
    */
    i = my_read(index_file, ndx->key, max_key_len, MYF(0));
    /*
      Read the key value. If error, return NULL.
    */
    i = my_read(index_file, (uchar *)&ndx->pos, sizeof(long long), MYF(0));
    if (i == −1)
    {
        delete ndx;
        ndx = NULL;
    }
  }
  DBUG_RETURN(ndx);
}

/* insert a key into the index in memory */
int Spartan_index::insert_key(SDE_INDEX *ndx, bool allow_dupes)
{
  SDE_NDX_NODE *p = NULL;
  SDE_NDX_NODE *n = NULL;
  SDE_NDX_NODE *o = NULL;
  int i = −1;
  int icmp;
  bool dupe = false;
  bool done = false;

  DBUG_ENTER("Spartan_index::insert_key");
  /*
    If this is a new index, insert first key as the root node.
  */
  if (root == NULL)
  {
    root = new SDE_NDX_NODE();
    root->next = NULL;
    root->prev = NULL;
    memcpy(root->key_ndx.key, ndx->key, max_key_len);
    root->key_ndx.pos = ndx->pos;
    root->key_ndx.length = ndx->length;
  }
  else //set pointer to root
    p = root;
  /*
    Loop through the linked list until a value greater than the
    key to be inserted, then insert new key before that one.
  */
  while ((p != NULL) && !done)
  {
    icmp = memcmp(ndx->key, p->key_ndx.key,
                 (ndx->length > p->key_ndx.length) ?
                  ndx->length : p->key_ndx.length);
    if (icmp > 0) // key is greater than current key in list
    {
      n = p;
      p = p->next;
    }
    /*
      If dupes not allowed, stop and return NULL
    */
    else if (!allow_dupes && (icmp == 0))
    {
      p = NULL;
      dupe = true;
    }
    else
    {
      n = p->prev; //stop, insert at n->prev
      done = true;
    }
  }
  /*
    If position found (n != NULL) and dupes permitted,
    insert key. If p is NULL insert at end else insert in middle
    of list.
  */
  if ((n != NULL) && !dupe)
  {
    if (p == NULL) //insert at end
    {
      p = new SDE_NDX_NODE();
      n->next = p;
      p->prev = n;
      memcpy(p->key_ndx.key, ndx->key, max_key_len);
      p->key_ndx.pos = ndx->pos;
      p->key_ndx.length = ndx->length;
    }
    else
    {
      o = new SDE_NDX_NODE();
      memcpy(o->key_ndx.key, ndx->key, max_key_len);
      o->key_ndx.pos = ndx->pos;
      o->key_ndx.length = ndx->length;
      o->next = p;
      o->prev = n;
      n->next = o;
      p->prev = o;
    }
    i = 1;
  }
  DBUG_RETURN(i);
}

/* delete a key from the index in memory. Note:
   position is included for indexes that allow dupes */
int Spartan_index::delete_key(uchar *buf, long long pos, int key_len)
{
  SDE_NDX_NODE *p;
  int icmp;
  int buf_len;
  bool done = false;

  DBUG_ENTER("Spartan_index::delete_key");
  p = root;
  /*
    Search for the key in the list. If found, delete it!
  */
  while ((p != NULL) && !done)
  {
    buf_len = p->key_ndx.length;
    icmp = memcmp(buf, p->key_ndx.key,
                 (buf_len > key_len) ? buf_len : key_len);
    if (icmp == 0)
    {
      if (pos != −1)
      {
        if (pos == p->key_ndx.pos)
          done = true;
      }
      else
        done = true;
    }
    else
      p = p->next;
  }
  if (p != NULL)
  {
    /*
      Reset pointers for deleted node in list.
    */
    if (p->next != NULL)
      p->next->prev = p->prev;
    if (p->prev != NULL)
      p->prev->next = p->next;
    else
      root = p->next;
    delete p;
  }
  DBUG_RETURN(0);
}

/* update key in place (so if key changes!) */
int Spartan_index::update_key(uchar *buf, long long pos, int key_len)
{
  SDE_NDX_NODE *p;
  bool done = false;

  DBUG_ENTER("Spartan_index::update_key");
  p = root;
  /*
    Search for the key.
  */
  while ((p != NULL) && !done)
  {
    if (p->key_ndx.pos == pos)
      done = true;
    else
      p = p->next;
  }
  /*
    If key found, overwrite key value in node.
  */
  if (p != NULL)
  {
    memcpy(p->key_ndx.key, buf, key_len);
  }
  DBUG_RETURN(0);
}

/* get the current position of the key in the index file */
long long Spartan_index::get_index_pos(uchar *buf, int key_len)
{
  long long pos = −1;

  DBUG_ENTER("Spartan_index::get_index_pos");
  SDE_INDEX *ndx;
  ndx = seek_index(buf, key_len);
  if (ndx != NULL)
    pos = ndx->pos;
  DBUG_RETURN(pos);
}

/* get next key in list */
uchar *Spartan_index::get_next_key()
{
  uchar *key = 0;

  DBUG_ENTER("Spartan_index::get_next_key");
  if (range_ptr != NULL)
  {
    key = (uchar *)my_malloc(max_key_len, MYF(MY_ZEROFILL | MY_WME));
    memcpy(key, range_ptr->key_ndx.key, range_ptr->key_ndx.length);
    range_ptr = range_ptr->next;
  }
  DBUG_RETURN(key);
}

/* get prev key in list */
uchar *Spartan_index::get_prev_key()
{
  uchar *key = 0;

  DBUG_ENTER("Spartan_index::get_prev_key");
  if (range_ptr != NULL)
  {
    key = (uchar *)my_malloc(max_key_len, MYF(MY_ZEROFILL | MY_WME));
    memcpy(key, range_ptr->key_ndx.key, range_ptr->key_ndx.length);
    range_ptr = range_ptr->prev;
  }
  DBUG_RETURN(key);
}

/* get first key in list */
uchar *Spartan_index::get_first_key()
{
  SDE_NDX_NODE *n = root;
  uchar *key = 0;

  DBUG_ENTER("Spartan_index::get_first_key");
  if (root != NULL)
  {
    key = (uchar *)my_malloc(max_key_len, MYF(MY_ZEROFILL | MY_WME));
    memcpy(key, n->key_ndx.key, n->key_ndx.length);
  }
  DBUG_RETURN(key);
}

/* get last key in list */
uchar *Spartan_index::get_last_key()
{
  SDE_NDX_NODE *n = root;
  uchar *key = 0;

  DBUG_ENTER("Spartan_index::get_last_key");
  while (n->next != NULL)
    n = n->next;
  if (n != NULL)
  {
    key = (uchar *)my_malloc(max_key_len, MYF(MY_ZEROFILL | MY_WME));
    memcpy(key, n->key_ndx.key, n->key_ndx.length);
  }
  DBUG_RETURN(key);
}

/* just close the index */
int Spartan_index::close_index()
{
  SDE_NDX_NODE *p;

  DBUG_ENTER("Spartan_index::close_index");
  if (index_file != −1)
  {
    my_close(index_file, MYF(0));
    index_file = −1;
  }
  while (root != NULL)
  {
    p = root;
    root = root->next;
    delete p;
  }
  DBUG_RETURN(0);
}

/* find a key in the index */
SDE_INDEX *Spartan_index::seek_index(uchar *key, int key_len)
{
  SDE_INDEX *ndx = NULL;
  SDE_NDX_NODE *n = root;
  int buf_len;
  bool done = false;

  DBUG_ENTER("Spartan_index::seek_index");
  if (n != NULL)
  {
    while((n != NULL) && !done)
    {
      buf_len = n->key_ndx.length;
      if (memcmp(n->key_ndx.key, key,
          (buf_len > key_len) ? buf_len : key_len) == 0)
        done = true;
      else
        n = n->next;
    }
  }
  if (n != NULL)
  {
    ndx = &n->key_ndx;
    range_ptr = n;
  }
  DBUG_RETURN(ndx);
}

/* find a key in the index and return position too */
SDE_NDX_NODE *Spartan_index::seek_index_pos(uchar *key, int key_len)
{
  SDE_NDX_NODE *n = root;
  int buf_len;
  bool done = false;

  DBUG_ENTER("Spartan_index::seek_index_pos");
  if (n != NULL)
  {
    while((n->next != NULL) && !done)
    {
      buf_len = n->key_ndx.length;
      if (memcmp(n->key_ndx.key, key,
          (buf_len > key_len) ? buf_len : key_len) == 0)
        done = true;
      else if (n->next != NULL)
        n = n->next;
    }
  }
  DBUG_RETURN(n);
}

/* read the index file from disk and store in memory */
int Spartan_index::load_index()
{
  SDE_INDEX *ndx;
  int i = 1;

  DBUG_ENTER("Spartan_index::load_index");
  if (root != NULL)
    destroy_index();
  /*
    First, read the metadata at the front of the index.
  */
  read_header();
  while(i != 0)
  {
    ndx = new SDE_INDEX();
    i = my_read(index_file, (uchar *)&ndx->key, max_key_len, MYF(0));
    i = my_read(index_file, (uchar *)&ndx->pos, sizeof(long long), MYF(0));
    i = my_read(index_file, (uchar *)&ndx->length, sizeof(int), MYF(0));
    if (i != 0)
      insert_key(ndx, false);
  }
  DBUG_RETURN(0);
}

/* get current position of index file */
long long Spartan_index::curfpos()
{
  long long pos = 0;

  DBUG_ENTER("Spartan_index::curfpos");
  pos = my_seek(index_file, 0l, MY_SEEK_CUR, MYF(0));
  DBUG_RETURN(pos);
}

/* write the index back to disk */
int Spartan_index::save_index()
{
  SDE_NDX_NODE *n = NULL;
  int i;
  DBUG_ENTER("Spartan_index::save_index");
  i = my_chsize(index_file, 0L, '\n', MYF(MY_WME));
  write_header();
  n = root;
  while (n != NULL)
  {
    write_row(&n->key_ndx);
    n = n->next;
  }
  DBUG_RETURN(0);
}

int Spartan_index::destroy_index()
{
  SDE_NDX_NODE *n = root;
  DBUG_ENTER("Spartan_index::destroy_index");
  while (root != NULL)
  {
    n = root;
    root = n->next;
    delete n;
  }
  root = NULL;
  DBUG_RETURN(0);
}

/* Get the file position of the first key in index */
long long Spartan_index::get_first_pos()
{
  long long pos = −1;

  DBUG_ENTER("Spartan_index::get_first_pos");
  if (root != NULL)
    pos = root->key_ndx.pos;
  DBUG_RETURN(pos);
}

/* truncate the index file */
int Spartan_index::trunc_index()
{
  DBUG_ENTER("Spartan_data::trunc_table");
  if (index_file != −1)
  {
    my_chsize(index_file, 0, 0, MYF(MY_WME));
    write_header();
  }
  DBUG_RETURN(0);
}
```

注意，和`Spartan_data`类一样，我使用`DBUG`例程来设置用于调试的跟踪元素。我还使用了`my_xxx`平台安全的实用方法。

![image](img/sq.jpg) **提示**这些方法可以在源码树根下的`mysys`目录中找到。它们通常被实现为存储在同名文件中的 C 函数(例如，`my_write.c`文件包含了`my_write()`方法)。

索引的工作方式是使用指向内存块的 uchar 指针存储一个键，一个位置值(`long long`)存储磁盘上用于定位文件指针的偏移位置，一个长度字段存储键的长度。在内存比较方法中使用了`length`变量来设置比较长度。这些数据项存储在一个名为`SDE_INDEX`的结构中。双向链表节点是另一个包含一个`SDE_INDEX`结构的结构。名为`SDE_NDX_NODE`的列表节点结构也为列表提供了`next`和`prev`指针。

当使用索引存储数据在`Spartan_data`类文件中的位置时，可以调用`insert_index()`方法，传入文件中数据项的键和偏移量。这个偏移量在对`my_write()`方法的调用中返回。这种技术允许您将指向数据的索引指针存储在磁盘上，并重用该信息，而无需转换它来将文件指针定位到磁盘上的正确位置。

索引存储在磁盘上的连续数据块中，这些数据块对应于`SDE_INDEX`结构的大小。该文件有一个头，用于存储崩溃状态变量和存储最大密钥长度的变量。崩溃状态变量有助于识别文件已损坏或在读取或写入期间发生了危及文件或其元数据完整性的错误的罕见情况。我没有使用可变长度的字段，比如 data 类，而是使用固定长度的内存块来简化磁盘访问的读写方法。在这种情况下，我有意识地决定为了简洁而牺牲空间。

现在，您已经了解了构建存储引擎(低级 I/O 功能)的肮脏工作，让我们看看如何构建一个基本的存储引擎。我将在后面的章节中返回到`Spartan_data`和`Spartan_index`类，分别讨论阶段 1 和阶段 5。

入门指南

下面的教程假设您已经配置了开发环境，并且已经编译了打开调试开关的服务器(见[第 5 章](05.html))。我研究了构建 Spartan 存储引擎的每个阶段。在开始之前，您需要做一个非常重要的步骤:创建一个测试文件来测试存储引擎，这样我们就可以朝着一个特定的目标驱动开发。[第 4 章](04.html)研究了 MySQL 测试套件以及如何创建和运行测试。请参阅该章了解更多详细信息或复习。

![image](img/sq.jpg) **提示**如果你使用的是 Windows，你可能无法使用 MySQL 测试套件(mysql-test-run.pl)。您可以使用 Cygwin ( `http://cygwin.com/`)来建立一个类似 Unix 的环境，并在那里运行测试套件。如果您不想设置 Cygwin 环境，您仍然可以创建测试文件，将语句复制并粘贴到 MySQL 客户端程序中，并以这种方式运行测试。

您应该做的第一件事是创建一个新的测试来测试 Spartan 存储引擎。即使引擎还不存在，本着测试驱动开发的精神，您应该在编写代码之前创建测试。让我们现在做那件事。

测试文件应该从一个简单的测试开始，创建表并从中检索行。您可以创建一个完整的测试文件，其中包含我将向您展示的所有操作，但是最好从一个简单的测试开始，并在构建 Spartan 存储引擎的过程中扩展它。这有一个额外的好处，即您的测试将只测试当前阶段，而不会为尚未实现的操作生成错误。清单 10-7 显示了一个测试 Stage 1 Spartan 存储引擎的基本测试示例。

在阅读本教程的过程中，您将向该测试添加语句，从而有效地为完整的 Spartan 存储引擎构建完整的测试。

[***清单 10-7。***](#_list7) 斯巴达-存储-引擎测试文件(Ch10s1.test)

```sql
#
# Simple test for the Spartan storage engine
#
--disable_warnings
drop table if exists t1;
--enable_warnings

CREATE TABLE t1 (
  col_a int,
  col_b varchar(20),
  col_c int
) ENGINE=SPARTAN;

SELECT * FROM t1;

RENAME TABLE t1 TO t2;

DROP TABLE t2;
```

您可以在源代码树的根目录下的`/mysql-test/t`目录中创建这个文件。当你第一次执行的时候，出错是正常的。事实上，您应该在开始阶段 1 之前执行测试。这样，你就知道测试是有效的(它不会失败)。如果您回忆起第 4 章的[，您可以使用`/mysql-test`目录](04.html)中的命令来执行测试:

```sql
%> touch r/Ch10s1.result
%> ./mysql-test-run.pl Ch10s1
%> cp r/cab.reject r/Ch10s1.result
%> ./mysql-test-run.pl Ch10s1
```

你试过吗？它产生错误了吗？测试套件返回了`[failed]`，但是如果您检查生成的日志文件，您不会看到任何错误，尽管您会看到警告。为什么没有失败？事实证明，如果您在 create 语句中指定的存储引擎不存在，MySQL 将使用默认的存储引擎。在这种情况下，我的 MySQL 服务器安装发出了系统正在使用默认的 MyISAM 存储引擎的错误，因为没有找到 Spartan 存储引擎。[清单 10-8](#list8) 显示了一个`/mysql-test/r/Ch10s1.log`文件的例子。

[***清单 10-8。***](#_list8) 来自测试运行的示例日志文件

```sql
mysql> drop table if exists t1;
mysql> CREATE TABLE t1 (
    ->   col_a int,
    ->   col_b varchar(20),
    ->   col_c int
    -> ) ENGINE=SPARTAN;
ERROR 1286 (42000): Unknown storage engine 'SPARTAN'
mysql>
mysql> SELECT * FROM t1;
ERROR 1146 (42S02): Table 'test.t1' doesn't exist
mysql>
mysql> DROP TABLE t1;
ERROR 1051 (42S02): Unknown table 'test.t1'
```

第一阶段:踩熄发动机

这个阶段的目标是生产一个存根存储引擎插件。存根引擎将具有最基本的操作，能够在`CREATE`语句上选择引擎并创建基表元文件(`.frm`)。我知道这听起来并不多，虽然它实际上并不存储任何东西， [<sup>5</sup>](#Fn5) 创建一个阶段 1 引擎可以让您确保您拥有向服务器注册存储引擎所需的所有初始代码更改。我之前提到过，在 MySQL 系统的未来版本中，其中一些变化可能是不必要的。在使用 MySQL 源代码之前，最好查看一下在线参考手册中的最新变化。

创建斯巴达插件源文件

首先，在主源代码树的`/storage`目录下创建一个名为`spartan`的目录。我使用示例存储引擎让我们开始。MySQL 参考手册建议使用示例存储引擎的源文件作为基础。示例存储引擎包含用正确的代码语句实现的所有必要方法。这使得为 Spartan 存储引擎创建基础源文件变得很容易。

将`*.cc`和`*.h`文件从`/storage/example`目录复制到`/storage/spartan`目录。现在在`spartan`目录中应该有两个文件:`ha_example.cc`和`ha_example.h`。前缀`ha_`表示这些文件是从处理程序类派生的，代表一个表处理程序。重命名文件`ha_spartan.cc`和`ha_spartan.h`。

![image](img/sq.jpg) **注意**短语*表处理器* 已经被更新的短语*存储引擎*所取代。您可能会遇到一些关于表处理程序的文档。它们与存储引擎同义，因此适用。

创建源文件的下一步是将所有出现的单词`example`和`EXAMPLE`分别改为`spartan`和`SPARTAN`。您可以使用您喜欢的代码编辑器或文本处理器来实现这些更改。生成的文件应该将所有的示例标识符都更改为`spartan`(例如`st_example_share`应该变成`st_spartan_share`)。用例敏感性。如果您没有正确地做到这一点，您的存储引擎将无法工作。

最后，编辑`ha_spartan.h`文件并添加 include 指令以包含`spartan_data.h`文件，如下所示:

```sql
#include "spartan_data.h"
```

添加 CMakeLists.txt 文件

因为我们正在创建一个新的插件和一个新的项目，所以我们需要创建一个 CMakeLists.txt 文件，以便 cmake 工具可以为项目创建适当的 make 文件。在`/storage/spartan`目录中打开一个新文件，并将其命名为 CMakeLists.txt。添加到文件中:

```sql
# Spartan storage engine plugin

SET(SPARTAN_PLUGIN_STATIC "spartan")
SET(SPARTAN_PLUGIN_DYNAMIC "spartan")

SET(SPARTAN_SOURCES ha_spartan.cc ha_spartan.h spartan_data.cc spartan_data.h)
MYSQL_ADD_PLUGIN(spartan ${SPARTAN_SOURCES} STORAGE_ENGINE MODULE_ONLY)
```

请注意，我们使用宏来定义插件的源代码，并在 c make 操作期间使用另一个宏来添加特定于存储引擎的 make 文件行。

最终修改

你需要做另外一个改变。在`ha_spartan.cc`文件的底部，您应该会看到一个`mysq_declare_plugin`部分。这是插件接口用来安装存储引擎的代码。关于这个结构的更多细节见[第 9 章](09.html)。

请随意修改这一部分，以表明它是 Spartan 存储引擎。您可以在代码中添加自己的名字和注释。这个部分还没有使用，但是当存储引擎插件架构完成时，您将需要这个部分来启用插件接口。

```sql

mysql_declare_plugin(spartan)
{
  MYSQL_STORAGE_ENGINE_PLUGIN,
  &spartan_storage_engine,
  "Spartan",
  "Chuck Bell",
  "Spartan Storage Engine Plugin",
  PLUGIN_LICENSE_GPL,
  spartan_init_func,                            /* Plugin Init */
  NULL,                                      /* Plugin Deinit */
  0x0100 /* 1.0 */,
  func_status,                                /* status variables */
  spartan_system_variables,                          /* system variables */
  NULL,                                      /* config options */
  0,                                      /* flags */
}
mysql_declare_plugin_end;
```

如果对于一个存储引擎插件来说，这似乎是一个很大的工作量，那么事实就是如此。幸运的是，这种情况将在 MySQL 系统的未来版本中得到改善。

编译斯巴达引擎

现在所有这些改变都已经完成，是时候编译服务器并测试新的 Spartan 存储引擎了。该过程与其他编译过程相同。从源树的根目录，运行命令:

```sql
cmake .
make
```

在调试模式下编译服务器，以便可以在服务器运行时生成跟踪文件并使用交互式调试器浏览源代码。

测试斯巴达发动机的第一阶段

一旦服务器编译完毕，您就可以启动并运行它了。首先，安装新的插件。正如我们在[第 9 章](09.html)中看到的，我们可以将编译后的库(ha_spartan.so)复制到插件目录(plugin-dir)并执行命令:

```sql
INSTALL PLUGIN spartan SONAME 'ha_spartan.so';
```

或者，对于 Windows，此命令:

```sql
INSTALL PLUGIN spartan SONAME 'ha_spartan.dll';
```

您可能会尝试使用交互式 MySQL 客户端来测试服务器。没关系，我就是这么做的。[清单 10-9](#list9) 显示了运行大量 SQL 命令后 MySQL 客户端的结果。在这个例子中，我运行了`SHOW STORAGE ENGINES`、`CREATE TABLE`、`SHOW CREATE TABLE`和`DROP TABLE`命令。结果表明，这些命令是有效的，当我运行它时，测试应该会通过。

[***清单 10-9。***](#_list9) 示例第一阶段斯巴达存储引擎手动测试

```sql
mysql> SHOW PLUGINS \G
*************************** 1\. row ***************************
   Name: binlog
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 2\. row ***************************
   Name: mysql_native_password
 Status: ACTIVE
   Type: AUTHENTICATION
Library: NULL
License: GPL
*************************** 3\. row ***************************
   Name: mysql_old_password
 Status: ACTIVE
   Type: AUTHENTICATION
Library: NULL
License: GPL
*************************** 4\. row ***************************
   Name: sha256_password
 Status: ACTIVE
   Type: AUTHENTICATION
Library: NULL
License: GPL
*************************** 5\. row ***************************
   Name: CSV
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 6\. row ***************************
   Name: MRG_MYISAM
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 7\. row ***************************
   Name: MEMORY
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 8\. row ***************************
   Name: MyISAM
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 9\. row ***************************
   Name: BLACKHOLE
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 10\. row ***************************
   Name: InnoDB
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL

...

*************************** 43\. row ***************************
   Name: partition
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
43 rows in set (0.00 sec)

mysql> INSTALL PLUGIN spartan SONAME 'ha_spartan.so';
Query OK, 0 rows affected (0.00 sec)

mysql> SHOW PLUGINS \G
*************************** 1\. row ***************************
   Name: binlog
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 2\. row ***************************
   Name: mysql_native_password
 Status: ACTIVE
   Type: AUTHENTICATION
Library: NULL
License: GPL
*************************** 3\. row ***************************
   Name: mysql_old_password
 Status: ACTIVE
   Type: AUTHENTICATION
Library: NULL
License: GPL
*************************** 4\. row ***************************
   Name: sha256_password
 Status: ACTIVE
   Type: AUTHENTICATION
Library: NULL
License: GPL
*************************** 5\. row ***************************
   Name: CSV
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 6\. row ***************************
   Name: MRG_MYISAM
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 7\. row ***************************
   Name: MEMORY
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 8\. row ***************************
   Name: MyISAM
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 9\. row ***************************
   Name: BLACKHOLE
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 10\. row ***************************
   Name: InnoDB
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL

...

*************************** 43\. row ***************************
   Name: partition
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 44\. row ***************************
   Name: Spartan
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: ha_spartan.so
License: GPL
44 rows in set (0.00 sec)

mysql> use test;
Database changed
mysql> CREATE TABLE t1 (col_a int, col_b varchar(20), col_c int) ENGINE=SPARTAN;
Query OK, 0 rows affected (0.02 sec)

mysql> SHOW CREATE TABLE t1 \G
*************************** 1\. row ***************************
       Table: t1
Create Table: CREATE TABLE 't1' (
  'col_a' int(11) DEFAULT NULL,
  'col_b' varchar(20) DEFAULT NULL,
  'col_c' int(11) DEFAULT NULL
) ENGINE=SPARTAN DEFAULT CHARSET=latin1
1 row in set (0.00 sec)

mysql> DROP TABLE t1;
Query OK, 0 rows affected (0.00 sec)

mysql>
```

我知道存储引擎正在工作，因为它列在了`SHOW` PLUGINS 命令和`SHOW CREATE TABLE`语句中。如果引擎连接失败，它可能会也可能不会显示在`SHOW PLUGINS`命令中，但是`CREATE TABLE`命令会指定 MyISAM 存储引擎而不是 Spartan 存储引擎。

您还应该运行您之前创建的测试(如果您运行的是 Linux)。当您这次运行测试时，测试通过。这是因为存储引擎现在是服务器的一部分，它可以被识别。让我们输入`SELECT`命令并重新运行测试。它应该再次通过。此时，您可以将测试结果添加到`/r`目录中，用于自动化测试报告。[清单 10-10](#list10) 显示了更新后的测试。

![image](img/sq.jpg) **注**我们会为每个阶段做新版本的测试，命名为 Ch10sX(如 Ch10s1、Ch10s2 等。).

[***清单 10-10。***](#_list10) 更新了斯巴达存储引擎测试文件(Ch10s1.test)

```sql
#
# Simple test for the Spartan storage engine
#
--disable_warnings
drop table if exists t1;
--enable_warnings

CREATE TABLE t1 (
  col_a int,
  col_b varchar(20),
  col_c int
) ENGINE=SPARTAN;

SELECT * FROM t1;

DROP TABLE t1;
```

这是第一阶段的引擎。它已经插好，可以添加`Spartan_data`和`spartan_index`类了。在下一阶段，我们将添加创建、打开、关闭和删除文件的功能。这听起来可能不多，但本着增量开发的精神，您可以添加这一点，然后测试和调试，直到一切正常，然后再继续进行更具挑战性的操作。

阶段 2:使用表格

此阶段的目标是生成一个存根存储引擎，它可以创建、打开、关闭和删除数据文件。在此阶段，您将设置基本的文件处理例程，并确定引擎正在正确处理文件。MySQL 已经为您提供了许多文件 I/O 例程,它们封装了底层函数，使它们平台安全。以下是一些可用函数的示例。详见`/mysys`目录中的文件。

*   `my_create(...)`:创建文件
*   `my_open(...)`:打开文件
*   `my_read(...)`:从文件中读取数据
*   `my_write(...)`:将数据写入文件
*   `my_delete(...)`:删除文件
*   `fn_format(...)`:创建一个平台安全的路径语句

在这一阶段，我将向您展示如何为低级 I/O 合并`Spartan_data`类。我将引导您完成每个更改，并包含每个更改的完整方法源代码。

更新斯巴达源文件

首先，要么从 Apress 网站的这本书的目录页面下载压缩的源文件，并将它们复制到您的`/storage/spartan`目录中。或者使用您之前创建的`spartan_data.cc`和`spartan_data.h`文件。

因为我使用了`Spartan_data`类来处理低级 I/O，所以我需要创建一个对象指针来保存该类的一个实例。我需要把它放在一个可以共享的地方，这样就不会有两个或更多的类实例试图读取同一个文件。虽然这可能没问题，但它更复杂，需要更多的工作。相反，我在 Spartan 处理程序的共享结构中放置了一个对象引用。

![image](img/sq.jpg) **提示**在你做出每一个改变之后，编译`spartan`项目以确保没有错误。在进行下一个更改之前，请更正任何错误。

更新头文件

打开 ha_spartan.h 文件，将对象引用添加到 st_spartan_share 结构中。[清单 10-11](#list11) 显示了完整的代码变更(为简洁起见，省略了注释)。一旦你做了这个改变，重新编译`spartan`源文件以确保没有任何错误。

[***清单 10-11。***](#_list11) 更改 ha_spartan.h 中的共享结构

```sql
/*
  Spartan Storage Engine Plugin
*/

#include "my_global.h"                   /* ulonglong */
#include "thr_lock.h"                    /* THR_LOCK, THR_LOCK_DATA */
#include "handler.h"                     /* handler */
#include "spartan_data.h"

class Spartan_share : public Handler_share {
public:
  mysql_mutex_t mutex;
  THR_LOCK lock;
  Spartan_data *data_class;
  Spartan_share();
  ∼Spartan_share()
  {
    thr_lock_delete(&lock);
    mysql_mutex_destroy(&mutex);
    if (data_class != NULL)
      delete data_class;
    data_class = NULL;
  }
};

...
```

更新类文件

接下来的一系列修改是在`ha_spartan.cc`文件中完成的。打开文件并找到`constructor for the new Spartan_share class`。由于现在在共享结构中有一个对象引用，我们需要在创建共享时实例化它。将`Spartan_data`类的实例化添加到方法中。将对象引用命名为`data_class`。[清单 10-12](#list12) 显示了经过修改的方法摘录。

![image](img/sq.jpg) **提示**如果你使用的是 Windows，而 Visual Studio 中的 IntelliSense 无法识别新的`Spartan_data`类，你需要修复`.ncb`文件。退出 Visual Studio，从源根目录删除`.ncb`文件，然后重新构建`mysqld`。这可能需要一段时间，但完成后，IntelliSense 将再次工作。

[***清单 10-12。***](#_list12) 更改 ha_spartan.cc 中的 Spartan_data 类构造函数

```sql
Spartan_share::Spartan_share()
{
  thr_lock_init(&lock);
  mysql_mutex_init(ex_key_mutex_Spartan_share_mutex,
                   &mutex, MY_MUTEX_INIT_FAST);
  data_class = new Spartan_data();
}
```

自然，当共享结构被销毁时，您也需要销毁对象引用。找到`destructor`方法并添加代码来销毁数据类对象引用。[清单 10-13](#list13) 显示了修改后的方法摘录。

[***清单 10-13。***](#_list13) 更改 ha_spartan.h 中的 Spartan_data 析构函数

```sql
class Spartan_share : public Handler_share {
public:
  mysql_mutex_t mutex;
  THR_LOCK lock;
  Spartan_data *data_class;
  Spartan_share();
  ∼Spartan_share()
  {
    thr_lock_delete(&lock);
    mysql_mutex_destroy(&mutex);
    if (data_class != NULL)
      delete data_class;
    data_class = NULL;
  }
};
```

Spartan 存储引擎的处理程序实例也必须为数据文件提供文件扩展名。因为既有数据文件又有索引文件，所以需要创建两个文件扩展名。定义文件扩展名并将它们添加到`ha_spartan_exts`数组。对数据文件使用`.sde`。`sdi`为索引文件。MySQL 使用这些扩展来删除文件和其他维护操作。找到`ha_spartan_exts`数组，在它上面添加`#define`，并将这些定义添加到数组中。清单 10-14 显示了数组结构的变化。

[***清单 10-14。***](#_list14) 对 ha_spartan.cc 中 ha_spartan_exts 数组的修改

```sql
#define SDE_EXT ".sde"
#define SDI_EXT ".sdi"

static const char *ha_spartan_exts[] = {
  SDE_EXT,
  SDI_EXT,
  NullS
};
```

您需要添加的第一个操作是创建文件操作。这将创建一个空文件来包含表的数据。找到`create()`方法并添加代码以获得共享结构的副本，然后调用数据类`create_table()`方法并关闭表。[清单 10-15](#list15) 显示了更新后的创建方法。我将向您展示如何在稍后的阶段添加索引类。

[***清单 10-15。***](#_list15) 更改 ha_spartan.cc 中的 create()方法

```sql
int ha_spartan::create(const char *name, TABLE *table_arg,
                       HA_CREATE_INFO *create_info)
{
  DBUG_ENTER("ha_spartan::create");
  char name_buff[FN_REFLEN];

  if (!(share = get_share()))
    DBUG_RETURN(1);
  /*
    Call the data class create table method.
    Note: the fn_format() method correctly creates a file name from the
    name passed into the method.
  */
  if (share->data_class->create_table(fn_format(name_buff, name, "", SDE_EXT,
                                      MY_REPLACE_EXT|MY_UNPACK_FILENAME)))
    DBUG_RETURN(−1);
  share->data_class->close_table();
  DBUG_RETURN(0);
}
```

您需要添加的下一个操作是打开文件操作。这将打开包含表格数据的文件。找到`open()`方法并添加代码以获得共享结构的副本并打开表。[清单 10-16](#list16) 显示了更新后的打开方法。

[***清单 10-16。***](#_list16) 更改 ha_spartan.cc 中的 open()方法

```sql
int ha_spartan::open(const char *name, int mode, uint test_if_locked)
{
  DBUG_ENTER("ha_spartan::open");
  char name_buff[FN_REFLEN];

  if (!(share = get_share()))
    DBUG_RETURN(1);
  /*
    Call the data class open table method.
    Note: the fn_format() method correctly creates a file name from the
    name passed into the method.
  */
  share->data_class->open_table(fn_format(name_buff, name, "", SDE_EXT,
                                MY_REPLACE_EXT|MY_UNPACK_FILENAME));
  thr_lock_data_init(&share->lock,&lock,NULL);
  DBUG_RETURN(0);
```

}

您需要添加的下一个操作是删除文件操作。这将删除包含该表数据的文件。找到`delete_table()`方法，添加关闭表的代码，并调用`my_delete()`函数删除表。[清单 10-17](#list17) 显示了更新后的删除方法。我将在稍后阶段向您展示如何添加索引类。

[***清单 10-17。***](#_list17) 修改 ha_spartan.cc 中的 delete_table()方法

```sql
int ha_spartan::delete_table(const char *name)
{
  DBUG_ENTER("ha_spartan::delete_table");
  char name_buff[FN_REFLEN];

  /*
    Call the mysql delete file method.
    Note: the fn_format() method correctly creates a file name from the
    name passed into the method.
  */
  my_delete(fn_format(name_buff, name, "", SDE_EXT,
            MY_REPLACE_EXT|MY_UNPACK_FILENAME), MYF(0));
  DBUG_RETURN(0);
}
```

还有最后一个操作，许多开发者都忘记了。`RENAME TABLE`命令允许用户重命名表格。您的存储处理程序还必须能够将文件复制到新名称，然后删除旧名称。当 MySQL 服务器处理`.frm`文件的重命名时，您需要执行数据文件的复制。找到`rename_table()`方法并添加代码来调用`my_copy()`函数来复制表的数据文件。清单 10-18 显示了更新后的重命名表方法。稍后，我将向您展示如何添加索引类。

[***清单 10-18。***](#_list18) 修改 ha_spartan.cc 中的 rename_table()方法

```sql
int ha_spartan::rename_table(const char * from, const char * to)
{
  DBUG_ENTER("ha_spartan::rename_table ");
  char data_from[FN_REFLEN];
  char data_to[FN_REFLEN];

  my_copy(fn_format(data_from, from, "", SDE_EXT,
          MY_REPLACE_EXT|MY_UNPACK_FILENAME),
          fn_format(data_to, to, "", SDE_EXT,
          MY_REPLACE_EXT|MY_UNPACK_FILENAME), MYF(0));
  /*
    Delete the file using MySQL's delete file method.
  */
  my_delete(data_from, MYF(0));
  DBUG_RETURN(0);
}
```

好了，现在您已经完成了第 2 阶段存储引擎。剩下要做的就是编译服务器并运行测试。

![image](img/sq.jpg) **注意**一定要把更新后的 ha_spartan.so(或者 ha_spartan.dll)复制到你的插件目录下。如果你忘记了这一步，你可能会花很多时间去寻找为什么你的第二阶段引擎不能正常工作。

测试斯巴达发动机的第二阶段

当您再次运行测试时，您应该看到所有语句都成功完成。然而，有两件事测试不会验证你。首先，您需要确保`.sde`文件已经创建并删除。其次，您需要确保 rename 命令有效。

测试创建和删除表的命令很容易。启动服务器，然后启动 MySQL 客户端。从测试中发出`CREATE`语句，然后使用您的文件浏览器导航到`/data/test`文件夹。在那里你应该看到两个文件:`t1.frm`和`t1.sde`。回到你的 MySQL 客户端，发布`DROP`声明。然后返回到`/data/test`文件夹，验证文件确实被删除了。

测试重命名表的命令也很容易。重复`CREATE`语句测试，然后发出命令:

```sql
RENAME TABLE t1 TO t2;
```

运行 RENAME 命令后，您应该能够发出 SELECT 语句，甚至是 DROP 语句来操作重命名的表。这将产生如下输出:

```sql
mysql> RENAME TABLE t1 to t2;
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT * FROM t2;
Empty set (0.00 sec)

mysql> DROP TABLE t2;
Query OK, 0 rows affected (0.00 sec)
```

使用文件浏览器导航至`/data/test`文件夹。在那里你应该看到两个文件:`t2.frm`和`t2.sde`。返回 MySQL 客户端，发出`DROP`语句。然后返回到`/data/test`文件夹，验证文件确实被删除了。

既然您已经验证了`RENAME`语句可以工作，那么将它添加到测试文件中并重新运行测试。测试应该没有错误地完成。[清单 10-19](#list19) 显示了更新后的`Ch10s2.test`文件。

[***清单 10-19。***](#_list19) 更新了斯巴达存储引擎测试文件(Ch10s2.test)

```sql
#
# Simple test for the Spartan storage engine
#
--disable_warnings
drop table if exists t1;
--enable_warnings

CREATE TABLE t1 (
  col_a int,
  col_b varchar(20),
  col_c int
) ENGINE=SPARTAN;

SELECT * FROM t1;

RENAME TABLE t1 TO t2;

DROP TABLE t2;
```

好了，这是第二阶段的引擎。它被插入并创建、删除和重命名文件。在下一阶段，我们将添加读写数据的能力。

第三阶段:读写数据

此阶段的目标是生产一个可以读写数据的工作存储引擎。在这个阶段，我将向您展示如何结合`Spartan_data`类来读取和写入数据。我将带您了解每个变更，并包括每个变更的完整方法源代码。

更新斯巴达源文件

制造阶段 3 引擎需要更新基本读取过程(如前所述)。为了实现读操作，您将对`ha_spartan.cc`文件中的`rnd_init()`、`rnd_next()`、`position()`和`rnd_pos()`方法进行修改。`position()`和`rnd_pos()`方法在大型排序操作中使用，并使用内部缓冲区来存储行。写操作只需要改变`write_row()`方法。

更新头文件

定位方法要求您存储一个指针—记录偏移位置或排序操作中使用的键值。Oracle 提供了一种很好的方式来做到这一点，稍后您将在 position 方法中看到。打开`ha_spartan.h`文件并将`current_position`变量添加到`ha_spartan`类中。[清单 10-20](#list20) 显示了修改后的摘录。

[***清单 10-20。***](#_list20) 修改为 ha_spartan.h 中的 ha_spartan 职业

```sql
class ha_spartan: public handler
{
  THR_LOCK_DATA lock;      /* MySQL lock */
  Spartan_share *share;    ///< Shared lock info
  Spartan_share *get_share(); ///< Get the share
  off_t current_position;  /* Current position in the file during a file scan */

public:
  ha_spartan(handlerton *hton, TABLE_SHARE *table_ar);
  ∼ha_spartan()
  {
  }
...
```

更新源文件

返回到`ha_spartan.cc`文件，因为那是需要进行其余修改的地方。你需要改变的第一个方法是`rnd_init()`。这里是您需要为表扫描设置初始条件的地方。在这种情况下，将当前位置设置为 0(文件开始)，记录数设置为 0，并指定要用于排序方法的项目的长度。使用`long long,`,因为这是文件中当前位置的数据类型。[清单 10-21](#list21) 显示了经过修改的更新方法。

[***清单 10-21。***](#_list21) 更改 ha_spartan.cc 中的 rnd_init()方法

```sql
int ha_spartan::rnd_init(bool scan)
{
  DBUG_ENTER("ha_spartan::rnd_init");
  current_position = 0;
  stats.records = 0;
  ref_length = sizeof(long long);
  DBUG_RETURN(0);
}
```

![image](img/sq.jpg) **注意**这是我们开始添加示例引擎之外的功能的地方。请确保正确指定您的返回代码。示例引擎通过发出 return 语句`DBUG_RETURN(HA_ERR_WRONG_COMMAND);`告诉优化器某个函数不受支持。请确保将这些更改为错误命令返回代码以外的内容(例如，0)。

下一个需要改变的方法是`rnd_next()`，它负责从文件中获取下一条记录，并检测文件的结尾。在这个方法中，您可以调用数据类`read_row()`方法，传入记录缓冲区、缓冲区的长度以及文件中的当前位置。注意文件结尾的返回和更多统计信息的设置。方法还记录当前位置，以便下一次调用方法时将文件推进到下一条记录。[清单 10-22](#list22) 显示了修改后的更新方法。

[***清单 10-22。***](#_list22) 更改 ha_spartan.cc 中的 rnd_next()方法

```sql
int ha_spartan::rnd_next(uchar *buf)
{
  int rc;
  DBUG_ENTER("ha_spartan::rnd_next");
  MYSQL_READ_ROW_START(table_share->db.str, table_share->table_name.str,
                       TRUE);
  /*
    Read the row from the data file.
  */
  rc = share->data_class->read_row(buf, table->s->rec_buff_length,
                                   current_position);
  if (rc != −1)
    current_position = (off_t)share->data_class->cur_position();
  else
    DBUG_RETURN(HA_ERR_END_OF_FILE);
  stats.records++;
  MYSQL_READ_ROW_DONE(rc);
  DBUG_RETURN(rc);
}
```

`Spartan_data`类很好，因为它以与 MySQL 内部缓冲区相同的格式存储记录。事实上，它只是为每个记录写了几个 uchars 的头，存储了一个删除标志和记录长度(用于扫描和修复)。如果您正在使用一个以不同格式存储数据的存储引擎，那么此时您需要执行转换。在`ha_tina.cc`文件中可以找到如何完成翻译的示例。这个过程看起来像这样:

```sql
for (Field **field=table->field ; *field ; field++)
{
  /* copy field data to your own storage type */
  my_value = (*field)->val_str();
  my_store_field(my_value);
}
```

在这个例子中，您正在遍历`field`数组，以您自己的格式写出数据。寻找`ha_tina::find_current_row()`方法 的例子。

您需要更改的下一个方法是`position()`，它记录了文件在 MySQL 指针存储机制中的当前位置。它在每次调用`rnd_next()`后被调用。存储和检索这些指针的方法是`my_store_ptr()`和`my_get_ptr()`。store-pointer 方法将一个引用变量(你想存储东西的地方)、你想存储的东西的长度和你想存储的东西作为参数。get-pointer 方法接受一个引用变量和所检索内容的长度，并返回存储的项。这些方法用于需要对数据进行排序的 order by 行的情况。看看清单 10-23 中的`position()`方法的变化，看看如何调用存储指针方法。

[***清单 10-23。***](#_list23) 对 ha_spartan.cc 中 position()方法的修改

```sql
void ha_spartan::position(const uchar *record)
{
  DBUG_ENTER("ha_spartan::position");
  my_store_ptr(ref, ref_length, current_position);
  DBUG_VOID_RETURN;
}
```

您需要更改的下一个方法是`rnd_pos()` ，在这里您将检索存储的当前位置，然后从该位置读入行。注意，在这个方法中，我们还增加了读取统计数据`ha_read_rnd_next_count`。这为优化器提供了关于表中有多少行的信息，并且有助于优化后面的查询。[清单 10-24](#list24) 显示了经过修改的更新方法。

[***清单 10-24。***](#_list24) 修改 ha_spartan.cc 中的 rnd_pos()方法

```sql
int ha_spartan::rnd_pos(uchar *buf, uchar *pos)
{
  int rc;
  DBUG_ENTER("ha_spartan::rnd_pos");
  MYSQL_READ_ROW_START(table_share->db.str, table_share->table_name.str,
                       TRUE);
  ha_statistic_increment(&SSV::ha_read_rnd_next_count);
  current_position = (off_t)my_get_ptr(pos,ref_length);
  rc = share->data_class->read_row(buf, current_position, -1);
  MYSQL_READ_ROW_DONE(rc);
  DBUG_RETURN(rc);
}
```

您需要更改的下一个方法是`info()` ，它将信息返回给优化器，以帮助选择最佳的执行路径。这是一个实现起来很有趣的方法，当你阅读源代码中的注释时，它会显得很幽默。在这个方法中你需要做的是返回记录的数量。Oracle 声明您应该总是返回 2 或更大的值。这将使优化器中浪费一行记录集的部分脱离。[清单 10-25](#list25) 显示了更新后的`info()`方法。

[***清单 10-25。***](#_list25) 对 ha_spartan.cc 中 info()方法的修改

```sql
int ha_spartan::info(uint flag)
{
  DBUG_ENTER("ha_spartan::info");
  /* This is a lie, but you don't want the optimizer to see zero or 1 */
  if (stats.records < 2)
    stats.records= 2;
  DBUG_RETURN(0);
}
```

你需要改变的最后一个方法是`write_row()`；您将再次使用`Spartan_data`类将数据写入数据文件。像读一样，`Spartan_data`类只需要把记录缓冲区写到磁盘，前面有一个删除状态标志和记录长度。[清单 10-26](#list26) 显示了修改后的更新方法。

[***清单 10-26。***](#_list26) 对 ha_spartan.cc 中 write_row()方法的修改

```sql
int ha_spartan::write_row(uchar *buf)
{
  DBUG_ENTER("ha_spartan::write_row");
  long long pos;
  SDE_INDEX ndx;

  ha_statistic_increment(&SSV::ha_write_count);
  /*
    Begin critical section by locking the spartan mutex variable.
  */
  mysql_mutex_lock(&share->mutex);
  pos = share->data_class->write_row(buf, table->s->rec_buff_length);
/*
    End section by unlocking the spartan mutex variable.
  */
  mysql_mutex_unlock(&share->mutex);
  DBUG_RETURN(0);
}
```

请注意，我再次在写入操作周围放置了一个互斥体(例如，临界区),这样就不会有两个线程同时写入。现在是编译服务器和调试任何错误的好时机。完成后，您将拥有一个完整的阶段 3 存储引擎。剩下要做的就是编译服务器并运行测试。

测试斯巴达发动机的第三阶段

当您再次运行测试时，您应该看到所有语句都成功完成。如果你想知道为什么我总是从最后一个增量开始运行测试，那是因为你想确保没有新代码破坏旧代码正在做的任何事情。在这种情况下，您可以看到您仍然可以创建、重命名和删除表。现在，让我们继续测试读写操作。

测试这些功能很容易。启动服务器，然后启动 MySQL 客户端。如果您删除了测试表，请重新创建它，然后发出命令:

```sql
INSERT INTO t1 VALUES(1, "first test", 24);
INSERT INTO t1 VALUES(4, "second test", 43);
INSERT INTO t1 VALUES(3, "third test", -2);
```

在每条语句之后，您应该看到成功插入了记录。如果遇到错误(这是不应该的)，启动调试器，在`ha_spartan.cc`文件的所有读写方法中设置断点，然后调试问题。除了`ha_spartan.cc`文件之外，您不应该再查看其他文件，因为这是唯一可能包含错误来源的文件。 [<sup>6</sup>](#Fn6)

现在您可以发出一个`SELECT`语句，看看服务器向您发回什么。输入命令:

```sql
SELECT * FROM t1;
```

您应该会看到返回的所有三行。清单 10-27 显示了运行查询的结果。

[***清单 10-27。***](#_list27) 运行插入/选择语句的结果

```sql

mysql> INSERT INTO t1 VALUES(1, "first test", 24);
Query OK, 1 row affected (0.00 sec)

mysql> INSERT INTO t1 VALUES(4, "second test", 43);
Query OK, 1 row affected (0.00 sec)

mysql> INSERT INTO t1 VALUES(3, "third test", -2);
Query OK, 1 row affected (0.00 sec)

mysql> SELECT * FROM t1;
+−−-----+−−-----------+−−-----+
| col_a | col_b       | col_c |
+−−-----+−−-----------+−−-----+
|     1 | first test  |    24 |
|     4 | second test |    43 |
|     3 | third test  |    -2 |
+−−-----+−−-----------+−−-----+
3 rows in set (0.00 sec)

mysql>
```

现在，您已经验证了读取和写入工作正常，请将这些操作的测试添加到测试文件中，然后重新运行测试。测试应该没有错误地完成。清单 10-28 显示了更新后的`Ch10s3.test`文件。

[***清单 10-28。***](#_list28) 更新了斯巴达-存储-引擎测试文件(Ch10s3.test)

```sql
#
# Simple test for the Spartan storage engine
#
--disable_warnings
drop table if exists t1;
--enable_warnings

CREATE TABLE t1 (
  col_a int,
  col_b varchar(20),
  col_c int
) ENGINE=SPARTAN;

SELECT * FROM t1;
INSERT INTO t1 VALUES(1, ìfirst testî, 24);
INSERT INTO t1 VALUES(4, ìsecond testî, 43);
INSERT INTO t1 VALUES(3, ìthird testî, -2);
SELECT * FROM t1;
RENAME TABLE t1 TO t2;
SELECT * FROM t2;
DROP TABLE t2;
```

这是第三阶段的引擎。它现在是一个基本的读/写存储引擎，可以完成读写数据的所有基本需求。在下一阶段，我们将添加更新和删除数据的功能。

阶段 4:更新和删除数据

这个阶段的目标是产生一个可以更新和删除数据的工作存储引擎。在这个阶段，我将向您展示如何整合用于更新和删除数据的`Spartan_data`类。我将带您经历每一个变更，并包括每一个变更的完整方法源代码。

`Spartan_data`类就地执行更新。也就是说，旧数据被新数据覆盖。删除是通过将数据标记为已删除并在读取时跳过已删除的记录来执行的。`Spartan_data`类中的`read_row()`方法跳过被删除的行。这似乎会浪费很多空间，如果存储引擎用于有大量删除和插入的情况，这可能是真的。为了减少这种可能性，您总是可以转储然后删除表，并从转储中重新加载数据。这将删除空记录。取决于您计划如何构建自己的存储引擎，这可能是您需要重新考虑的事情。

更新斯巴达源文件

这个阶段要求您更新`update_row()`、`delete_row()`和`delete_all_rows()`方法。`delete_all_rows()`方法是一种节省时间的方法，用于一次清空一个表，而不是一次清空一行。对于截断操作以及检测到批量删除查询时，优化器可能会调用此方法。

更新头文件

对于阶段 4 存储引擎，不需要对`ha_spartan.h`文件进行任何更改。

更新源文件

打开`ha_spartan.cc`文件并找到`update_row()`方法。该方法将旧记录和新记录缓冲区作为参数传递。这很好，因为我们没有索引，必须进行表扫描来定位记录！幸运的是，`Spartan_data`类有`update_row()`方法可以为您完成这项工作。[清单 10-29](#list29) 显示了修改后的更新方法。

[***清单 10-29。***](#_list29) 更改 ha_spartan.cc 中的 update_row()方法

```sql
/* update a record in place */
long long Spartan_data::update_row(uchar *old_rec, uchar *new_rec,
                                   int length, long long position)
{

  DBUG_ENTER("ha_spartan::update_row");
  /*
    Begin critical section by locking the spartan mutex variable.
  */
  mysql_mutex_lock(&share->mutex);
  share->data_class->update_row((uchar *)old_data, new_data,
                 table->s->rec_buff_length, current_position -
                 share->data_class->row_size(table->s->rec_buff_length));
  /*
    End section by unlocking the spartan mutex variable.
  */
  mysql_mutex_unlock(&share->mutex);
  DBUG_RETURN(0);
 }
```

`delete_row()`方法类似于更新方法。在这种情况下，我们调用`Spartan_data`类中的`delete_row()`方法，传入要删除的行的缓冲区、记录缓冲区的长度以及当前位置的`-1`来强制表扫描。数据类方法再次为您完成了所有繁重的工作。清单 10-30 显示了修改后的更新方法。

[***清单 10-30。***](#_list30) 修改 ha_spartan.cc 中的 delete_row()方法

```sql
int ha_spartan::update_row(const uchar *old_data, uchar *new_data)
{

  DBUG_ENTER("ha_spartan::update_row");
  /*
    Begin critical section by locking the spartan mutex variable.
  */
  mysql_mutex_lock(&share->mutex);
  share->data_class->update_row((uchar *)old_data, new_data,
                 table->s->rec_buff_length, current_position -
                 share->data_class->row_size(table->s->rec_buff_length));
  /*
    End section by unlocking the spartan mutex variable.
  */
  mysql_mutex_unlock(&share->mutex);
  DBUG_RETURN(0);
}
```

你需要更新的最后一个方法是`delete_all_rows()` 。这将删除表中的所有数据。最简单的方法是删除数据文件并重新创建它。`Spartan_data`类的做法略有不同。`trunc_table()`方法将文件指针重置到文件的开头，并使用`my_chsize()`方法截断文件。清单 10-31 显示了修改后的更新方法。

[***清单 10-31。***](#_list31) 修改 ha_spartan.cc 中的 delete_all_rows()方法

```sql
int ha_spartan::delete_all_rows()
{
  DBUG_ENTER("ha_spartan::delete_all_rows");
  /*
    Begin critical section by locking the spartan mutex variable.
  */
  mysql_mutex_lock(&share->mutex);
  share->data_class->trunc_table();
  /*
    End section by unlocking the spartan mutex variable.
  */
  mysql_mutex_unlock(&share->mutex);
  DBUG_RETURN(0);
}
```

现在编译服务器并调试任何错误。完成后，你就有了一个完整的第四阶段引擎。剩下要做的就是编译服务器并运行测试。

测试斯巴达发动机的第 4 阶段

首先，验证 Stage 3 引擎中的一切都工作正常，然后继续测试更新和删除操作。当您再次运行测试时，您应该看到所有语句都成功完成。

更新和删除测试要求您创建一个表，并在其中包含数据。您可以像以前一样使用普通的`INSERT`语句添加数据。您可以随意添加自己的数据，并在表格中再添加几行。

当表中有一些数据时，选择其中一条记录，并使用类似下面的命令对其发出更新命令:

```sql
UPDATE t1 SET col_b = "Updated!" WHERE col_a = 1;
```

当您运行该命令后接一个`SELECT *`命令时，您应该看到该行被更新。然后，您可以通过发出 delete 命令来删除行，例如:

```sql
DELETE FROM t1 WHERE col_a = 3;
```

当您运行该命令后接一个`SELECT *`命令时，您应该看到该行已经被删除。这个命令序列将产生的结果的一个例子是:。

```sql
mysql> DELETE FROM t1 WHERE col_a = 3;
Query OK, 1 row affected (0.01 sec)

mysql> SELECT * FROM t1;
+−−-----+−−-----------+−−-----+
| col_a | col_b       | col_c |
+−−-----+−−-----------+−−-----+
|     4 | second test |    43 |
|     4 | tenth test  |    11 |
|     5 | Updated!    |   100 |
+−−-----+−−-----------+−−-----+
3 rows in set (0.00 sec)

mysql>
```

我们错过了什么吗？精明的软件开发者可能会注意到这个测试并不全面，也没有涵盖`Spartan_data`类必须考虑的所有可能性。例如，删除数据中间的一行不同于删除文件开头或结尾的一行。更新数据也是一样。

这没关系，因为您可以将该功能添加到测试文件中。您可以添加更多的`INSERT`语句来添加更多的数据，然后更新第一行和最后一行以及中间的一行。您可以对删除操作进行同样的操作。[清单 10-32](#list32) 显示了更新后的`Ch10s4.test`文件。

[***清单 10-32。***](#_list32) 更新了斯巴达-存储-引擎测试文件(Ch10s4.test)

```sql
#
# Simple test for the Spartan storage engine
#
--disable_warnings
drop table if exists t1;
--enable_warnings

CREATE TABLE t1 (
  col_a int,
  col_b varchar(20),
  col_c int
) ENGINE=SPARTAN;

SELECT * FROM t1;
INSERT INTO t1 VALUES(1, ìfirst testî, 24);
INSERT INTO t1 VALUES(4, ìsecond testî, 43);
INSERT INTO t1 VALUES(3, ìfourth testî, -2);
INSERT INTO t1 VALUES(4, ìtenth testî, 11);
INSERT INTO t1 VALUES(1, ìseventh testî, 20);
INSERT INTO t1 VALUES(5, ìthird testî, 100);
SELECT * FROM t1;
UPDATE t1 SET col_b = ìUpdated!î WHERE col_a = 1;
SELECT * from t1;
UPDATE t1 SET col_b = ìUpdated!î WHERE col_a = 3;
SELECT * from t1;
UPDATE t1 SET col_b = ìUpdated!î WHERE col_a = 5;
SELECT * from t1;
DELETE FROM t1 WHERE col_a = 1;
SELECT * FROM t1;
DELETE FROM t1 WHERE col_a = 3;
SELECT * FROM t1;
DELETE FROM t1 WHERE col_a = 5;
SELECT * FROM t1;
RENAME TABLE t1 TO t2;
SELECT * FROM t2;
DROP TABLE t2;
```

请注意，我添加了一些具有重复值的行。您应该预料到服务器会更新并删除重复行的所有匹配项。运行该测试，看看它会做什么。清单 10-33 显示了这个测试的预期结果的一个例子。当您在测试套件下运行测试时，它应该没有错误地完成。

[***清单 10-33。***](#_list33) 第四阶段测试的样本结果

```sql
mysql> INSTALL PLUGIN spartan SONAME 'ha_spartan.so';
Query OK, 0 rows affected (0.01 sec)

mysql> use test;
Database changed
mysql>
mysql> CREATE TABLE t1 (
    ->   col_a int,
    ->   col_b varchar(20),
    ->   col_c int
    -> ) ENGINE=SPARTAN;
Query OK, 0 rows affected (0.01 sec)

mysql>
mysql> SELECT * FROM t1;
Empty set (0.00 sec)

mysql> INSERT INTO t1 VALUES(1, "first test", 24);
Query OK, 1 row affected (0.00 sec)

mysql> INSERT INTO t1 VALUES(4, "second test", 43);
Query OK, 1 row affected (0.00 sec)

mysql> INSERT INTO t1 VALUES(3, "fourth test", -2);
Query OK, 1 row affected (0.00 sec)

mysql> INSERT INTO t1 VALUES(4, "tenth test", 11);
Query OK, 1 row affected (0.00 sec)

mysql> INSERT INTO t1 VALUES(1, "seventh test", 20);
Query OK, 1 row affected (0.00 sec)

mysql> INSERT INTO t1 VALUES(5, "third test", 100);
Query OK, 1 row affected (0.00 sec)

mysql> SELECT * FROM t1;
+−−-----+−−------------+−−-----+
| col_a | col_b        | col_c |
+−−-----+−−------------+−−-----+
|     1 | first test   |    24 |
|     4 | second test  |    43 |
|     3 | fourth test  |    -2 |
|     4 | tenth test   |    11 |
|     1 | seventh test |    20 |
|     5 | third test   |   100 |
+−−-----+−−------------+−−-----+
6 rows in set (0.00 sec)

mysql> UPDATE t1 SET col_b = "Updated!" WHERE col_a = 1;
Query OK, 2 rows affected (0.00 sec)
Rows matched: 2  Changed: 2  Warnings: 0

mysql> SELECT * from t1;
+−−-----+−−-----------+−−-----+
| col_a | col_b       | col_c |
+−−-----+−−-----------+−−-----+
|     1 | Updated!    |    24 |
|     4 | second test |    43 |
|     3 | fourth test |    -2 |
|     4 | tenth test  |    11 |
|     1 | Updated!    |    20 |
|     5 | third test  |   100 |
+−−-----+−−-----------+−−-----+
6 rows in set (0.00 sec)

mysql> UPDATE t1 SET col_b = "Updated!" WHERE col_a = 3;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> SELECT * from t1;
+−−-----+−−-----------+−−-----+
| col_a | col_b       | col_c |
+−−-----+−−-----------+−−-----+
|     1 | Updated!    |    24 |
|     4 | second test |    43 |
|     3 | Updated!    |    -2 |
|     4 | tenth test  |    11 |
|     1 | Updated!    |    20 |
|     5 | third test  |   100 |
+−−-----+−−-----------+−−-----+
6 rows in set (0.01 sec)

mysql> UPDATE t1 SET col_b = "Updated!" WHERE col_a = 5;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> SELECT * from t1;
+−−-----+−−-----------+−−-----+
| col_a | col_b       | col_c |
+−−-----+−−-----------+−−-----+
|     1 | Updated!    |    24 |
|     4 | second test |    43 |
|     3 | Updated!    |    -2 |
|     4 | tenth test  |    11 |
|     1 | Updated!    |    20 |
|     5 | Updated!    |   100 |
+−−-----+−−-----------+−−-----+
6 rows in set (0.00 sec)

mysql> DELETE FROM t1 WHERE col_a = 1;
Query OK, 2 rows affected (0.00 sec)

mysql> SELECT * FROM t1;
+−−-----+−−-----------+−−-----+
| col_a | col_b       | col_c |
+−−-----+−−-----------+−−-----+
|     4 | second test |    43 |
|     3 | Updated!    |    -2 |
|     4 | tenth test  |    11 |
|     5 | Updated!    |   100 |
+−−-----+−−-----------+−−-----+
4 rows in set (0.00 sec)

mysql> DELETE FROM t1 WHERE col_a = 3;
Query OK, 1 row affected (0.01 sec)

mysql> SELECT * FROM t1;
+−−-----+−−-----------+−−-----+
| col_a | col_b       | col_c |
+−−-----+−−-----------+−−-----+
|     4 | second test |    43 |
|     4 | tenth test  |    11 |
|     5 | Updated!    |   100 |
+−−-----+−−-----------+−−-----+
3 rows in set (0.00 sec)

mysql> DELETE FROM t1 WHERE col_a = 5;
Query OK, 1 row affected (0.00 sec)

mysql> SELECT * FROM t1;
+−−-----+−−-----------+−−-----+
| col_a | col_b       | col_c |
+−−-----+−−-----------+−−-----+
|     4 | second test |    43 |
|     4 | tenth test  |    11 |
+−−-----+−−-----------+−−-----+
2 rows in set (0.00 sec)

mysql> RENAME TABLE t1 TO t2;
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT * FROM t2;
+−−-----+−−-----------+−−-----+
| col_a | col_b       | col_c |
+−−-----+−−-----------+−−-----+
|     4 | second test |    43 |
|     4 | tenth test  |    11 |
+−−-----+−−-----------+−−-----+
2 rows in set (0.00 sec)

mysql> DROP TABLE t2;
Query OK, 0 rows affected (0.00 sec)

mysql>
```

这就是四级发动机。它现在是一个基本的读/写/更新/删除存储引擎。在下一阶段，我们将添加 index 类来提高查询效率。

阶段 5:索引数据

这个阶段的目标是产生一个工作的存储引擎，它包括对单个索引的支持(只需做一点工作，您就可以让它拥有多个索引)。在这个阶段，我将向您展示如何结合`Spartan_index`类来索引数据。需要做出许多改变。我建议在开始跟随变化之前通读这一部分。

首先将`Spartan_index`类文件添加到 CMakeLists.txt 文件中，如下所示。

```sql
# Spartan storage engine plugin

SET(SPARTAN_PLUGIN_STATIC "spartan")
SET(SPARTAN_PLUGIN_DYNAMIC "spartan")

SET(SPARTAN_SOURCES
   ha_spartan.cc ha_spartan.h
   spartan_data.cc spartan_data.h
   spartan_index.cc spartan_index.h
)

MYSQL_ADD_PLUGIN(spartan ${SPARTAN_SOURCES} STORAGE_ENGINE MODULE_ONLY)

TARGET_LINK_LIBRARIES(spartan mysys)
```

`Spartan_index`类通过保存指向`Spartan_data`类中相应行的记录指针来工作。当服务器通过主键搜索记录时，它可以使用`Spartan_index`类找到记录指针，然后通过`Spartan_data`类发出直接读取调用来直接访问记录。这使得读取随机记录的过程比执行表扫描快得多。

本节中的源代码设计用于最基本的索引操作。根据您的查询变得有多复杂，这些更改应该足以满足大多数情况。我将带您了解每个变更，并包括每个变更的完整方法源代码。

更新斯巴达源文件

`Spartan_index`类只是保存文件的当前位置和键。您需要更新的`ha_spartan.cc`中的方法包括`index_read()`、`index_read_idx()`、`index_next()`、`index_prev()`、`index_first()`和`index_last()`。这些方法从索引中读取值并遍历索引，以及转到索引的前面和后面(开始，结束)。幸运的是，`Spartan_index`类提供了所有这些操作。

更新头文件

要使用 index 类，首先在`ha_spartan.h`头文件中添加对`spartan_index.h`文件的引用。[清单 10-34](#list34) 显示了完整的代码变更(为了简洁，我省略了注释)。一旦你做了这个改变，重新编译`spartan`源文件以确保没有任何错误。

[***清单 10-34。***](#_list34) 修改为 ha_spartan.h 中的 Spartan_share 类

```sql
#include "my_global.h"                   /* ulonglong */
#include "thr_lock.h"                    /* THR_LOCK, THR_LOCK_DATA */
#include "handler.h"                     /* handler */
#include "spartan_data.h"
#include "spartan_index.h"

class Spartan_share : public Handler_share {
public:
  mysql_mutex_t mutex;
  THR_LOCK lock;
  Spartan_data *data_class;
  Spartan_index *index_class;
  Spartan_share();
  ∼Spartan_share()
  {
    thr_lock_delete(&lock);
    mysql_mutex_destroy(&mutex);
    if (data_class != NULL)
      delete data_class;
    data_class = NULL;
    if (index_class != NULL)
      delete index_class;
    index_class = NULL;
  }
};
...
```

打开`ha_spartan.h`文件并添加`#include`指令以包含`spartan_index.h`头文件，如上所示。

完成后，打开 ha_spartan.cc 文件，将索引类初始化添加到构造函数中..清单 10-35 显示了完整的代码变更。一旦你做了这个改变，重新编译`spartan`源文件以确保没有任何错误。

[***清单 10-35。***](#_list35) 更改 ha_spartan.cc 中的 Spartan_data 构造函数

```sql
Spartan_share::Spartan_share()
{
  thr_lock_init(&lock);
  mysql_mutex_init(ex_key_mutex_Spartan_share_mutex,
                   &mutex, MY_MUTEX_INIT_FAST);
  data_class = new Spartan_data();
  index_class = new Spartan_index();
}
```

当头文件打开时，您需要做一些其他的修改。您必须添加标志来告诉优化器支持哪些索引操作。您还必须设置索引参数的界限:支持的最大键数、键的最大长度和最大键部分。在此阶段，如[清单 10-36](#list36) 所示设置参数。我已经包含了您需要对文件进行的全部更改。注意`table_flags()`方法。这是您告诉优化器存储引擎有什么限制的地方。我已经将引擎设置为不允许 BLOBs，也不允许自动递增字段。这些标志的完整列表可在`handler.h`中找到。

[***清单 10-36。***](#_list36) 对 ha_spartan.h 中 ha_spartan 类定义的修改

```sql
  /*
    The name of the index type that will be used for display
    don't implement this method unless you really have indexes
   */
  const char *index_type(uint inx) { return "Spartan_index"; }
  /*
    The file extensions.
  */
  const char **bas_ext() const;
  /*
    This is a list of flags that says what the storage engine
    implements. The current table flags are documented in
    handler.h
  */
  ulonglong table_flags() const
  {
    return (HA_NO_BLOBS | HA_NO_AUTO_INCREMENT | HA_BINLOG_STMT_CAPABLE);
  }
  /*
    This is a bitmap of flags that says how the storage engine
    implements indexes. The current index flags are documented in
    handler.h. If you do not implement indexes, just return zero
    here.

    part is the key part to check. First key part is 0
    If all_parts it's set, MySQL want to know the flags for the combined
    index up to and including 'part'.
  */
  ulong index_flags(uint inx, uint part, bool all_parts) const
  {
    return (HA_READ_NEXT | HA_READ_PREV | HA_READ_RANGE |
            HA_READ_ORDER | HA_KEYREAD_ONLY);
  }
  /*
    unireg.cc will call the following to make sure that the storage engine can
    handle the data it is about to send.

    Return *real* limits of your storage engine here. MySQL will do
    min(your_limits, MySQL_limits) automatically

    There is no need to implement ..._key_... methods if you don't suport
    indexes.
  */
  uint max_supported_keys()          const { return 1; }
  uint max_supported_key_parts()     const { return 1; }
  uint max_supported_key_length()    const { return 128; }
```

如果您在一个用 Spartan 引擎创建的表上执行 SHOW INDEXES FROM 命令，您将会看到上述代码更改的结果，如清单 10-37 所示。请注意输出中报告的索引类型。

[***清单 10-37。***](#_list37) 显示指标输出的例子

```sql
mysql> show indexes from test.t1 \G
*************************** 1\. row ***************************
        Table: t1
   Non_unique: 0
     Key_name: PRIMARY
 Seq_in_index: 1
  Column_name: col_a
    Collation: A
  Cardinality: NULL
     Sub_part: NULL
       Packed: NULL
         Null:
   Index_type: Spartan_index
      Comment:
Index_comment:
1 row in set (0.00 sec)
```

最后需要补充一点。识别记录中的键很容易，但不是很直观。为了使事情更容易处理，我编写了两个助手方法:`get_key()`，它查找键字段并返回其值，如果没有键，则返回 0；以及`get_key_len()`，它返回键的长度。将它们的定义添加到类头文件中(`ha_spartan.h`):

```sql
uchar *get_key();
int get_key_len();
```

您将在`ha_spartan.cc`类文件中实现这些方法。

更新类文件

现在是编译和检查错误的好时机。完成后，开始修改索引方法。

首先，回顾 open、create、close、write、update、delete 和 rename 方法，并添加对 index 类的调用来维护索引。完成这项工作的代码包括识别作为键的字段，然后将键及其位置保存到索引中，以便以后检索。

open 方法必须同时打开数据和索引文件。唯一的额外步骤是将索引加载到内存中。在类文件中找到`open()`方法，并添加对 index 类的调用，以打开索引并将索引加载到内存中。清单 10-38 显示了修改后的方法。

[***清单 10-38。***](#_list38) 对 ha_spartan.cc 中 open()方法的修改

```sql
int ha_spartan::open(const char *name, int mode, uint test_if_locked)
{
  DBUG_ENTER("ha_spartan::open");
  char name_buff[FN_REFLEN];

  if (!(share = get_share()))
    DBUG_RETURN(1);
  /*
    Call the data class open table method.
    Note: the fn_format() method correctly creates a file name from the
    name passed into the method.
  */
  share->data_class->open_table(fn_format(name_buff, name, "", SDE_EXT,
                                MY_REPLACE_EXT|MY_UNPACK_FILENAME));
  share->index_class->open_index(fn_format(name_buff, name, "", SDI_EXT,
                                MY_REPLACE_EXT|MY_UNPACK_FILENAME));
  share->index_class->load_index();
  thr_lock_data_init(&share->lock,&lock,NULL);
  DBUG_RETURN(0);
}
```

create 方法必须同时创建数据和索引文件。在类文件中找到`create()`方法，并添加对 index 类的调用以创建索引。清单 10-39 显示了修改后的方法。

[***清单 10-39。***](#_list39) 对 ha_spartan.cc 中 create()方法的修改

```sql
int ha_spartan::create(const char *name, TABLE *table_arg,
                       HA_CREATE_INFO *create_info)
{
  DBUG_ENTER("ha_spartan::create");
  char name_buff[FN_REFLEN];
  char name_buff2[FN_REFLEN];

  if (!(share = get_share()))
    DBUG_RETURN(1);
  /*
    Call the data class create table method.
    Note: the fn_format() method correctly creates a file name from the
    name passed into the method.
  */
  if (share->data_class->create_table(fn_format(name_buff, name, "", SDE_EXT,
                                      MY_REPLACE_EXT|MY_UNPACK_FILENAME)))
    DBUG_RETURN(−1);
   share->data_class->close_table();
   if (share->index_class->create_index(fn_format(name_buff2, name, "", SDI_EXT,
                                      MY_REPLACE_EXT|MY_UNPACK_FILENAME),
                                      128))
  {
     DBUG_RETURN(−1);
  }
  share->index_class->close_index();
  DBUG_RETURN(0);
}
```

close 方法必须同时关闭数据和索引文件。由于 index 类使用内存中的结构来存储所有更改，因此必须将其写回磁盘。在类文件中找到`close()`方法，并添加对 index 类的调用，用于保存、销毁内存结构和关闭索引。[清单 10-40](#list40) 显示了修改后的方法。

[***清单 10-40。***](#_list40) 对 ha_spartan.cc 中 close()方法的修改

```sql
int ha_spartan::close(void)
{
  DBUG_ENTER("ha_spartan::close");
  share->data_class->close_table();
  share->index_class->save_index();
  share->index_class->destroy_index();
  share->index_class->close_index();
  DBUG_RETURN(0);
 }
```

现在让我们改变写作和阅读方法。因为有可能不使用任何键，所以该方法必须检查是否有要添加的键。为了使事情更容易处理，我编写了两个助手方法:`get_key()`，它查找键字段并返回其值，如果没有键，则返回 0；以及`get_key_len()`，它返回键的长度。[清单 10-41](#list41) 展示了这两个助手方法。现在将这些方法添加到`ha_spartan.cc`文件中。

[***列举 10-41。***](#_list41) 附加辅助方法在 ha_spartan.cc 中

```sql
uchar *ha_spartan::get_key()
{
  uchar *key = 0;

  DBUG_ENTER("ha_spartan::get_key");
  /*
    For each field in the table, check to see if it is the key
    by checking the key_start variable. (1 = is a key).
  */
  for (Field **field=table->field ; *field ; field++)
  {
    if ((*field)->key_start.to_ulonglong() == 1)
    {
      /*
        Copy field value to key value (save key)
      */
      key = (uchar *)my_malloc((*field)->field_length,
                                  MYF(MY_ZEROFILL | MY_WME));
      memcpy(key, (*field)->ptr, (*field)->key_length());
    }
  }
  DBUG_RETURN(key);
}

int ha_spartan::get_key_len()
{
  int length = 0;

  DBUG_ENTER("ha_spartan::get_key");
  /*
    For each field in the table, check to see if it is the key
    by checking the key_start variable. (1 = is a key).
  */
  for (Field **field=table->field ; *field ; field++)
  {
    if ((*field)->key_start.to_ulonglong() == 1)
      /*
        Copy field length to key length
      */
      length = (*field)->key_length();
  }
  DBUG_RETURN(length);
}
```

write 方法必须将记录写入数据文件，并将键插入索引文件。在类文件中找到`write_row()`方法，并添加对 index 类的调用，以插入键(如果找到的话)。清单 10-42 显示了修改后的方法。

[***清单 10-42。***](#_list42) 对 ha_spartan.cc 中 write_row()方法的修改

```sql
int ha_spartan::write_row(uchar *buf)
{
  DBUG_ENTER("ha_spartan::write_row");
  long long pos;
  SDE_INDEX ndx;

  ha_statistic_increment(&SSV::ha_write_count);
  /*
    Begin critical section by locking the spartan mutex variable.
  */
  mysql_mutex_lock(&share->mutex);
  ndx.length = get_key_len();
  memcpy(ndx.key, get_key(), get_key_len());
  pos = share->data_class->write_row(buf, table->s->rec_buff_length);
  ndx.pos = pos;
  if ((ndx.key != 0) && (ndx.length != 0))
    share->index_class->insert_key(&ndx, false);
  /*
    End section by unlocking the spartan mutex variable.
  */
  mysql_mutex_unlock(&share->mutex);
  DBUG_RETURN(0);
}
```

更新方式也有点不同。它必须更改数据文件中的记录和索引中的键。因为索引使用内存结构，所以必须更改索引文件，将其保存到磁盘，然后重新加载。

![image](img/sq.jpg) **注意**精明的程序员会在代码中为`Spartan_index`注意到一些可以防止重载步骤的东西。你知道是什么吗？这里有一个提示:如果 index-class update 方法更新了键，然后在内存结构中重新定位它会怎么样？我将把那个实验留给你。进入索引代码并改进它。

在类文件中找到`update_row()`方法，并添加对 index 类的调用以更新键(如果找到的话)。清单 10-43 显示了修改后的方法。

[***清单 10-43。***](#_list43) 对 ha_spartan.cc 中 update_row()方法的修改

```sql
int ha_spartan::update_row(const uchar *old_data, uchar *new_data)
{

  DBUG_ENTER("ha_spartan::update_row");
  /*
    Begin critical section by locking the spartan mutex variable.
  */
  mysql_mutex_lock(&share->mutex);
  share->data_class->update_row((uchar *)old_data, new_data,
                 table->s->rec_buff_length, current_position -
                 share->data_class->row_size(table->s->rec_buff_length));
  if (get_key() != 0)
  {
    share->index_class->update_key(get_key(), current_position -
                   share->data_class->row_size(table->s->rec_buff_length),
                   get_key_len());
    share->index_class->save_index();
    share->index_class->load_index();
  }
  /*
    End section by unlocking the spartan mutex variable.
  */
  mysql_mutex_unlock(&share->mutex);
  DBUG_RETURN(0);
}
```

删除方法并不复杂。在这种情况下，该方法只需要删除数据行，并从内存结构中移除索引(如果找到的话)。在类文件中找到`delete_row()`方法，并添加对 index 类的调用以删除键(如果找到的话)。清单 10-44 显示了修改后的方法。

[***清单 10-44。***](#_list44) 修改 ha_spartan.cc 中的 delete_row()方法

```sql
int ha_spartan::delete_row(const uchar *buf)
{
  DBUG_ENTER("ha_spartan::delete_row");
  long long pos;

  if (current_position > 0)
    pos = current_position -
      share->data_class->row_size(table->s->rec_buff_length);
  else
    pos = 0;
  /*
    Begin critical section by locking the spartan mutex variable.
  */
  mysql_mutex_lock(&share->mutex);
  share->data_class->delete_row((uchar *)buf,
                                table->s->rec_buff_length, pos);
  if (get_key() != 0)
    share->index_class->delete_key(get_key(), pos, get_key_len());
  /*
    End section by unlocking the spartan mutex variable.
  */
  mysql_mutex_unlock(&share->mutex);
  DBUG_RETURN(0);
}
```

同样，删除所有行的方法也非常简单。在这种情况下，我们希望删除数据和索引文件中的所有数据。在类文件中找到`delete_all_rows()`方法，并添加对 index 类的调用，以销毁索引并截断索引文件。清单 10-45 显示了修改后的方法。

[***清单 10-45。***](#_list45) 修改 ha_spartan.cc 中的 delete_all_rows()方法

```sql
int ha_spartan::delete_all_rows()
{
  DBUG_ENTER("ha_spartan::delete_all_rows");
  /*
    Begin critical section by locking the spartan mutex variable.
  */
  mysql_mutex_lock(&share->mutex);
  share->data_class->trunc_table();
  share->index_class->destroy_index();
  share->index_class->trunc_index();
  /*
    End section by unlocking the spartan mutex variable.
  */
  mysql_mutex_unlock(&share->mutex);
  DBUG_RETURN(0);
}
```

`delete_table()`方法必须删除数据和索引文件。找到`delete_table()`方法并添加代码来调用`my_delete()`函数来删除索引。清单 10-46 显示了修改后的方法。

[***清单 10-46。***](#_list46) 修改 ha_spartan.cc 中的 delete_table()方法

```sql
int ha_spartan::delete_table(const char *name)
{
  DBUG_ENTER("ha_spartan::delete_table");
  char name_buff[FN_REFLEN];

  /*
    Call the mysql delete file method.
    Note: the fn_format() method correctly creates a file name from the
    name passed into the method.
  */
  my_delete(fn_format(name_buff, name, "", SDE_EXT,
            MY_REPLACE_EXT|MY_UNPACK_FILENAME), MYF(0));
  /*
    Call the mysql delete file method.
    Note: the fn_format() method correctly creates a file name from the
    name passed into the method.
  */
  my_delete(fn_format(name_buff, name, "", SDI_EXT,
            MY_REPLACE_EXT|MY_UNPACK_FILENAME), MYF(0));

  DBUG_RETURN(0);
}
```

对常规读写文件操作的最后一个更改是对`rename_table()`方法的更改。索引的`rename_table()`方法遵循与前面的更改相同的模式。在类文件中找到`rename_table()`方法，并添加代码来复制索引文件。清单 10-47 显示了修改后的方法。

[***清单 10-47。***](#_list47) 修改 ha_spartan.cc 中的 rename_table()方法

```sql
int ha_spartan::rename_table(const char * from, const char * to)
{
  DBUG_ENTER("ha_spartan::rename_table ");
  char data_from[FN_REFLEN];
  char data_to[FN_REFLEN];
  char index_from[FN_REFLEN];
  char index_to[FN_REFLEN];

  my_copy(fn_format(data_from, from, "", SDE_EXT,
          MY_REPLACE_EXT|MY_UNPACK_FILENAME),
          fn_format(data_to, to, "", SDE_EXT,
          MY_REPLACE_EXT|MY_UNPACK_FILENAME), MYF(0));
  my_copy(fn_format(index_from, from, "", SDI_EXT,
          MY_REPLACE_EXT|MY_UNPACK_FILENAME),
          fn_format(index_to, to, "", SDI_EXT,
          MY_REPLACE_EXT|MY_UNPACK_FILENAME), MYF(0));
  /*
    Delete the file using MySQL's delete file method.
  */
  my_delete(data_from, MYF(0));
  my_delete(index_from, MYF(0));

  DBUG_RETURN(0);
}
```

哇哦！变化真大。如您所见，支持索引使得代码变得更加复杂。我希望您现在能更好地理解 MySQL 中现有的存储引擎是如何构建的。现在，让我们继续对索引方法进行更改。

必须实现几种方法来完成第 5 阶段存储引擎的索引机制。请注意，在使用这些方法时，有些方法根据传入的索引从数据文件中返回一行，而有些方法返回一个键。文档对此并不清楚，参数的名称也没有给我们多少线索，但是我会向您展示它们是如何使用的。这些方法必须返回未找到的键或文件结束返回代码。注意正确编写这些 return 语句，否则您可能会遇到一些奇怪的查询结果。

第一种方法是`index_read_map()`法。这会将行缓冲区设置为文件中与传入的键相匹配的行。如果传入的键为 null，该方法应该返回文件中的第一个键值。找到`index_read_map()`方法，添加代码从索引中获取文件位置，并从数据文件中读取相应的行。清单 10-48 显示了修改后的方法。

[***清单 10-48。***](#_list48) 更改 ha_spartan.cc 中的 index_read_map()方法

```sql
int ha_spartan::index_read_map(uchar *buf, const uchar *key,
                               key_part_map keypart_map __attribute__((unused)),
                               enum ha_rkey_function find_flag
                               __attribute__((unused)))
{
  int rc;
  long long pos;
  DBUG_ENTER("ha_spartan::index_read");
  MYSQL_INDEX_READ_ROW_START(table_share->db.str, table_share->table_name.str);
  if (key == NULL)
    pos = share->index_class->get_first_pos();
  else
    pos = share->index_class->get_index_pos((uchar *)key, keypart_map);
  if (pos == −1)
    DBUG_RETURN(HA_ERR_KEY_NOT_FOUND);
  current_position = pos + share->data_class->row_size(table->s->rec_buff_length);
  rc = share->data_class->read_row(buf, table->s->rec_buff_length, pos);
  share->index_class->get_next_key();
  MYSQL_INDEX_READ_ROW_DONE(rc);
  DBUG_RETURN(rc);
}
```

接下来的索引方法是`index_next()`。此方法获取索引中的下一个键，并从数据文件中返回匹配的行。它在范围索引扫描期间被调用。找到`index_next()`方法，添加代码从索引中获取下一个键，并从数据文件中读取一行。清单 10-49 显示了修改后的方法。

[***清单 10-49。***](#_list49) 更改 ha_spartan.cc 中的 index_next()方法

```sql
int ha_spartan::index_next(uchar *buf)
{
  int rc;
  uchar *key = 0;
  long long pos;

  DBUG_ENTER("ha_spartan::index_next");
  MYSQL_INDEX_READ_ROW_START(table_share->db.str, table_share->table_name.str);
  key = share->index_class->get_next_key();
  if (key == 0)
    DBUG_RETURN(HA_ERR_END_OF_FILE);
  pos = share->index_class->get_index_pos((uchar *)key, get_key_len());
  share->index_class->seek_index(key, get_key_len());
  share->index_class->get_next_key();
  if (pos == −1)
    DBUG_RETURN(HA_ERR_KEY_NOT_FOUND);
  rc = share->data_class->read_row(buf, table->s->rec_buff_length, pos);
  MYSQL_INDEX_READ_ROW_DONE(rc);
  DBUG_RETURN(rc);
}
```

下一个索引方法也是一个范围查询。`index_prev()`方法获取索引中的前一个键，并从数据文件中返回匹配的行。它在范围索引扫描期间被调用。找到`index_prev()`方法，添加代码以从索引中获取前一个键，并从数据文件中读取一行。清单 10-50 显示了修改后的方法。

[***清单 10-50。***](#_list50) 对 ha_spartan.cc 中 index_prev()方法的修改

```sql
int ha_spartan::index_prev(uchar *buf)
{
  int rc;
  uchar *key = 0;
  long long pos;

  DBUG_ENTER("ha_spartan::index_prev");
  MYSQL_INDEX_READ_ROW_START(table_share->db.str, table_share->table_name.str);
  key = share->index_class->get_prev_key();
  if (key == 0)
    DBUG_RETURN(HA_ERR_END_OF_FILE);
  pos = share->index_class->get_index_pos((uchar *)key, get_key_len());
  share->index_class->seek_index(key, get_key_len());
  share->index_class->get_prev_key();
  if (pos == −1)
    DBUG_RETURN(HA_ERR_KEY_NOT_FOUND);
  rc = share->data_class->read_row(buf, table->s->rec_buff_length, pos);
  MYSQL_INDEX_READ_ROW_DONE(rc);
  DBUG_RETURN(rc);
}
```

请注意，我不得不稍微移动一下索引指针，以使下一个和上一个代码能够工作。第一次使用 index 类时，范围查询会生成对它的两个调用:第一个调用获取第一个键(`index_read`)，然后第二个调用下一个键(`index_next`)。随后对`index_next()`进行索引调用。因此，我必须调用`Spartan_index`类方法`get_prev_key()`来正确重置键。这将是重新设计 index 类以更好地处理 MySQL 中的范围查询的又一个好机会。

下一个索引方法也是一个范围查询。方法获取索引中的第一个键并返回它。找到`index_first()`方法，添加代码以从索引中获取第一个键并返回该键。清单 10-51 显示了修改后的方法。

[***清单 10-51。***](#_list51) 更改 ha_spartan.cc 中的 index_first()方法

```sql
int ha_spartan::index_first(uchar *buf)
{
  int rc;
  uchar *key = 0;
  DBUG_ENTER("ha_spartan::index_first");
  MYSQL_INDEX_READ_ROW_START(table_share->db.str, table_share->table_name.str);
  key = share->index_class->get_first_key();
  if (key == 0)
    DBUG_RETURN(HA_ERR_END_OF_FILE);
  else
    rc = 0;
  memcpy(buf, key, get_key_len());
  MYSQL_INDEX_READ_ROW_DONE(rc);
  DBUG_RETURN(rc);
}
```

最后一个索引方法也是范围查询之一。方法获取索引中的最后一个键并返回它。找到`index_last()`方法并添加代码以从索引中获取最后一个键并返回该键。清单 10-52 显示了修改后的方法。

[***清单 10-52。***](#_list52) 对 ha_spartan.cc 中 index_last()方法的修改

```sql
int ha_spartan::index_last(uchar *buf)
{
  int rc;
  uchar *key = 0;

  DBUG_ENTER("ha_spartan::index_last");
  MYSQL_INDEX_READ_ROW_START(table_share->db.str, table_share->table_name.str);
  key = share->index_class->get_last_key();
  if (key == 0)
    DBUG_RETURN(HA_ERR_END_OF_FILE);
  else
    rc = 0;
  memcpy(buf, key, get_key_len());
  MYSQL_INDEX_READ_ROW_DONE(rc);
  DBUG_RETURN(rc);
}

```

现在编译服务器并调试任何错误。完成后，你将拥有一个完整的第五阶段引擎。剩下要做的就是编译服务器并运行测试。

如果您决定调试 Spartan 存储引擎代码，您可能会在调试期间注意到一些索引方法可能没有被调用。这是因为索引方法在优化器中有多种用途。调用的顺序在很大程度上取决于优化器做出的选择。如果你很好奇(像我一样)，想看看每个方法是如何工作的，你需要创建一个更大的数据集，并执行更复杂的查询。您还可以查看源代码和参考手册，以了解 handler 类中支持的每个方法的更多详细信息。

测试斯巴达发动机的第五阶段

当您再次运行测试时，您应该看到所有语句都成功完成。验证 Stage 4 引擎中的一切都工作正常，然后继续测试索引操作。

索引测试将要求您创建一个表，并在其中包含数据。您可以像以前一样使用普通的`INSERT`语句添加数据。现在您需要测试索引。输入一个在索引列(`col_a`)上有一个`WHERE`子句的命令，例如:

```sql
SELECT * FROM t1 WHERE col_a = 2;
```

当您运行该命令时，应该会看到返回的行。那不是很有趣，是吗？你已经做了所有的工作，它只是返回行。了解索引是否有效的最好方法是拥有包含各种索引值的大型数据表。这需要一段时间，我鼓励你这样做。

还有一个办法。您可以启动服务器，在源代码中附加断点(使用调试器)，并发出基于索引的查询。这听起来像是大量的工作，您可能没有时间运行，但有几个例子。这很好，因为您可以将该功能添加到测试文件中。您可以将键列添加到`CREATE`中，并添加更多带有`WHERE`子句的`SELECT`语句来执行点和范围查询。[清单 10-53](#list53) 显示了更新后的`Ch10s5.test`文件。

[***清单 10-53。***](#_list53) 更新了斯巴达存储引擎测试文件(Ch10s5.test)

```sql
#
# Simple test for the Spartan storage engine
#
--disable_warnings
drop table if exists t1;
--enable_warnings

CREATE TABLE t1 (
  col_a int KEY,
  col_b varchar(20),
  col_c int
) ENGINE=SPARTAN;

INSERT INTO t1 VALUES (1, "first test", 24);
INSERT INTO t1 VALUES (2, "second test", 43);
INSERT INTO t1 VALUES (9, "fourth test", -2);
INSERT INTO t1 VALUES (3, 'eighth test', -22);
INSERT INTO t1 VALUES (4, "tenth test", 11);
INSERT INTO t1 VALUES (8, "seventh test", 20);
INSERT INTO t1 VALUES (5, "third test", 100);
SELECT * FROM t1;
UPDATE t1 SET col_b = "Updated!" WHERE col_a = 1;
SELECT * from t1;
UPDATE t1 SET col_b = "Updated!" WHERE col_a = 3;
SELECT * from t1;
UPDATE t1 SET col_b = "Updated!" WHERE col_a = 5;
SELECT * from t1;
DELETE FROM t1 WHERE col_a = 1;
SELECT * FROM t1;
DELETE FROM t1 WHERE col_a = 3;
SELECT * FROM t1;
DELETE FROM t1 WHERE col_a = 5;
SELECT * FROM t1;
SELECT * FROM t1 WHERE col_a = 4;
SELECT * FROM t1 WHERE col_a >= 2 AND col_a <= 5;
SELECT * FROM t1 WHERE col_a = 22;
DELETE FROM t1 WHERE col_a = 5;
SELECT * FROM t1;
SELECT * FROM t1 WHERE col_a = 5;
UPDATE t1 SET col_a = 99 WHERE col_a = 8;
SELECT * FROM t1 WHERE col_a = 8;
SELECT * FROM t1 WHERE col_a = 99;
RENAME TABLE t1 TO t2;
SELECT * FROM t2;
DROP TABLE t2;

```

请注意，我已经更改了一些`INSERT`语句，以使索引方法能够工作。运行该测试，看看它会做什么。清单 10-54 显示了这个测试的预期结果的一个例子。当您在测试套件下运行测试时，它应该没有错误地完成。

[***清单 10-54。***](#_list54) 第五阶段测试的样本结果

```sql
mysql> INSTALL PLUGIN spartan SONAME 'ha_spartan.so';
Query OK, 0 rows affected (0.01 sec)

mysql> use test;
Database changed
mysql> CREATE TABLE t1 (col_a int, col_b varchar(20), col_c int) ENGINE=SPARTAN;
Query OK, 0 rows affected (0.04 sec)

mysql> INSERT INTO t1 VALUES (1, "first test", 24);
Query OK, 1 row affected (0.00 sec)

mysql> INSERT INTO t1 VALUES (2, "second test", 43);
Query OK, 1 row affected (0.00 sec)

mysql> INSERT INTO t1 VALUES (9, "fourth test", -2);
Query OK, 1 row affected (0.00 sec)

mysql> INSERT INTO t1 VALUES (3, 'eighth test', -22);
Query OK, 1 row affected (0.00 sec)

mysql> INSERT INTO t1 VALUES (4, "tenth test", 11);
Query OK, 1 row affected (0.01 sec)

mysql> INSERT INTO t1 VALUES (8, "seventh test", 20);
Query OK, 1 row affected (0.00 sec)

mysql> INSERT INTO t1 VALUES (5, "third test", 100);
Query OK, 1 row affected (0.01 sec)

mysql> SELECT * FROM t1;
+−−-----+−−------------+−−-----+
| col_a | col_b        | col_c |
+−−-----+−−------------+−−-----+
|     1 | first test   |    24 |
|     2 | second test  |    43 |
|     9 | fourth test  |    -2 |
|     3 | eighth test  |   -22 |
|     4 | tenth test   |    11 |
|     8 | seventh test |    20 |
|     5 | third test   |   100 |
+−−-----+−−------------+−−-----+
7 rows in set (0.00 sec)

mysql> UPDATE t1 SET col_b = "Updated!" WHERE col_a = 1;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> SELECT * from t1;
+−−-----+−−------------+−−-----+
| col_a | col_b        | col_c |
+−−-----+−−------------+−−-----+
|     1 | Updated!     |    24 |
|     2 | second test  |    43 |
|     9 | fourth test  |    -2 |
|     3 | eighth test  |   -22 |
|     4 | tenth test   |    11 |
|     8 | seventh test |    20 |
|     5 | third test   |   100 |
+−−-----+−−------------+−−-----+
7 rows in set (0.00 sec)

mysql> UPDATE t1 SET col_b = "Updated!" WHERE col_a = 3;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> SELECT * from t1;
+−−-----+−−------------+−−-----+
| col_a | col_b        | col_c |
+−−-----+−−------------+−−-----+
|     1 | Updated!     |    24 |
|     2 | second test  |    43 |
|     9 | fourth test  |    -2 |
|     3 | Updated!     |   -22 |
|     4 | tenth test   |    11 |
|     8 | seventh test |    20 |
|     5 | third test   |   100 |
+−−-----+−−------------+−−-----+
7 rows in set (0.01 sec)

mysql> UPDATE t1 SET col_b = "Updated!" WHERE col_a = 5;
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> SELECT * from t1;
+−−-----+−−------------+−−-----+
| col_a | col_b        | col_c |
+−−-----+−−------------+−−-----+
|     1 | Updated!     |    24 |
|     2 | second test  |    43 |
|     9 | fourth test  |    -2 |
|     3 | Updated!     |   -22 |
|     4 | tenth test   |    11 |
|     8 | seventh test |    20 |
|     5 | Updated!     |   100 |
+−−-----+−−------------+−−-----+
7 rows in set (0.00 sec)

mysql> DELETE FROM t1 WHERE col_a = 1;
Query OK, 1 row affected (0.01 sec)

mysql> SELECT * FROM t1;
+−−-----+−−------------+−−-----+
| col_a | col_b        | col_c |
+−−-----+−−------------+−−-----+
|     2 | second test  |    43 |
|     9 | fourth test  |    -2 |
|     3 | Updated!     |   -22 |
|     4 | tenth test   |    11 |
|     8 | seventh test |    20 |
|     5 | Updated!     |   100 |
+−−-----+−−------------+−−-----+
6 rows in set (0.00 sec)

mysql> DELETE FROM t1 WHERE col_a = 3;
Query OK, 1 row affected (0.00 sec)

mysql> SELECT * FROM t1;
+−−-----+−−------------+−−-----+
| col_a | col_b        | col_c |
+−−-----+−−------------+−−-----+
|     2 | second test  |    43 |
|     9 | fourth test  |    -2 |
|     4 | tenth test   |    11 |
|     8 | seventh test |    20 |
|     5 | Updated!     |   100 |
+−−-----+−−------------+−−-----+
5 rows in set (0.01 sec)

mysql> DELETE FROM t1 WHERE col_a = 5;
Query OK, 1 row affected (0.00 sec)

mysql> SELECT * FROM t1;
+−−-----+−−------------+−−-----+
| col_a | col_b        | col_c |
+−−-----+−−------------+−−-----+
|     2 | second test  |    43 |
|     9 | fourth test  |    -2 |
|     4 | tenth test   |    11 |
|     8 | seventh test |    20 |
+−−-----+−−------------+−−-----+
4 rows in set (0.00 sec)

mysql> SELECT * FROM t1 WHERE col_a = 4;
+−−-----+−−----------+−−-----+
| col_a | col_b      | col_c |
+−−-----+−−----------+−−-----+
|     4 | tenth test |    11 |
+−−-----+−−----------+−−-----+
1 row in set (0.01 sec)

mysql> SELECT * FROM t1 WHERE col_a >= 2 AND col_a <= 5;
+−−-----+−−-----------+−−-----+
| col_a | col_b       | col_c |
+−−-----+−−-----------+−−-----+
|     2 | second test |    43 |
|     4 | tenth test  |    11 |
+−−-----+−−-----------+−−-----+
2 rows in set (0.00 sec)

mysql> SELECT * FROM t1 WHERE col_a = 22;
Empty set (0.01 sec)

mysql> DELETE FROM t1 WHERE col_a = 5;
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT * FROM t1;
+−−-----+−−------------+−−-----+
| col_a | col_b        | col_c |
+−−-----+−−------------+−−-----+
|     2 | second test  |    43 |
|     9 | fourth test  |    -2 |
|     4 | tenth test   |    11 |
|     8 | seventh test |    20 |
+−−-----+−−------------+−−-----+
4 rows in set (0.00 sec)

mysql> SELECT * FROM t1 WHERE col_a = 5;
Empty set (0.00 sec)

mysql> UPDATE t1 SET col_a = 99 WHERE col_a = 8;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> SELECT * FROM t1 WHERE col_a = 8;
Empty set (0.01 sec)

mysql> SELECT * FROM t1 WHERE col_a = 99;
+−−-----+−−------------+−−-----+
| col_a | col_b        | col_c |
+−−-----+−−------------+−−-----+
|    99 | seventh test |    20 |
+−−-----+−−------------+−−-----+
1 row in set (0.00 sec)

mysql> RENAME TABLE t1 TO t2;
Query OK, 0 rows affected (0.01 sec)

mysql> SELECT * FROM t2;
+−−-----+−−------------+−−-----+
| col_a | col_b        | col_c |
+−−-----+−−------------+−−-----+
|     2 | second test  |    43 |
|     9 | fourth test  |    -2 |
|     4 | tenth test   |    11 |
|    99 | seventh test |    20 |
+−−-----+−−------------+−−-----+
4 rows in set (0.01 sec)

mysql> DROP TABLE t2;
Query OK, 0 rows affected (0.00 sec)

mysql>
```

这是第五阶段的引擎。它现在是一个基本的带索引的读/写/更新/删除存储引擎，这是 MySQL 中大多数存储引擎实现的阶段。事实上，对于除事务环境之外的所有环境，这应该足以满足您的存储需求。在下一阶段，我将讨论添加事务支持这一更加复杂的主题。

第六阶段:添加事务支持

目前，MySQL 中唯一支持事务的存储引擎是 InnoDB 。 [<sup>7</sup>](#Fn7) 事务提供了一种机制，允许一组操作作为单个原子操作来执行。例如，如果为一个银行机构建立一个数据库，从一个账户转移资金到另一个账户(从一个账户转移资金到另一个账户)的宏操作最好完全执行，不中断。事务允许将这些操作封装在一个原子操作中，如果在所有操作完成之前发生错误，该原子操作将取消任何更改，从而避免数据从一个表中删除，并且永远不会进入下一个表。清单 10-55 中显示了一组包含在事务命令中的 SQL 语句形式的示例操作。

[***清单 10-55。***](#_list55) 示例事务 SQL 命令

```sql
START TRANSACTION;
UPDATE SavingsAccount SET Balance = Balance—100
WHERE AccountNum = 123;
UPDATE CheckingAccount SET Balance = Balance + 100
WHERE AccountNum = 345;
COMMIT;
```

实际上，如果需要更快的访问速度，大多数数据库专业人员会指定 MyISAM 表类型,如果需要事务支持，则指定 InnoDB。幸运的是，Oracle 提供了支持事务的存储引擎插件。

`start_stmt()`和`external_lock()`方法支持在存储引擎中执行事务的功能。当一个事务开始时，调用`start_stmt()`方法。`external_lock()`方法用于通知表的特定锁，并在发出显式锁时调用。您的存储引擎必须通过创建一个保存点并使用`trans_register_ha()`方法向服务器注册事务，以`start_stmt()`方法实现新事务。该方法将当前线程、是否要跨所有线程设置事务以及 handlerton 的地址作为参数。调用此方法会导致事务启动。清单 10-56 中显示了`start_stmt()`方法的一个示例实现。

[***清单 10-56。***](#_list56) 示例 start_stmt()方法实现

```sql
int my_handler::start_stmt(THD *thd, thr_lock_type lock_type)
{
  DBUG_ENTER("my_handler::index_last");
  int error= 0;
  /*
    Save the transaction data
  */
  my_txn *txn= (my_txn *) thd->ha_data[my_handler_hton.slot];
  /*
    If this is a new transaction, create it and save it to the
    handler's slot in the ha_data array.
  */
  if (txn == NULL)
    thd->ha_data[my_handler_hton.slot]= txn= new my_txn;
  /*
    Start the transaction and create a savepoint then register
    the transaction.
  */
  if (txn->stmt == NULL && !(error= txn->tx_begin()))
  {
    txn->stmt= txn->new_savepoint();
    trans_register_ha(thd, FALSE, &my_handler_hton);
  }
  DBUG_RETURN(error);
}
```

从`external_lock()`开始一个事务有点复杂。MySQL 在事务开始时为每个正在使用的表调用`external_lock()`方法。因此，您需要做更多的工作来检测事务并相应地处理它。这可以从对`trx->active_trans`旗的检查中看出。当对第一个表调用`external_lock()`方法时，也意味着开始事务操作。[列出 10-57](#list57) 展示了`external_lock()`方法的一个示例实现(为了简洁，省略了一些部分)。完整代码见`ha_innodb.cc`文件。

[***列举 10-57。***](#_list57) 示例 external_lock()方法实现(来自 InnoDB)

```sql
int ha_innobase::external_lock(THD*  thd, int Lock_type)
{
  row_prebuilt_t* prebuilt = (row_prebuilt_t*) innobase_prebuilt;
  trx_t*    trx;

  DBUG_ENTER("ha_innobase::external_lock");
  DBUG_PRINT("enter",("lock_type: %d", lock_type));

  update_thd(thd);

  trx = prebuilt->trx;

  prebuilt->sql_stat_start = TRUE;
  prebuilt->hint_need_to_fetch_extra_cols = 0;

  prebuilt->read_just_key = 0;
  prebuilt->keep_other_fields_on_keyread = FALSE;

  if (lock_type == F_WRLCK) {

    /* If this is a SELECT, then it is in UPDATE TABLE ...
    or SELECT ... FOR UPDATE */
    prebuilt->select_lock_type = LOCK_X;
    prebuilt->stored_select_lock_type = LOCK_X;
  }

  if (lock_type != F_UNLCK)
       {
    /* MySQL is setting a new table lock */

    trx->detailed_error[0] = '\0';

    /* Set the MySQL flag to mark that there is an active
    transaction */
    if (trx->active_trans == 0) {

      innobase_register_trx_and_stmt(thd);
      trx->active_trans = 1;
    } else if (trx->n_mysql_tables_in_use == 0) {
      innobase_register_stmt(thd);
    }

    trx->n_mysql_tables_in_use++;
    prebuilt->mysql_has_locked = TRUE;

...
    DBUG_RETURN(0);
  }

  /* MySQL is releasing a table lock */

  trx->n_mysql_tables_in_use--;
  prebuilt->mysql_has_locked = FALSE;

  /* If the MySQL lock count drops to zero we know that the current SQL
  statement has ended */

  if (trx->n_mysql_tables_in_use == 0) {

...
  DBUG_RETURN(0);
}
```

现在您已经看到了如何启动事务，让我们看看它们是如何停止的(也称为提交或回滚)。提交事务只是意味着将挂起的更改写入磁盘，存储适当的键，并清理事务。Oracle 在 handlerton ( `int (*commit)(THD *thd, bool all)`)中提供了一个方法，可以使用这里显示的函数描述来实现该方法。参数是当前线程和您是否想要提交整个命令集。

```sql
int (*commit)(THD *thd, bool all);
```

回滚事务更加复杂。在这种情况下，您必须撤销自事务最后一次启动以来所做的一切。Oracle 使用 handlerton ( `int  (*rollback)(THD *thd, bool all)`)中的回调来支持回滚，可以使用这里显示的函数描述来实现回调。参数是当前线程和是否应该回滚整个事务。

```sql
int (*rollback)(THD *thd, bool all);
```

为了实现事务，存储引擎必须提供某种缓冲机制来保存未保存的对数据库的更改。一些存储引擎使用类似堆的结构；其他的使用队列和类似的内存结构。如果您打算在存储引擎中实现事务，您将需要创建一个内部缓存(有时称为版本控制)机制。当发出 commit 时，数据必须从缓冲区中取出并写入磁盘。发生回滚时，必须取消操作并撤销其更改。

保存点是另一种事务机制，可用于在事务期间管理数据。保存点是内存中允许您保存信息的区域。您可以使用它们在事务过程中保存信息。例如，您可能希望保存有关内部缓冲区的信息，您实现该缓冲区是为了存储“脏的”或“未提交的”更改。保存点概念就是为了这种用途而创建的。

Oracle 提供了几种可以在 handlerton 中定义的保存点操作。这些出现在清单 10-1 中的 handlerton 结构的第 13 到 15 行。保存点方法的方法描述如下:

```sql
uint savepoint_offset;
int (*savepoint_set)(THD *thd, void *sv);
int (*savepoint_rollback)(THD *thd, void *sv);
int (*savepoint_release)(THD *thd, void *sv);
```

`savepoint_offset`值是您想要保存的存储区域的大小。`savepoint_set()`方法允许您为参数`sv`设置一个值，并将其保存为保存点。当回滚操作被触发时，调用`savepoint_rollback()`方法。在这种情况下，服务器将保存在`sv`中的信息返回给方法。类似地，当服务器响应释放保存点事件并通过设置为保存点的`sv`返回数据时，会调用`savepoint_release()` 。有关保存点的更多信息，请参见 MySQL 源代码和在线参考手册。

![image](img/sq.jpg) **提示**关于事务设施如何工作的优秀示例，请参见`ha_innodb.cc`源文件。您也可以在在线参考手册中找到相关信息。

简单地使用 MySQL 机制添加事务支持并不是故事的结尾。使用索引 [<sup>8</sup>](#Fn8) 的存储引擎必须提供允许事务的机制。这些操作必须能够标记已经被事务中的操作改变的节点，保存已经改变的数据的原始值，直到事务完成。此时，所有的更改都被提交到物理存储中(对于索引和数据)。这需要对`Spartan_index`类进行修改。

显然，在存储引擎插件中实现事务需要很多仔细的思考和计划。我强烈建议，如果您打算在您的存储引擎中实现事务支持，您应该学习 BDB 和 InnoDB 存储引擎以及在线参考手册。您甚至可能想要设置调试器并观察事务的执行。无论您以哪种方式实现事务，请放心，如果您让它工作，您将会有一些特别的东西。很少有优秀的存储引擎支持事务，也没有(到目前为止)超过原生 MySQL 存储引擎的能力。

摘要

在这一章中，我带你浏览了存储引擎插件的源代码，并向你展示了如何创建你自己的存储引擎。通过 Spartan 存储引擎，您学习了如何构建一个可以读写数据并支持并发访问和索引的存储引擎。虽然我解释了构建这个存储引擎的所有阶段，但是我将添加事务支持留给您去试验。

我也没有实现存储处理程序所有可能的功能。相反，我只是实现了一些基本功能。既然您已经看到了基本的操作并有机会进行实验，我建议您在设计自己的存储引擎时学习在线文档和源代码。

如果你觉得这一章是个挑战，没关系。创建数据库物理存储机制不是一项简单的任务。我希望您从本章中能够更好地理解构建一个存储引擎需要什么，并对那些实现索引和事务支持的 MySQL 存储引擎有一个正确的认识。这些任务都不是微不足道的努力。

最后，我看到了我提供的数据和索引类的几个可能改进的地方。虽然数据类对大多数应用来说似乎不错，但索引类还可以改进。如果您计划使用这些类作为您自己的存储引擎的起点，我建议让您的存储引擎像现在这样使用这些类，然后返回并更新或替换它们。

我建议更新索引类中的几个区域。也许我推荐的最重要的改变是将内部缓冲区改为更有效的树结构。有很多可以选择，比如无处不在的 B 树或者哈希机制。我还建议您更改该类处理范围查询的方式。最后，需要进行更改来处理事务支持。该类需要支持您用来处理提交和回滚的任何缓冲机制。

在下一章中，我将讨论数据库服务器设计和实现中的一些高级主题。这一章将为你使用 MySQL 服务器源代码作为研究数据库系统内部的实验平台做准备。

[<sup>1</sup>](#_Fn1) 尽管使用了聚集索引和其他数据文件优化。

[<sup>2</sup>](#_Fn2) 一些特殊的存储引擎可能根本不需要写数据。例如，黑洞存储引擎实际上不实现任何写功能。嘿，这是个黑洞！

[<sup>3</sup>](#_Fn3) 将存储引擎正在读写的数据称为存储介质更为正确，因为没有任何东西规定数据必须驻留在传统的数据存储机制上。

[<sup>4</sup>](#_Fn4)MyISAM 和 InnoDB 存储引擎包含附加源文件。这些是最老的存储引擎，也是最复杂的。

这一章的灵感来源于那些寻求开发自己的存储引擎的人所缺乏的内容。很少有参考资料在其示例中超出了创建阶段 1 引擎的范围。

[<sup>6</sup>](#_Fn6) 嗯，也许是低级 I/O 源代码。自从我写了那个类之后，总是有可能我错过了一些东西或者服务器中的一些东西已经改变了。

[<sup>7</sup>T3】集群存储引擎(NDB)也支持事务。](#_Fn7)

[<sup>8</sup>](#_Fn8) 根据记录，有可能存在不支持索引的第 6 级引擎。事务处理不需要索引。然而，唯一性应该是一个问题，性能会受到影响。