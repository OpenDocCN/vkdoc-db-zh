# 三、MySQL 源代码之旅

本章对 MySQL 源代码进行了完整的介绍，并解释了如何获取和构建该系统。我向您介绍了源代码的机制，以及如何维护代码的编码指南和最佳实践。我将重点放在处理查询的代码部分；这将为第 11 章及以后介绍的主题做好准备。我也给你一个简短的概述，介绍动态加载包含特性的库的插件系统。

入门指南

在这一节中，我将研究修改 MySQL 源代码背后的原则，以及如何获得源代码。让我们先回顾一下可用的许可选项。

了解许可选项

当计划对开源软件进行修改时，要考虑如何使用这些修改。更具体地说，您将如何获取源代码并使用它？根据你对修改的意图，你的选择会和其他人非常不同。您可能希望通过三种主要方式来修改源代码:

*   深入了解 MySQL 是如何构建的；因此，你是在遵循本书中的例子，还是在进行自己的实验。
*   为您或您的组织开发一项不会在组织外分发的功能。
*   构建计划与其他人共享或推广的应用或扩展。

在第一章中，我讨论了在开源许可下修改软件的开源开发者的责任。既然 MySQL 是在 GPLv2 下发布的，也是在商业许可下发布的(一个*双许可*，我们必须考虑在*和*双许可下源代码的使用。我将从 GPLv2 开始我们的讨论。

根据 GPL，在纯学术会议中修改源代码是允许的，这显然给了你修改和试验源代码的自由。您贡献的价值可能决定您的代码是否在 GPL 下发布。例如，如果您的代码修改被认为是单一的(它们只适用于有限的一组特殊用途的用户)，那么该代码可能不包含在源代码库中。类似地，如果你的代码专注于学术实践的探索，那么除了你自己，代码可能对任何人都没有价值。很少有人会将测试源代码中实现的选项和特性的学术练习视为对 MySQL 系统的增值。另一方面，如果你的实验为系统带来了成功和有意义的贡献，大多数人会同意你有义务分享你的发现。出于本书的目的，您将继续修改源代码，就好像您不会共享您的修改一样。虽然我希望你会发现本书中的实验具有启发性和娱乐性，但我不认为在没有进一步开发的情况下，它们会被考虑采用到 MySQL 系统中。如果你采用这些例子，并从中做出一些精彩的东西，我祝福你。一定要告诉所有人你的想法是从哪里来的。

![image](img/sq.jpg) **警告**如果您正在规划一个计划以任何方式与任何人共享的项目，请联系 Oracle 的 MySQL 销售人员，了解您当前的许可以及支持您的目标的许可选项的可用性。

如果您正在修改供您或您的组织使用的 MySQL 源代码，并且您不想共享您的修改，您应该购买适当的 MySQL 商业许可证。MySQL 的商业许可条款允许您进行修改(甚至让 Oracle 来帮助您)并保留这些修改。

类似地，如果你正在修改源代码并打算发布修改，GPL 要求你免费发布修改后的源代码(但你可能会收取媒体费)。在这样做之前，您应该咨询 Oracle。

此外，您的更改不能成为专有的，并且您不能拥有 GPL 下的修改权利。如果您选择不自己发布您的更改，您应该将代码提交给 Oracle 考虑。如果被接受，它将成为甲骨文的财产。另一方面，如果您想对 MySQL 进行专有修改，以便在嵌入式系统或类似安装中使用，请在启动项目之前联系 Oracle 并讨论您的计划。

获取源代码

您可以从 MySQL 开发者网站([http://dev.mysql.com/downloads](http://dev.mysql.com/downloads))下载 MySQL 源代码。在该网站上，您会看到下载所有 MySQL 开源产品的链接。(要使用这本书，您需要 MySQL 社区版。)你还会看到几个下载不同版本服务器的链接，包括:

*   生产使用的当前版本(也称为普遍可用版本或 GA)
*   软件的旧版本
*   每个版本的文档

如果向下滚动，您会看到一个下拉框，允许您选择您的平台。这将下载服务器的二进制版本，包括在您的系统上安装和运行它所需的一切。您还会看到名为“源代码”的条目这是您将用来下载源代码的链接。

您还可以下载新版本服务器的源代码，称为“开发版本”您可以点击选项卡，看到一个类似的列表，用于选择平台或源代码。提醒一下，开发版本是最先进的功能预览，可能包含也可能不包含最终的生产代码，因此，不应考虑在生产环境中使用。出于本书的目的，您可以使用开发发布版本 5.6.5 或更高版本。

要了解本书中的示例，请从网站下载版本 5.6.5 或更高版本。我将在下一节提供安装 MySQL 的说明。该站点包含所有受支持环境的所有二进制文件和源代码。支持许多不同的平台。你会在页面底部找到源代码。为您的平台下载源代码和二进制文件(两次下载)。在本书中，我将使用 Ubuntu 和微软 Windows 7 中的例子。

![image](img/sq.jpg) **提示**如果你用的是 Windows，下载 MSI 安装程序。事实上，可以考虑下载 MySQL Windows installer。它包含了所有的 MySQL 组件，使得在 Windows 上安装 MySQL 成为一个简单快速的过程。在你的 Windows 系统上安装 MySQL 是最好的方法。

旧平台支持

如果您没有看到您选择的二进制发行版中列出您的平台，很可能您的平台太新，不再受支持，或者尚未包括在内。如果出现这种情况，您仍然可以下载源代码并自己构建。

![image](img/sq.jpg) **注**除非另有说明，本书中的例子均取自 Linux 源代码发行版(`mysql-5.6.5`)。虽然 Linux 和 Windows 发行版的大部分代码都是相同的，但我强调了它们之间的差异。最值得注意的是，Windows 平台有一个稍微不同的`vio`实现。

MySQL 源代码

下载源代码后，将文件解压到系统上的一个文件夹中。如果愿意，您可以将它们解压缩到同一个目录中。当您这样做时，请注意有许多文件夹和许多源文件。您需要引用的主文件夹是`/sql`文件夹。这包含服务器的主要源文件。[表 3-1](#Tab1) 列出了最常访问的文件夹及其内容。

[表 3-1。](#_Tab1) MySQL 源文件夹

| 文件夹 | 内容 |
| --- | --- |
| `/BUILD` | 支持所有平台的编译配置和 make 文件。 |
| `/client` | MySQL 命令行客户端工具。 |
| `/cmake` | CMake 跨平台构建系统的配置文件。 |
| `/dbug` | 调试中使用的实用程序(详见第 5 章。 |
| `/include` | 基本系统包括文件和头文件。 |
| `/libmysql` | 用于 MySQL 客户端应用以及创建嵌入式系统的 C 客户端 API。(更多详情见第 6 章。) |
| `/libmysqld` | 核心服务器 API 文件。也用于创建嵌入式系统。(更多详情见第 6 章。) |
| `/mysql-test` | MySQL 系统测试套件。(更多详情请参见[第 4 章](04.html)。) |
| `/mysys` | 大多数核心操作系统 API 包装器和助手函数。 |
| `/plugin` | 包含所有提供的插件的源代码的文件夹。 |
| `/regex` | 正则表达式库。在查询优化器和执行中用于解析表达式。 |
| `/scripts` | 一组基于 shell 脚本的实用程序。 |
| `/sql` | 主系统代码。你应该从这个文件夹开始你的探索。 |
| `/sql-bench` | 一套基准测试工具。 |
| `/storage` | MySQL 可插拔存储引擎源代码位于该文件夹中。还包括存储引擎示例代码。(详见[第 7 章](07.html)。) |
| `/strings` | 核心字符串处理包装器。使用这些来满足您所有的字符串处理需求。 |
| `/support-files` | 一组预配置的配置文件，用于使用不同的选项进行编译。 |
| `/tests` | 一组测试程序和测试文件。 |
| `/vio` | 网络和套接字层代码。 |
| `/zlib` | 数据压缩工具。 |

我建议你现在花些时间仔细阅读一些文件夹，熟悉文件的位置。您会发现许多类型的文件和各种 Perl 脚本分散在文件夹中。虽然没有过分简单化，但 MySQL 源代码在逻辑上是围绕源代码的功能而不是核心子系统组织的。一些子系统，如存储引擎和插件，位于文件夹层次结构中，但大多数位于文件夹结构中的几个位置。对于检查源代码时讨论的每个子系统，我列出了相关的源文件及其位置。

入门指南

理解 MySQL 系统的流程和控制的最佳方式是从典型查询的角度来看源代码。我在第 2 章的[中展示了每个主要 MySQL 子系统的高级视图。我现在使用相同的子系统视图，向您展示典型的 SQL 语句是如何执行的。我使用的示例](02.html) SQL 语句是:

```sql
SELECT lname, fname, DOB FROM Employees WHERE Employees.department = 'EGR'
```

该查询选择工程部门每个人的姓名和出生日期。虽然不是很有趣，但这个查询在演示 MySQL 系统中的几乎所有子系统时会很有用。让我们从到达服务器进行处理的查询开始。

[图 3-1](#Fig1) 显示了示例查询通过 MySQL 源代码的路径。我已经抽出了主要的代码行，你应该把它们与第二章[中确定的子系统联系起来。我还简化和省略了一些参数列表，使图形更容易阅读。虽然不是特定子系统的一部分，但是`mysqld_main()`函数负责初始化服务器和设置连接监听器。mysqld_main()函数在文件`/sql/mysqld.cc`中。](02.html)

![image](img/sq.jpg) **注** Windows 系统执行`win_main()`方法 ，也位于`mysqld.cc`。

![9781430246596_Fig03-01.jpg](img/9781430246596_Fig03-01.jpg)

[图 3-1。](#_Fig1)查询路径概述

查询的路径一旦到达服务器，就从 SQL 接口子系统开始(像大多数 MySQL 子系统一样，SQL 接口函数分布在一组松散关联的源文件上)。在您阅读这一部分和后面的部分时，我会告诉您这些方法在哪个文件中。`handle_connections_socket()`方法(位于`in /sql/mysqld.cc`)实现监听器循环，为每个检测到的连接创建一个线程。一旦线程被创建，控制就流向`do_handle_one_connection()`函数。`do_handle_one_connection()`功能识别命令，然后将控制传递给`do_command`开关(位于`/sql/sql_parse.cc`)。`do_command`开关将控制路由到适当的网络读取调用，以从连接中读取查询，并通过`dispatch_command()`函数(位于`in /sql/sql_parse.cc`)将查询传递给解析器。

查询传递到查询解析器子系统，在那里查询被解析并路由到优化器的正确部分。查询解析器内置了 Lex 和 YACC。Lex 用于标识语言的标记和文字以及语法。YACC 用于构建与 MySQL 源代码交互的代码。它捕获 SQL 命令，将命令的部分存储在内部查询表示中，并将命令路由到名为`mysql_execute_command()`(有点名不副实)的命令处理器。然后，该方法将查询路由到适当的子功能，在本例中是`mysql_select()`。这些方法位于`/sql/sql_parse.cc`和`/sql/sql_select.cc`。这部分代码进入 SELECT-PROJECT-JOIN 查询优化器的 SELECT-PROJECT 部分。

![image](img/sq.jpg) **提示**项目或投影是一个关系数据库术语，描述将结果集限制为 SQL 命令的列列表中定义的那些列的查询操作。例如，SQL 命令`SELECT fname, lname FROM employee`只将雇员表中的`fname`和`lname`列“投影”到结果集中。

此时，查询优化器被调用，通过位于`/sql/sql_resolver.cc`的函数`join->prepare()`和位于`/sql/sql_optimizer.cc`的函数`join->optimize()`来优化查询的执行。接下来在位于`/sql/sql_executor.cc`的 join- > exec()中执行查询，控制传递给位于`/sql/sql_executor.cc`中的较低级别的`do_select()`函数，该函数执行限制和投影操作。最后，`sub` `_select()`函数调用存储引擎读取元组，对其进行处理，并将结果返回给客户端。这些方法位于`/sql/sql_executor.cc`中。在结果被写入网络后，控制返回到`handle_connections_sockets`循环(位于`in /sql/mysqld.cc`)。

![image](img/sq.jpg) **提示**类、结构、类、结构——这都是关于类和结构的！在研究 MySQL 源代码时，请记住这一点。对于服务器中的任何操作，至少有一个类或结构管理数据或驱动执行。学习常用的 MySQL 类和结构是理解源代码的关键，你会在本章后面的“重要的类和结构”中看到。

您可能认为代码并不像您听到的那样糟糕。对于简单的`SELECT` 语句，比如我正在使用的例子，这在很大程度上是正确的，但是正如你很快会看到的，它可以变得比这更复杂。既然您已经看到了这条路径，并且已经了解了一些主要函数在查询和子系统路径中的位置，那么打开源代码并寻找这些函数。您可以在`/sql/mysqld.cc`中开始搜索。

好的，这是一个旋风般的介绍，对吗？从这一点开始，我放慢了一点速度(好吧，慢了很多),更详细地浏览源代码。我还在每一节的末尾以表格的形式列出了示例所在的特定源文件。所以系紧安全带，我们要进去了！

我省略了与我们旅行无关的部分。这些可能包括条件编译指令、辅助代码和其他系统级调用。我对缺失的部分做了如下注释:`...`。我保留了许多原始注释，因为我相信它们将帮助您了解源代码，并让您对开发世界一流的数据库系统有所了解。最后，我用粗体突出显示了代码的重要部分，以便您在阅读时可以更容易地找到它们。

函数的作用是

服务器开始执行的`mysqld_main()`函数位于`/sql/mysqld.cc`中。它是服务器可执行文件加载到内存中时调用的第一个函数。这个函数中有数百行代码专门用于特定于操作系统的启动任务，还有大量的系统级初始化代码。[清单 3-1](#list1) 显示了代码的压缩视图，要点用粗体显示。

[***清单 3-1***](#_list1) 。main()函数

```sql
int mysqld_main(int argc, char **argv)
{
  ...

  if (init_common_variables())

  ...

  if (init_server_components())

  ...
  /*
   Initialize my_str_malloc() and my_str_free()
  */
  my_str_malloc= &my_str_malloc_mysqld;
  my_str_free= &my_str_free_mysqld;

  ...

  if (mysql_rm_tmp_tables() || acl_init(opt_noacl) ||
      my_tz_init((THD *)0, default_tz_name, opt_bootstrap))

  ...

  create_shutdown_thread();

  ...

  handle_connections_sockets();

  ...

  (void) mysql_mutex_lock(&LOCK_thread_count);

  ...

  (void) mysql_mutex_unlock(&LOCK_thread_count);

  ...
}
```

第一个有趣的函数是`init_common_variables()`。这使用命令行参数来控制服务器的运行方式；它是服务器解释参数并以各种模式启动服务器的地方。该函数负责设置系统变量，并将服务器置于所需的模式。`init-server-components()`函数初始化数据库日志，供任何子系统使用。这些是您看到的事件、语句执行等的典型日志。

两个最重要的`my_`库函数是`my_str_malloc()`和`my_str_free()`。这两个函数指针就是在服务器启动代码中的这一点(靠近开头)被设置的。您应该总是使用这些函数来代替传统的 C/C++ `malloc()`函数，因为 MySQL 函数有额外的错误处理，因此比基本方法更安全。`acl_init()`函数的工作是启动认证和访问控制子系统。这个密钥系统出现在服务器启动代码的早期。

现在你开始了解 MySQL 的成功之处:线程。创建了两个重要的助手线程。函数创建一个线程，它的任务是在收到信号时关闭服务器。我将在“进程与线程”侧栏中更详细地讨论线程。

在启动代码的这一点上，系统已经准备好接受来自客户端的连接。为了做到这一点，`handle-connections-sockets()`函数实现了一个监听器，它循环遍历等待连接的代码。接下来我将更详细地讨论这个函数。

我想在代码中指出的最后一点是多线程期间互斥访问的临界区保护代码的一个例子。临界区是必须作为一个集合执行的代码块，一次只能由一个线程访问。临界区通常是写入共享内存变量的区域，因此它们必须在另一个线程试图读取内存之前完成。Oracle 创建了一种常见并发保护机制的抽象，称为*互斥*(互斥的缩写)。如果您在代码中找到一个需要在并发执行期间保护的区域，请使用以下函数来保护代码。

你应该调用的第一个函数是`mysql_mutex_lock([resource reference]`。这会在代码的这一点锁定代码的执行。它不允许另一个线程访问指定的内存位置，直到您的代码调用解锁函数`mysql_mutex_unlock([resource reference])`。在来自`mysqld_main()`函数的例子中，互斥调用锁定了线程计数全局变量。

这是你第一次在引擎盖下潜水。感觉如何？你想要更多吗？继续读——你才刚刚开始。事实上，您还没有看到我们的示例查询是从哪里进入系统的。让我们接下来做那件事。

进程与线程

术语*进程*和*线程*经常互换使用。这是不正确的，因为*进程*是一组有组织的计算机指令，它有自己的内存和执行路径。一个*线程*也是一组计算机指令，但是线程在一个主机的执行路径中执行，没有自己的内存。(有些人称线程为轻量级进程。虽然这是一个很好的描述，但对它们的称呼无助于区分。)它们存储状态(在 MySQL 中，是通过`THD`类)。因此，当谈到支持进程的大型系统时，我指的是允许系统的各个部分作为独立的进程执行并拥有自己的内存的系统。当谈到支持线程的大型系统时，我指的是允许系统的某些部分与系统的其他部分并发执行的系统，它们都与主机共享相同的内存空间。

大多数数据库系统使用进程模型来管理并发连接和助手功能。MySQL 使用多线程模型。与进程相比，使用线程有很多优点。最值得注意的是，线程更容易创建和管理(没有内存分配和隔离的开销)。线程也允许非常快速的切换，因为没有上下文切换发生。然而，线程确实有一个严重的缺点。如果事情变得不稳定(这是一个高度技术性的术语，用来描述奇怪的、无法解释的行为；在线程的情况下，它们通常是非常奇怪和有害的事件),如果问题很严重，很可能会影响整个系统。幸运的是，Oracle 和全球开发者社区已经非常努力地让 MySQL 的线程子系统变得健壮和可靠。这就是为什么你的修改必须是线程安全的。

处理连接并创建线程

在上一节中，您看到了系统是如何启动的，以及控制是如何流向等待用户连接的侦听器循环的。连接始于客户端，并被分解成数据包，由客户端软件放在网络上，然后流经网络通信路径，由服务器的网络子系统接收，并在服务器上重新形成数据。(关于通信包的完整描述可以在 MySQL 内部手册中找到。)这个流程可以在[图 3-2](#Fig2) 中看到。我将在下一章展示更多关于网络通信方法的细节。我还提供了一些例子，说明如何编写代码，使用这些函数向客户机返回结果。

![9781430246596_Fig03-02.jpg](img/9781430246596_Fig03-02.jpg)

[图 3-2。](#_Fig2)从客户端到服务器的网络通信

此时，系统处于 SQL 接口子系统中。也就是说，数据包(包含查询)已经到达服务器，并通过`handle_connections_sockets()`函数被检测到。该函数进入一个循环，等待变量`abort_loop`被设置为`TRUE`。[表 3-2](#Tab2) 显示了管理连接和线程的文件位置。

[表 3-2。](#_Tab2)连接和线程管理

| 源文件 | 描述 |
| --- | --- |
| `/sql/net_serv.cc` | 包含所有网络通信功能。有关如何通过网络与客户端或服务器通信的信息，请查看此处。 |
| `/include/mysql_com.h` | 包含通信中使用的大多数结构。 |
| `/sql/sql_parse.cc` | 包含除词法分析器之外的大多数查询路由和分析功能。 |
| `/sql/mysqld.cc` | 除了 mysqld_main 和服务器启动函数之外，这个文件还包含创建线程的方法。 |

[清单 3-2](#list2) 提供了连接处理代码的浓缩视图。当检测到一个连接时(我已经隐藏了这部分代码，因为它对了解系统如何工作没有帮助)，函数创建一个新的线程，调用恰当命名的`create_new_thread()`函数。正是在这个功能中，第一个主要结构被创建。`THD`类负责维护线程的所有信息。虽然没有在私有内存空间中分配给线程，但是`THD`类允许系统在执行过程中控制线程。我将在后面的部分公开一些`THD`类。

[***清单 3-2***](#_list2) 句柄-连接-套接字功能

```sql
void handle_connections_sockets()
{

  ...

  DBUG_PRINT("general",("Waiting for connections."));

  ...

  while (!abort_loop)
  {

  ...

    /*
    ** Don't allow too many connections
    */

    if (!(thd= new THD))

  ...

    create_new_thread(thd);
  }

  ...
}
```

好了，客户端已经连接到服务器了。接下来会发生什么？让我们看看`create_new_thread()`函数内部发生了什么。[清单 3-3](#list3) 显示了这个函数的一个浓缩视图。首先看到的是锁定线程数的互斥调用。正如您在`mysqld_main()`函数中看到的，这对于防止其他线程竞争对变量的写访问是必要的。创建线程时，会调用相关的解锁互斥体来解锁资源。

[***清单 3-3***T5【create _ new _ thread()函数](#_list3)

```sql
static void create_new_thread(THD *thd)
{

...

  /*
    Don't allow too many connections. We roughly check here that we allow
    only (max_connections + 1) connections.
  */
  mysql_mutex_lock(&LOCK_connection_count);
  if (connection_count >= max_connections + 1 || abort_loop)
  {
    mysql_mutex_unlock(&LOCK_connection_count);
...
    close_connection(thd, ER_CON_COUNT_ERROR);
    delete thd;
...
  }

  ++connection_count;

  if (connection_count > max_used_connections)
    max_used_connections= connection_count;
  mysql_mutex_unlock(&LOCK_connection_count);
  /* Start a new thread to handle connection. */
  mysql_mutex_lock(&LOCK_thread_count);
...

  thd->thread_id= thd->variables.pseudo_thread_id= thread_id++;
  MYSQL_CALLBACK(thread_scheduler, add_connection, (thd));
...

}
```

一件非常有趣的事情发生在函数的早期。注意`MYSQL_CALLBACK()`宏。该宏旨在重用驻留在连接池中的线程。这有助于加快速度，因为创建线程虽然比创建进程快，但会花费一些时间。让线程准备就绪是一种连接缓存机制。为以后使用而保存的线程被称为*连接池*。

如果没有可供重用的连接(线程)，系统会通过调用`pthread_create()`函数创建一个。这里发生了非常奇怪的事情。注意这个函数调用的第三个参数。看似变量的东西实际上是函数的起始地址(函数指针)。`pthread_create()`使用这个函数指针来关联服务器中线程开始执行的位置。T3】

既然查询已经从客户机发送到服务器，并且已经创建了一个线程来管理执行，那么控制就传递给 do_ `handle_one_connection()`函数。[清单 3-4](#list4) 显示了 do_ `handle_one_connection()`函数的浓缩视图。在这个视图中，我注释掉了处理初始化`THD`类以供使用的一大段代码。如果您感兴趣，稍后可以仔细看看代码(位于`/sql/sql_connect.cc`)。现在，让我们看看这个函数内部的基本工作。

[***清单 3-4***](#_list4)do _ handle _ one _ connection()函数

```sql
void do_handle_one_connection(THD *thd_arg)
{
  THD *thd= thd_arg;

...

    while (thd_is_connection_alive(thd))
    {
      mysql_audit_release(thd);
      if (do_command(thd))
        break;
    }
    end_connection(thd);

...

}
```

在这种情况下，我们研究的唯一感兴趣的函数调用是`do_command(thd)`函数。它位于一个循环中，对于从网络通信代码中读取的每个命令，该循环都循环一次。虽然在这一点上有点神秘，但这是我们这些输入过堆叠 SQL 命令(同一行中有多个命令)的人感兴趣的。正如您在这里看到的，这是 MySQL 处理这种可能性的地方。对于每个命令读取，该函数将控制传递给开始从网络读取查询的函数。

此时，系统从网络中读取查询，并将其放入`THD`类进行解析。这发生在`do_command()`函数中。[清单 3-5](#list5) 显示了`do_command()`函数的浓缩视图。我留下了一些更有趣的注释和代码来演示 MySQL 源代码的健壮性。

[***清单 3-5。***](#_list5)do _ command()函数

```sql
bool do_command(THD *thd)
{
  bool return_value;
  char *packet = 0;
  ulong packet_length;
  NET *net= &thd->net;
  enum enum_server_command command;

...

  net_new_transaction(net);

...

  packet_length= my_net_read(net);

...

  if (packet_length == packet_error)
  {
    DBUG_PRINT("info",("Got error %d reading command from socket %s",
         net->error,
         vio_description(net->vio)));

...

  command= (enum enum_server_command) (uchar) packet[0];

  if (command >= COM_END)
    command= COM_END; // Wrong command

  DBUG_PRINT("info",("Command on %s = %d (%s)",
                     vio_description(net->vio), command,
                     command_name[command].str));

  ...

  my_net_set_read_timeout(net, thd->variables.net_read_timeout);

  DBUG_ASSERT(packet_length);

  return_value= dispatch_command(command, thd, packet+1, 
                                    (uint) (packet_length-1));

...

}
```

首先要注意的是一个包缓冲区和一个`NET`结构的创建。这个包缓冲区是一个字符数组，存储从网络上读取的原始查询字符串，并存储在`NET`结构中。下一个创建的项目是一个命令结构，它将用于将控制传递给适当的解析器函数。`my_net_read()`功能从网络中读取数据包，并将它们存储在`NET`结构中。数据包的长度也存储在`NET`结构的`packet_length`变量中。您在这个函数中看到的最后一件事是对`dispatch_command()`的调用，从这里您可以开始看到命令是如何通过服务器代码路由的。

好吧，你开始有所进展了。`dispatch_command()`功能的工作是将控制路由到服务器中能够最好地处理输入命令的部分。由于您正在进行一个普通的`SELECT`查询，系统通过将`command`变量设置为`COM_QUERY.`将它识别为一个查询，其他命令类型用于识别语句、更改用户、生成统计数据和许多其他服务器功能。对于这一章，我将只看查询命令(`COM_QUERY`)。清单 3-6 显示了该函数的一个浓缩视图。为了简洁起见，我省略了 switch 中所有其他命令的代码(我也省略了注释分隔符)，但是我保留了大多数命令的 case 语句。花点时间浏览列表。大多数名字都是不言自明的。如果您要对另一种类型的查询进行这种探索，您可以通过在这个函数中查找所标识的类型并按照 case 语句中的代码来找到自己的方法。我还包括了出现在函数代码前的大函数注释块。花点时间看看这个。在这一章的后面，我会更深入地探讨这一点。

[***清单 3-6。***](#_list6)dispatch _ command()函数

```sql
/**
  Perform one connection-level (COM_XXXX) command.

  @param command         type of command to perform
  @param thd             connection handle
  @param packet          data for the command, packet is always null-terminated
  @param packet_length   length of packet + 1 (to show that data is
                         null-terminated) except for COM_SLEEP, where it
                         can be zero.

...

  @retval
    0   ok
  @retval
    1   request of thread shutdown, i. e. if command is
        COM_QUIT/COM_SHUTDOWN
*/
bool dispatch_command(enum enum_server_command command, THD *thd,
        char* packet, uint packet_length)
{

  ...
  switch (command) {
    case COM_INIT_DB:
    ...
    case COM_REGISTER_SLAVE:
    ...
    case COM_TABLE_DUMP:
    ...
    case COM_CHANGE_USER:
    ...
    case COM_STMT_EXECUTE:
    ...
    case COM_STMT_FETCH:
    ...
    case COM_STMT_SEND_LONG_DATA:
    ...
    case COM_STMT_PREPARE:
    ...
    case COM_STMT_CLOSE:
    ...
    case COM_STMT_RESET:
    ...
    case COM_QUERY:
    {
      if (alloc_query(thd, packet, packet_length))
        break;          // fatal error is set

    ...

      if (opt_log_raw)
        general_log_write(thd, command, thd->query(), thd->query_length());

    ...

      mysql_parse(thd, thd->query(), thd->query_length(), &parser_state);

    ...
    }
    case COM_FIELD_LIST:        // This isn't actually needed
    ...
    case COM_QUIT:
    ...
    case COM_BINLOG_DUMP_GTID;
    ...
    case COM_BINLOG_DUMP:
    ...
    case COM_REFRESH:
    ...
    case COM_SHUTDOWN:
    ...
    case COM_STATISTICS:
    ...
    case COM_PING:
    ...
    case COM_PROCESS_INFO:
    ...
    case COM_PROCESS_KILL:
    ...
    case COM_SET_OPTION:
    ...
    case COM_DEBUG:
    ...
    case COM_SLEEP:
    ...
    case COM_DELAYED_INSERT:
    ...
    case COM_CONNECT;
    case COM_TIME;
    ...
    case COM_END:
    ...
    default:
    ...
}
```

当控制权传递给`COM_QUERY`处理程序时发生的第一件事是，通过`alloc` `_query()`函数将查询从`packet`数组复制到`thd->query`成员变量。通过这种方式，线程现在拥有了查询的副本，该副本将在整个执行过程中一直伴随着它。还要注意，代码将命令写入常规日志。这将有助于稍后调试系统问题和查询问题。清单 3-6 中感兴趣的最后一个函数调用是`mysql_parse()`函数调用。至此，代码可以正式从 SQL 接口子系统转移到查询解析器子系统。如您所见，这种区别是语义上的，而不是语法上的。

解析查询

最后，解析开始。这是服务器处理查询时内部运行的核心。解析器代码和系统的其他部分一样，位于几个地方。如果你意识到虽然它是高度组织的，但是代码的结构与架构不匹配，那么这就不难理解了。

您现在正在检查的函数是`mysql_parse()`函数(位于`/sql/sql_parse.cc`)。它的工作是在查询缓存中检查先前执行的具有相同结果集的查询的结果，然后将控制传递给词法分析器(`parse_sql()`)，最后将命令传递给查询优化器。[清单 3-7](#list7) 显示了`mysql_parse()`函数的浓缩视图。

[***清单 3-7***](#_list7)MySQL _ parse()函数

```sql
/**
  Parse a query.

  @param       thd     Current thread
  @param       rawbuf  Begining of the query text
  @param       length  Length of the query text
  @param[out]  found_semicolon For multi queries, position of the character of
                               the next query in the query text.
*/

void mysql_parse(THD *thd, char *rawbuf, uint length,
                 Parser_state *parser_state)
{
  int error __attribute__((unused));

  ...

  if (query_cache_send_result_to_client(thd, rawbuf, length) <= 0)
  {
    LEX *lex= thd->lex;

  ...

    bool err= parse_sql(thd, parser_state, NULL);

  ...

      error= mysql_execute_command(thd);

  ...

    }

  ...

  }
  else
  {
    /*
      Query cache hit. We need to write the general log here.
      Right now, we only cache SELECT results; if the cache ever
      becomes more generic, we should also cache the rewritten
      query string together with the original query string (which
      we'd still use for the matching) when we first execute the
      query, and then use the obfuscated query string for logging
      here when the query is given again.
    */
    thd->m_statement_psi= MYSQL_REFINE_STATEMENT(thd->m_statement_psi,
                                                sql_statement_info[SQLCOM_SELECT].m_key);
    if (!opt_log_raw)
      general_log_write(thd, COM_QUERY, thd->query(), thd->query_length());
    parser_state->m_lip.found_semicolon= NULL;
  }
  ...
}
```

首先要注意的是检查查询缓存的调用。查询缓存存储所有最频繁请求的查询，包括结果。如果查询已经在查询缓存中，我们跳到 else，这样就完成了！剩下的工作就是将结果返回给客户机。不需要解析、优化甚至执行。这有多酷？

为了便于研究，我们假设查询缓存不包含示例查询的副本。在这种情况下，该函数创建一个新的`LEX`结构来包含查询的内部表示。这个结构由 Lex/YACC 解析器填充，如清单 3-8 所示。这段代码在 sql/sql_yacc.yy 中。

[***清单 3-8***](#_list8) 选择 Lex/YACC 解析代码摘录

```sql
/*
  Select : retrieve data from table
*/

select:
          select_init
          {
            LEX *lex= Lex;
            lex->sql_command= SQLCOM_SELECT;
          }
        ;

/* Need select_init2 for subselects. */
select_init:
          SELECT_SYM select_init2
        | '(' select_paren ')' union_opt
        ;

select_paren:
          SELECT_SYM select_part2
          {
            if (setup_select_in_parentheses(Lex))
              MYSQL_YYABORT;
          }
        | '(' select_paren ')'
        ;

/* The equivalent of select_paren for nested queries. */
select_paren_derived:
          SELECT_SYM select_part2_derived
          {
            if (setup_select_in_parentheses(Lex))
              MYSQL_YYABORT;
          }
        | '(' select_paren_derived ')'
        ;

select_init2:
          select_part2
          {
            LEX *lex= Lex;
            SELECT_LEX * sel= lex->current_select;
            if (lex->current_select->set_braces(0))
            {
              my_parse_error(ER(ER_SYNTAX_ERROR));
              MYSQL_YYABORT;
            }
            if (sel->linkage == UNION_TYPE &&
                sel->master_unit()->first_select()->braces)
            {
              my_parse_error(ER(ER_SYNTAX_ERROR));
              MYSQL_YYABORT;
            }
          }
          union_clause
        ;

select_part2:
          {
            LEX *lex= Lex;
            SELECT_LEX *sel= lex->current_select;
            if (sel->linkage != UNION_TYPE)
              mysql_init_select(lex);
            lex->current_select->parsing_place= SELECT_LIST;
          }
          select_options select_item_list
          {
            Select->parsing_place= NO_MATTER;
          }
          select_into select_lock_type
        ;

select_into:
          opt_order_clause opt_limit_clause {}
        | into
        | select_from
        | into select_from
        | select_from into
        ;

select_from:
          FROM join_table_list where_clause group_clause having_clause
          opt_order_clause opt_limit_clause procedure_analyse_clause
          {
            Select->context.table_list=
              Select->context.first_name_resolution_table=
                Select->table_list.first;
          }
        | FROM DUAL_SYM where_clause opt_limit_clause
          /* oracle compatibility: oracle always requires FROM clause,
             and DUAL is system table without fields.
             Is "SELECT 1 FROM DUAL" any better than "SELECT 1" ?
          Hmmm :) */
        ;

select_options:
          /* empty*/
        | select_option_list
          {
            if (Select->options & SELECT_DISTINCT && Select->options & SELECT_ALL)
            {
              my_error(ER_WRONG_USAGE, MYF(0), "ALL", "DISTINCT");
              MYSQL_YYABORT;
            }
          }
        ;

select_option_list:
          select_option_list select_option
        | select_option
        ;

select_option:
          query_expression_option
        | SQL_NO_CACHE_SYM
          {
            /* 
              Allow this flag only on the first top-level SELECT statement, if
              SQL_CACHE wasn't specified, and only once per query.
             */
            if (Lex->current_select != &Lex->select_lex)
            {
              my_error(ER_CANT_USE_OPTION_HERE, MYF(0), "SQL_NO_CACHE");
              MYSQL_YYABORT;
            }
            else if (Lex->select_lex.sql_cache == SELECT_LEX::SQL_CACHE)
            {
              my_error(ER_WRONG_USAGE, MYF(0), "SQL_CACHE", "SQL_NO_CACHE");
              MYSQL_YYABORT;
            }
            else if (Lex->select_lex.sql_cache == SELECT_LEX::SQL_NO_CACHE)
            {
              my_error(ER_DUP_ARGUMENT, MYF(0), "SQL_NO_CACHE");
              MYSQL_YYABORT;
            }
            else
            {
              Lex->safe_to_cache_query=0;
              Lex->select_lex.options&= ∼OPTION_TO_QUERY_CACHE;
              Lex->select_lex.sql_cache= SELECT_LEX::SQL_NO_CACHE;
            }
          }
        | SQL_CACHE_SYM
          {
            /* 
              Allow this flag only on the first top-level SELECT statement, if
              SQL_NO_CACHE wasn't specified, and only once per query.
             */
            if (Lex->current_select != &Lex->select_lex)
            {
              my_error(ER_CANT_USE_OPTION_HERE, MYF(0), "SQL_CACHE");
              MYSQL_YYABORT;
            } 
            else if (Lex->select_lex.sql_cache == SELECT_LEX::SQL_NO_CACHE)
            {
              my_error(ER_WRONG_USAGE, MYF(0), "SQL_NO_CACHE", "SQL_CACHE");
              MYSQL_YYABORT;
            }
            else if (Lex->select_lex.sql_cache == SELECT_LEX::SQL_CACHE)
            {
              my_error(ER_DUP_ARGUMENT, MYF(0), "SQL_CACHE");
              MYSQL_YYABORT;
            }
            else
            {
              Lex->safe_to_cache_query=1;
              Lex->select_lex.options|= OPTION_TO_QUERY_CACHE;
              Lex->select_lex.sql_cache= SELECT_LEX::SQL_CACHE;
            }
          }
        ;

select_lock_type:
          /* empty */
        | FOR_SYM UPDATE_SYM
          {
            LEX *lex=Lex;
            lex->current_select->set_lock_for_tables(TL_WRITE);
            lex->safe_to_cache_query=0;
          }
        | LOCK_SYM IN_SYM SHARE_SYM MODE_SYM
          {
            LEX *lex=Lex;
            lex->current_select->
              set_lock_for_tables(TL_READ_WITH_SHARED_LOCKS);
            lex->safe_to_cache_query=0;
          }
        ;

select_item_list:
          select_item_list ',' select_item
        | select_item
        | '*'
          {
            THD *thd= YYTHD;
            Item *item= new (thd->mem_root)
                          Item_field(&thd->lex->current_select->context,
                                     NULL, NULL, "*");
            if (item == NULL)
              MYSQL_YYABORT;
            if (add_item_to_list(thd, item))
              MYSQL_YYABORT;
            (thd->lex->current_select->with_wild)++;
          }
        ;

select_item:
          remember_name table_wild remember_end
          {
            THD *thd= YYTHD;

            if (add_item_to_list(thd, $2))
              MYSQL_YYABORT;
          }
        | remember_name expr remember_end select_alias
          {
            THD *thd= YYTHD;
            DBUG_ASSERT($1 < $3);

            if (add_item_to_list(thd, $2))
              MYSQL_YYABORT;
            if ($4.str)
            {
              if (Lex->sql_command == SQLCOM_CREATE_VIEW &&
                  check_column_name($4.str))
              {
                my_error(ER_WRONG_COLUMN_NAME, MYF(0), $4.str);
                MYSQL_YYABORT;
              }
              $2->item_name.copy($4.str, $4.length, system_charset_info, false);
            }
            else if (!$2->item_name.is_set())
            {
              $2->item_name.copy($1, (uint) ($3 - $1), thd->charset());
            }
          }
        ;
```

我包含了来自 Lex/YACC 解析器的摘录，展示了如何识别`SELECT`标记并通过 YACC 代码进行解析。要阅读这段代码(以防你不知道莱克斯或 YACC)，注意代码中的关键词(或标记)(它们位于冒号的左下方，如`select:`)。这些关键字用于指导解析器的流程。这些关键字右侧的标记定义了解析查询时必须出现的顺序。例如，看看`select:`关键词。在它的右边，你会看到一个`select_init2`关键字，它并没有提供太多的信息。然而，如果你向下看代码，你会在左边看到`select_init:`关键字。这允许 Lex/YACC 作者以一种类似宏的形式指定某些行为。另外，请注意在`select_init`关键字下有花括号。这是解析器将查询分成几部分并将条目放入`LEX`结构的地方。直接符号，如`SELECT,`在头文件(`/sql/lex.h`)中定义，在解析器中显示为`SELECT_SYM`。现在花点时间浏览一下代码。你可能需要反复练习几次。如果你没有学习过编译器构造或文本解析，这可能会令人困惑。

如果你在想，“真是个怪物”，那么你可以放心，你是正常的。莱克斯/YACC 代码对大多数开发者来说都是一个挑战。我强调了一些重要的代码语句，它们应该有助于解释代码是如何工作的。让我们过一遍。为了方便起见，我在这里再次重复了示例`SELECT`语句:

```sql
SELECT lname, fname, DOB FROM Employees WHERE Employees.department = 'EGR'
```

再看第一个关键词。注意`select_init`代码块如何将`LEX`结构的`sql_command`设置为`SQLCOM_SELECT`。这很重要，因为查询路径中的下一个函数在一个大型 switch 语句中使用它来进一步控制通过服务器的查询流。示例`SELECT`语句在字段列表中有三个字段。让我们试着在解析器代码中找到它们。寻找`add_item_to_list()`函数调用。这就是解析器检测字段并将它们放入`LEX`结构的地方。您还会看到调用解析器代码的几行代码，这些代码标识了字段列表的`*`选项。现在您已经得到了`sql_command`成员变量集和标识的字段。那么,`FROM`子句在哪里被检测到呢？寻找以`FROM join_table_list where_clause`开头的代码语句。这段代码是解析器的一部分，用于识别`FROM`和`WHERE`子句(以及其他)。处理这些子句的解析器的代码没有包含在[清单 3-8](#list8) 中，但是我想你已经明白了。如果您打开`sql_yacc.yy`源文件(位于`/sql`)，您现在应该能够找到所有这些语句，并看到`LEX`结构的其余部分是如何用`FROM`子句中的表列表和`WHERE`子句中的表达式填充的。

我希望这次解析器代码之旅有助于减轻通常伴随着检查 MySQL 系统这一部分的震惊和恐惧。稍后当我演示如何添加你自己的命令 MySQL SQL lexicon 时，我将回到系统的这一部分(更多细节见第 8 章)。[表 3-3](#Tab3) 列出了与 MySQL 解析器相关的源文件。

[表 3-3。](#_Tab3)MySQL 解析器

| 源文件 | 描述 |
| --- | --- |
| `/sql/lex.h` | 解析器支持的所有关键字和标记的符号表 |
| `/sql/lex_symbol.h` | 符号表的类型定义 |
| `/sql/sql_lex.h` | 法律结构的定义 |
| `/sql/sql_lex.cc` | Lex 类的定义 |
| `/sql/sql_yacc.yy` | 莱克斯/YACC 解析器代码 |
| `/sql/sql_parse.cc` | 包含除词法分析器之外的大多数查询路由和分析功能 |

![image](img/sq.jpg) **注意**不要编辑文件`sql_yacc.cc`、`sql_yacc.h`或`lex_hash.h`。这些文件由其他实用程序生成。详见第 7 章。

为优化准备查询

尽管从 MySQL 文档来看，解析器结束和优化器开始的界限并不清楚(存在矛盾)，但是从优化器的定义来看，源代码的路由和控制部分可以被视为优化器的一部分。为了避免混淆，我将把下一组函数称为优化器的准备阶段。

这些准备功能中的第一个是`mysql_execute_command()`功能(位于`/sql/sql_parse.cc`)。这个名称使您相信您实际上正在执行查询，但事实并非如此。该函数执行优化查询所需的许多设置步骤。复制了`LEX`结构，并设置了几个变量来帮助查询优化和后期执行。你可以在清单 3-9 中的[函数的浓缩视图中看到这些操作。](#list9)

[***清单 3-9***](#_list9) 。函数的作用是

```sql
/**
  Execute command saved in thd and lex->sql_command.

  @param thd                       Thread handle

...

  @retval
    FALSE       OK
  @retval
    TRUE        Error
*/

int
mysql_execute_command(THD *thd)
{
  int res= FALSE;
  int  up_result= 0;
  LEX  *lex= thd->lex;
  /* first SELECT_LEX (have special meaning for many of non-SELECTcommands) */
  SELECT_LEX *select_lex= &lex->select_lex;
  /* first table of first SELECT_LEX */
  TABLE_LIST *first_table= select_lex->table_list.first;
  /* list of all tables in query */
  TABLE_LIST *all_tables;
  /* most outer SELECT_LEX_UNIT of query */
  SELECT_LEX_UNIT *unit= &lex->unit;
#ifdef HAVE_REPLICATION
  /* have table map for update for multi-update statement (BUG#37051) */
  bool have_table_map_for_update= FALSE;
#endif
  DBUG_ENTER("mysql_execute_command");

  ...

switch (lex->sql_command) {

...

  case SQLCOM_SHOW_STATUS_PROC:
  case SQLCOM_SHOW_STATUS_FUNC:
  case SQLCOM_SHOW_DATABASES:
  case SQLCOM_SHOW_TABLES:
  case SQLCOM_SHOW_TRIGGERS:
  case SQLCOM_SHOW_TABLE_STATUS:
  case SQLCOM_SHOW_OPEN_TABLES:
  case SQLCOM_SHOW_PLUGINS:
  case SQLCOM_SHOW_FIELDS:
  case SQLCOM_SHOW_KEYS:
  case SQLCOM_SHOW_VARIABLES:
  case SQLCOM_SHOW_CHARSETS:
  case SQLCOM_SHOW_COLLATIONS:
  case SQLCOM_SHOW_STORAGE_ENGINES:
  case SQLCOM_SHOW_PROFILE:
  case SQLCOM_SELECT:
  {
    thd->status_var.last_query_cost= 0.0;
    thd->status_var.last_query_partial_plans= 0;

    if ((res= select_precheck(thd, lex, all_tables, first_table)))
      break;

    res= execute_sqlcom_select(thd, all_tables);
    break;
  }

...
```

在这个函数中会发生许多有趣的事情。您将会注意到另一个 switch 语句，它使用了`SQLCOM`关键字。在示例查询中，您看到解析器将成员变量`lex->sql_command`设置为`SQLCOM_SELECT`。我已经在[的清单 3-9](#list9) 中为您提供了该案例陈述的精简视图。我没有包括许多其他的`SQLCOM`案例陈述。这是一个非常大的函数。因为它是查询处理的中心路由功能，所以它包含每个可能命令的案例。因此，源代码有几十页长。

让我们看看这个 case 语句的作用。注意 select_precheck()方法调用。该方法执行权限检查，查看用户是否可以使用表列表来执行命令，以验证访问权限。如果用户有访问权，处理继续到 execute_sqlcom_select()方法，如[清单 3-10](#list10) 所示。我将有关`DESCRIBE` ( `EXPLAIN`)命令的部分代码留给您来检查并弄清楚它是如何工作的。

[***清单 3-10***](#_list10) 。execute_sqlcom_command()函数

```sql
static bool execute_sqlcom_select(THD *thd, TABLE_LIST *all_tables)
{
  LEX       *lex= thd->lex;
  select_result *result= lex->result;
  bool res;
  /* assign global limit variable if limit is not given */
  {
    SELECT_LEX *param= lex->unit.global_parameters;
    if (!param->explicit_limit)
      param->select_limit=
        new Item_int((ulonglong) thd->variables.select_limit);
  }
  if (!(res= open_and_lock_tables(thd, all_tables, 0)))
  {
    if (lex->describe)
    {
      /*
        We always use select_send for EXPLAIN, even if it's an EXPLAIN
        for SELECT ... INTO OUTFILE: a user application should be able
        to prepend EXPLAIN to any query and receive output for it,
        even if the query itself redirects the output.
      */
      if (!(result= new select_send()))
        return 1;                               /* purecov: inspected */
      res= explain_query_expression(thd, result);
      delete result;
    }
    else
    {
      if (!result && !(result= new select_send()))
        return 1;                               /* purecov: inspected */
      select_result *save_result= result;
      select_result *analyse_result= NULL;
      if (lex->proc_analyse)
      {
        if ((result= analyse_result=
               new select_analyse(result, lex->proc_analyse)) == NULL)
          return true;
      }
      res= handle_select(thd, result, 0);
      delete analyse_result;
      if (save_result != lex->result)
        delete save_result;
    }
  }
  return res;
}
```

![image](img/sq.jpg) **注意**有一次当我修改代码时，我需要找到所有`EXPLAIN`调用的位置，这样我就可以根据特定的需要修改它们。我到处寻找，直到在解析器中找到它们。在莱克斯/YACC 代码的中间，有一个注释，大意是`DESCRIBE`是早期 Oracle 兼容性问题遗留下来的，正确的术语是`EXPLAIN`。注释是有用的，如果你能找到它们的话。

下一个有趣的函数调用是对`handle_select()`的调用。你可能在想，“我们不是刚做了手柄的事情吗？”`handle_select()`是另一个函数`mysql_select()`的包装器。[清单 3-11](#list11) 显示了`handle_select()`功能的完整代码。清单顶部附近是`select_lex->next_select()`操作，它检查将多个`SELECT`结果追加到一组结果中的`UNION`命令。除此之外，代码只调用链中的下一个函数`mysql_select()`。此时，您终于可以过渡到查询优化器子系统了。[表 3-4](#Tab4) 列出了与查询优化器相关的源文件。

![image](img/sq.jpg) **注意**这可能是代码中最容易受到未定义子系统影响的部分。虽然代码仍然非常有组织，但是在源代码的这一点上，子系统的边界是模糊的。

[***清单 3-11***](#_list11)handle _ select()函数

```sql
bool handle_select(THD *thd, select_result *result,
                   ulong setup_tables_done_option)
{
  bool res;
  LEX *lex= thd->lex;
  register SELECT_LEX *select_lex = &lex->select_lex;
  DBUG_ENTER("handle_select");
  MYSQL_SELECT_START(thd->query());

  if (lex->proc_analyse && lex->sql_command != SQLCOM_SELECT)
  {
    my_error(ER_WRONG_USAGE, MYF(0), "PROCEDURE", "non-SELECT");
    DBUG_RETURN(true);
  }

  if (select_lex->master_unit()->is_union() || 
      select_lex->master_unit()->fake_select_lex)
    res= mysql_union(thd, lex, result, &lex->unit, setup_tables_done_option);
  else
  {
    SELECT_LEX_UNIT *unit= &lex->unit;
    unit->set_limit(unit->global_parameters);
    /*
      'options' of mysql_select will be set in JOIN, as far as JOIN for
      every PS/SP execution new, we will not need reset this flag if 
      setup_tables_done_option changed for next rexecution
    */
    res= mysql_select(thd,
        select_lex->table_list.first,
        select_lex->with_wild, select_lex->item_list,
        select_lex->where,
        &select_lex->order_list,
        &select_lex->group_list,
        select_lex->having,
        select_lex->options | thd->variables.option_bits |
                      setup_tables_done_option,
        result, unit, select_lex);
  }
  DBUG_PRINT("info",("res: %d  report_error: %d", res,
       thd->is_error()));
  res|= thd->is_error();
  if (unlikely(res))
    result->abort_result_set();

  MYSQL_SELECT_DONE((int) res, (ulong) thd->limit_found_rows);
  DBUG_RETURN(res);
}
```

[表 3-4。](#_Tab4)查询优化器

| 源文件 | 描述 |
| --- | --- |
| `/sql/sql_parse.cc` | 大部分解析器代码都在这个文件中 |
| `/sql/sql_select.cc` | 包含一些优化功能和选择功能的实现 |
| `/sql/sql_prepare.cc` | 包含优化程序的准备方法。 |
| `/sql/sql_executor.cc` | 包含优化程序的执行方法。 |

优化查询

终于！你在优化器那里。然而，如果您去寻找那个名字的源文件或类，您将找不到它。虽然`JOIN`类包含一个名为`optimize()`的方法，但是优化器实际上是一个流控制和子功能的集合，旨在找到执行查询的最短路径。花哨的算法、查询路径和编译后的查询发生了什么变化？回想一下我们在[第 2 章](02.html)的架构讨论，MySQL 查询优化器是一个非传统的混合优化器，它结合了已知的最佳实践和基于成本的路径选择。在代码的这一点上，最佳实践部分开始发挥作用。

其中一个最佳实践的例子是标准化`WHERE`子句表达式中的参数。示例查询使用带有表达式`Employees.department = 'EGR'`的`WHERE`子句，但是该子句可以写成`'EGR' = Employees.department`，仍然是正确的(它返回相同的结果)。这是一个传统的基于成本的优化器可以生成多个计划的例子——每个表达式变量一个计划。MySQL 使用的许多最佳实践的几个例子是:

*   *常数传播——使用常数移除传递连接词。比如你有* *a=b='c'* ，*传递性定律陈述* *a='c'* 。*这种优化消除了那些内部等式，从而减少了求值的次数。例如，SQL 命令**SELECT * FROM table 1 WHERE column 1 = 12 AND NOT(column 3 = 17 OR column 2 = column 1)**将被简化为**SELECT * FROM table 1 WHERE column 1 = 12 AND column 3<>17 AND column 2<>12*。
*   *死代码消除——消除始终为真的条件。例如，如果您有* *a=b 和 1=1* ，**和 1=1* *条件被移除。对于 always- false 条件也是如此，在这种情况下，可以删除 false 表达式，而不会影响子句的其余部分。例如，SQL 命令* *SELECT * FROM table1，其中 column1 = 12，column2 = 13，column1 < column2* *将被简化为* *SELECT * FROM table1，其中 column1 = 12，column2 = 13* 。*
**   *范围查询——将* *子句中的* *转换为析取列表。例如，如果在(1，2，3)* ，*中有一个*， *变换将是 a = 1 或 a = 2 或 a = 3* 。*这有助于简化表达式的计算。例如，SQL 命令**SELECT * FROM table 1 WHERE column 1 = 12 或 column1 = 17 或 column1 = 21* *将简化为**SELECT * FROM table 1 WHERE column 1 IN(12，17，21)* 。*

 *我希望这一小部分例子能够让您对世界上最成功的非传统查询优化器的内部工作原理有所了解。简而言之，它对于数量惊人的查询非常有效。

嗯，我说得太快了。在优化领域，`mysql_select()`函数也没有太多变化。似乎`mysql_select()`函数只是锁定表，然后调用`mysql_execute_select()`函数。你又一次处于另一个模糊的边界。[清单 3-12](#list12) 显示了`mysql_select()`函数的摘录。

[***清单 3-12***](#_list12)MySQL _ select()函数

```sql
/**
  An entry point to single-unit select (a select without UNION).

  @param thd                  thread handler
  @param tables               list of all tables used in this query.
                              The tables have been pre-opened.
  @param wild_num             number of wildcards used in the top level 
                              select of this query.
                              For example statement
                              SELECT *, t1.*, catalog.t2.* FROM t0, t1, t2;
                              has 3 wildcards.
  @param fields               list of items in SELECT list of the top-level
                              select
                              e.g. SELECT a, b, c FROM t1 will have Item_field
                              for a, b and c in this list.
  @param conds                top level item of an expression representing
                              WHERE clause of the top level select
  @param order                linked list of ORDER BY agruments
  @param group                linked list of GROUP BY arguments
  @param having               top level item of HAVING expression
  @param select_options       select options (BIG_RESULT, etc)
  @param result               an instance of result set handling class.
                              This object is responsible for send result
                              set rows to the client or inserting them
                              into a table.
  @param unit                 top-level UNIT of this query
                              UNIT is an artificial object created by the
                              parser for every SELECT clause.
                              e.g.
                              SELECT * FROM t1 WHERE a1 IN (SELECT * FROM t2)
                              has 2 unions.
  @param select_lex           the only SELECT_LEX of this query

  @retval
    false  success
  @retval
    true   an error
*/

bool
mysql_select(THD *thd,
             TABLE_LIST *tables, uint wild_num, List<Item> &fields,
             Item *conds, SQL_I_List<ORDER> *order, SQL_I_List<ORDER> *group,
             Item *having, ulonglong select_options,
             select_result *result, SELECT_LEX_UNIT *unit,
             SELECT_LEX *select_lex)
{
  bool free_join= true;
  uint og_num= 0;
  ORDER *first_order= NULL;
  ORDER *first_group= NULL;
  DBUG_ENTER("mysql_select");

  if (order)
  {
    og_num= order->elements;
    first_order= order->first;
  }
  if (group)
  {
    og_num+= group->elements;
    first_group= group->first;
  }

  if (mysql_prepare_select(thd, tables, wild_num, fields,
                       conds, og_num, first_order, first_group, having,
                       select_options, result, unit,
                       select_lex, &free_join))
  {
    if (free_join)
    {
      THD_STAGE_INFO(thd, stage_end);
      (void) select_lex->cleanup();
    }
    DBUG_RETURN(true);
  }

  if (! thd->lex->is_query_tables_locked())
  {
    /*
      If tables are not locked at this point, it means that we have delayed
      this step until after the prepare stage (i.e. this moment). This allows us to
      do better partition pruning and avoid locking unused partitions.
      As a consequence, in such a case, the prepare stage can rely only on
      metadata about tables used and not data from them.
      We need to lock tables now in order to proceed with the remaining
      stages of query optimization and execution.
    */
    if (lock_tables(thd, thd->lex->query_tables, thd->lex->table_count, 0))
    {
      if (free_join)
      {
        THD_STAGE_INFO(thd, stage_end);
        (void) select_lex->cleanup();
      }
      DBUG_RETURN(true);
    }

    /*
      Only register query in cache if it tables were locked above.

      Tables must be locked before storing the query in the query cache.
      Transactional engines must have been signalled that the statement started,
      which external_lock signals.
    */
    query_cache_store_query(thd, thd->lex->query_tables);
  }

  DBUG_RETURN(mysql_execute_select(thd, select_lex, free_join));
}
```

所有这些最佳实践在哪里？他们在`JOIN`班！对`JOIN`类中的优化器源代码的详细检查将花费比这本书更多的页面来呈现任何有意义的深度。简单地说，优化器很复杂，也很难检查。幸运的是，很少有人需要深入探究 MySQL。但是，欢迎您这样做！我将集中精力对`optimizer from the mysql_execute_select() function`进行更高层次的审查。

该函数中的下一个主要函数调用是`join->exec()`方法。不过，首先让我们看看在[清单 3-13](#list13) 中的`mysql_execute_select()`方法中发生了什么。

[***清单 3-13。***](#_list13)MySQL _ execute _ select()函数

```sql
/**
  Execute stage of mysql_select.

  @param thd                  thread handler
  @param select_lex           the only SELECT_LEX of this query
  @param free_join            if join should be freed

  @return Operation status
    @retval false  success
    @retval true   an error

  @note tables must be opened and locked before calling mysql_execute_select.
*/

static bool
mysql_execute_select(THD *thd, SELECT_LEX *select_lex, bool free_join)
{
  bool err;
  JOIN* join= select_lex->join;

  DBUG_ENTER("mysql_execute_select");
  DBUG_ASSERT(join);

  if ((err= join->optimize()))
  {
    goto err; // 1
  }

  if (thd->is_error())
    goto err;

  if (join->select_options & SELECT_DESCRIBE)
  {
    join->explain();
    free_join= false;
  }
  else
    join->exec();

err:
  if (free_join)
  {
    THD_STAGE_INFO(thd, stage_end);
    err|= select_lex->cleanup();
    DBUG_RETURN(err || thd->is_error());
  }
  DBUG_RETURN(join->error);
}
```

现在我们可以在`mysql_execute_select()`函数中看到优化器代码的入口。我们看到了对在 prepare 方法中创建的现有 JOIN 类的引用。在代码中再往下一点，我们看到了我们期望的方法——`optimize()`调用。此后不久，我们看到了通过 JOIN 类执行查询的`exec()`方法。[表 3-5](#Tab5) 列出了与查询优化相关的更重要的源文件。

[表 3-5。](#_Tab5)查询优化

| 源文件 | 描述 |
| --- | --- |
| `/sql/abstract_query_plan.cc` | 实现了一个抽象查询计划接口，用于检查查询计划的某些方面，而无需访问 mysqld 内部类(JOIN_TAB、SQL_SELECT 等)。)直接。 |
| `/sql/sql_optimizer.cc` | 包含优化器核心功能 |
| `/sql/sql_planner.cc` | 包含帮助优化器确定检索连接行的表顺序的类。 |
| `/sql/sql_select.h` | 选择功能中用于支持`the SELECT`命令的结构定义 |
| `/sql/sql_select.cc` | 包含一些优化功能和选择功能的实现 |
| `/sql/sql_union.cc` | 用于执行联合操作的代码。 |

执行查询

与优化器一样，查询执行使用一组最佳实践来执行查询。例如，查询执行子系统检测特殊子句，如`ORDER BY`和`DISTINCT,`，并将这些操作的控制路由到为快速排序和元组消除而设计的方法。

这种活动大部分发生在`JOIN`类的方法中。清单 3-14 展示了一个`join::exec()`方法的浓缩视图。请注意，还有另一个函数调用，调用的函数名称中包含了`select`。果然，还有一个调用需要调用一个名为`do_select()`的函数。看看这个函数调用的参数。您现在开始看到字段列表等内容。这是否意味着你正在接近读取数据？没错。事实上，`do_select()`函数正是为此而设计的高级包装器。

[***清单 3-14***](#_list14)join::exec()函数

```sql
void
JOIN::exec()
{
  Opt_trace_context * const trace= &thd->opt_trace;
  Opt_trace_object trace_wrapper(trace);
  Opt_trace_object trace_exec(trace, "join_execution");
  trace_exec.add_select_number(select_lex->select_number);
  Opt_trace_array trace_steps(trace, "steps");
  List<Item> *columns_list= &fields_list;
  DBUG_ENTER("JOIN::exec");

...

  THD_STAGE_INFO(thd, stage_sending_data);
  DBUG_PRINT("info", ("%s", thd->proc_info));
  result->send_result_set_metadata(*fields,
                                Protocol::SEND_NUM_ROWS | Protocol::SEND_EOF);
  error= do_select(this);
  /* Accumulate the counts from all join iterations of all join parts. */
  thd->inc_examined_row_count(examined_rows);
  DBUG_PRINT("counts", ("thd->examined_row_count: %lu",
                        (ulong) thd->get_examined_row_count()));

  DBUG_VOID_RETURN;
}
```

还有一个函数调用看起来很有意思。注意代码语句`result->send_result_set_metadata ()`。这个函数如其名所示。这个函数将字段头发送给客户端。正如您所猜测的，还有其他方法可以将结果发送给客户端。我将在第四章的[中讨论这些方法。请注意`thd->inc_examined_row_count=`任务。这将记录计数值保存在`THD`类中。我们来看看那个`do_select()`功能。](04.html)

你可以在[清单 3-15](#list15) 所示的`do_select()`方法中看到，一些重要的事情正在发生。请注意最后突出显示的代码语句。语句`join->result->send_eof()`看起来好像代码正在某处发送一个文件结束标志。它确实向客户端发送了一个文件结束信号。那么结果在哪里呢？它们在`first_select()`函数中生成(映射到`sub_select())`)。接下来让我们看看这个函数。

[***清单 3-15***](#_list15)do _ select()函数

```sql
static int
do_select(JOIN *join)
{
  int rc= 0;
  enum_nested_loop_state error= NESTED_LOOP_OK;
  DBUG_ENTER("do_select");

...

  else
  {
    JOIN_TAB *join_tab= join->join_tab + join->const_tables;
    DBUG_ASSERT(join->tables);
    error= join->first_select(join,join_tab,0);
    if (error >= NESTED_LOOP_OK)
      error= join->first_select(join,join_tab,1);
  }

  join->thd->limit_found_rows= join->send_records;
  /* Use info provided by filesort. */
  if (join->order)
  {
    // Save # of found records prior to cleanup
    JOIN_TAB *sort_tab;
    JOIN_TAB *join_tab= join->join_tab;
    uint const_tables= join->const_tables;

    // Take record count from first non constant table or from last tmp table
    if (join->tmp_tables > 0)
      sort_tab= join_tab + join->tables + join->tmp_tables - 1;
    else
    {
      DBUG_ASSERT(join->tables > const_tables);
      sort_tab= join_tab + const_tables;
    }
    if (sort_tab->filesort &&
        sort_tab->filesort->sortorder)
    {
      join->thd->limit_found_rows= sort_tab->records;
    }
  }

  {
    /*
      The following will unlock all cursors if the command wasn't an
      update command
    */
    join->join_free(); // Unlock all cursors
  }
  if (error == NESTED_LOOP_OK)
  {
    /*
      Sic: this branch works even if rc != 0, e.g. when
      send_data above returns an error.
    */
    if (join->result->send_eof())
      rc= 1;                                  // Don't send error
    DBUG_PRINT("info",("%ld records output", (long) join->send_records));
  }

...

}
```

现在你有所进展了！花点时间浏览一下清单 3-16 。这个清单显示了`sub_select()`函数的一个精简视图。注意，代码以一个名为`READ_RECORD`的结构的初始化开始。`READ_RECORD`结构包含从表中读取的元组。系统初始化表，开始顺序读取记录，然后一次读取一条记录，直到所有记录都被读取。

[***清单 3-16***](#_list16)sub _ select()函数

```sql
enum_nested_loop_state
sub_select(JOIN *join,JOIN_TAB *join_tab,bool end_of_records)
{
  DBUG_ENTER("sub_select");

  join_tab->table->null_row=0;
  if (end_of_records)
  {
    enum_nested_loop_state nls=
      (*join_tab->next_select)(join,join_tab+1,end_of_records);
    DBUG_RETURN(nls);
  }
  READ_RECORD *info= &join_tab->read_record;

...

  join->thd->get_stmt_da()->reset_current_row_for_warning();

  enum_nested_loop_state rc= NESTED_LOOP_OK;
  bool in_first_read= true;
  while (rc == NESTED_LOOP_OK && join->return_tab >= join_tab)
  {
    int error;
    if (in_first_read)
    {
      in_first_read= false;
      error= (*join_tab->read_first_record)(join_tab);
    }
    else
      error= info->read_record(info);

    DBUG_EXECUTE_IF("bug13822652_1", join->thd->killed= THD::KILL_QUERY;);

    if (error > 0 || (join->thd->is_error()))   // Fatal error
      rc= NESTED_LOOP_ERROR;
    else if (error < 0)
      break;
    else if (join->thd->killed) // Aborted by user
    {
      join->thd->send_kill_message();
      rc= NESTED_LOOP_KILLED;
    }
    else
    {
      if (join_tab->keep_current_rowid)
        join_tab->table->file->position(join_tab->table->record[0]);
      rc= evaluate_join_record(join, join_tab);
    }
  }

  if (rc == NESTED_LOOP_OK && join_tab->last_inner && !join_tab->found)
    rc= evaluate_null_complemented_join_record(join, join_tab);

  DBUG_RETURN(rc);
}
```

![image](img/sq.jpg) **注意**清单 3-16 中的代码比我展示的其他例子更加简洁。主要原因是这段代码使用了相当多的高级编程技术，比如递归和函数指针重定向。然而，所提出的概念对于示例查询是准确的。

控制返回到`JOIN`类，用于计算表达式和执行关系运算符。在结果被处理之后，它们被传输到客户端，然后控制返回到`sub_select()`函数，在这里发送文件结束标志来告诉客户端没有更多的结果。我希望这篇文章满足了您的好奇心，如果没有别的，也希望它提高了您对真实世界数据库系统复杂性的理解。请随意再次回顾此教程，直到您对基本流程感到满意为止。我将在下一节讨论一些更重要的类和结构。

支持库

MySQL 源代码树中有许多附加的库。Oracle 长期以来一直致力于封装和优化许多用于访问受支持的操作系统和硬件的常用例程。这些库中的大部分被设计成使代码与操作系统和硬件无关。这些库使得编写代码成为可能，这样特定的平台特性就不会迫使您编写专门的代码。这些库包括用于管理有效的字符串处理、哈希表、链表、内存分配等的库。表 3-6 列出了一些比较常见的库的用途和位置。

![image](img/sq.jpg) **提示**发现你正在使用的例程是否有库的最好方法是使用文本搜索工具查看`/mysys`目录下的源代码文件。大多数包装函数都有一个类似于它们原始函数的名字。例如，`my_alloc.c`实现了`malloc`包装器。

[表 3-6。](#_Tab6)支持库

| 源文件 | 公用事业 |
| --- | --- |
| `/mysys/array.c` | 数组运算 |
| `/include/hash.h`和`/mysys/hash.c` | 散列表 |
| `/mysys/list.c` | 合框架 |
| `/mysys/my_alloc.c` | 存储器分配 |
| `/strings/*.c` | 基本内存和字符串操作例程 |
| `/mysys/string.c` | 字符串操作 |
| `/mysys/my_pthread.c` | 穿线 |

重要的类和结构

MySQL 源代码中相当多的类和结构被认为是系统成功的关键因素。要全面了解 MySQL 源代码，需要学习系统中使用的所有关键类和结构的基础知识。了解什么存储在哪个类中或者结构包含什么可以帮助您很好地集成您的修改。以下部分描述了这些关键的类和结构。

项目 _ 类别

渗透到整个子系统的一个类是`ITEM_ class`。我称之为`ITEM_`是因为许多类都是从基类`ITEM`中派生出来的，甚至还有从基类中派生出来的类。这些衍生工具用于存储和操作系统中的大量数据(项目)。这些包括参数(如在`WHERE`子句中)、标识符、时间、字段、函数、数量、字符串和许多其他内容。清单 3-17 显示了一个`ITEM`基类的浓缩视图。该结构在`/sql/item.h`源文件中定义，在`/sql/item.cc`源文件中实现。附加的子类在以其封装的数据命名的文件中定义和实现。比如 function 子类在`/sql/item_func.h`中定义，在`/sql/item_func.cc`中实现。

[***清单 3-17***](#_list17)ITEM _ Class

```sql
class Item
{
  Item(const Item &); /* Prevent use of these */
  void operator=(Item &);
  /* Cache of the result of is_expensive(). */
  int8 is_expensive_cache;
  virtual bool is_expensive_processor(uchar *arg) { return 0; }

public:
  static void *operator new(size_t size) throw ()
  { return sql_alloc(size); }
  static void *operator new(size_t size, MEM_ROOT *mem_root) throw ()
  { return alloc_root(mem_root, size); }
  static void operator delete(void *ptr,size_t size) { TRASH(ptr, size); }
  static void operator delete(void *ptr, MEM_ROOT *mem_root) {}

  enum Type {FIELD_ITEM= 0, FUNC_ITEM, SUM_FUNC_ITEM, STRING_ITEM,
      INT_ITEM, REAL_ITEM, NULL_ITEM, VARBIN_ITEM,
      COPY_STR_ITEM, FIELD_AVG_ITEM, DEFAULT_VALUE_ITEM,
      PROC_ITEM,COND_ITEM, REF_ITEM, FIELD_STD_ITEM,
      FIELD_VARIANCE_ITEM, INSERT_VALUE_ITEM,
             SUBSELECT_ITEM, ROW_ITEM, CACHE_ITEM, TYPE_HOLDER,
             PARAM_ITEM, TRIGGER_FIELD_ITEM, DECIMAL_ITEM,
             XPATH_NODESET, XPATH_NODESET_CMP,
             VIEW_FIXER_ITEM};

  enum cond_result { COND_UNDEF,COND_OK,COND_TRUE,COND_FALSE };

  enum traverse_order { POSTFIX, PREFIX };

  /* Reuse size, only used by SP local variable assignment, otherwize 0 */
  uint rsize;

  /*
    str_values's main purpose is to be used to cache the value in
    save_in_field
  */
  String str_value;

  Item_name_string item_name;  /* Name from select */
  Item_name_string orig_name;  /* Original item name (if it was renamed)*/

  /**
     Intrusive list pointer for free list. If not null, points to the next
     Item on some Query_arena's free list. For instance, stored procedures
     have their own Query_arena's.

     @see Query_arena::free_list
   */
  Item *next;
  uint32 max_length;                    /* Maximum length, in bytes */
  /**
     This member has several successive meanings, depending on the phase we're
     in:
     - during field resolution: it contains the index, in the "all_fields"
     list, of the expression to which this field belongs; or a special
     constant UNDEF_POS; see st_select_lex::cur_pos_in_all_fields and
     match_exprs_for_only_full_group_by().
     - when attaching conditions to tables: it says whether some condition
     needs to be attached or can be omitted (for example because it is already
     implemented by 'ref' access)
     - when pushing index conditions: it says whether a condition uses only
     indexed columns
     - when creating an internal temporary table: it says how to store BIT
     fields
     - when we change DISTINCT to GROUP BY: it is used for book-keeping of
     fields.
  */
  int marker;
  uint8 decimals;
  my_bool maybe_null; /* If item may be null */
  my_bool null_value; /* if item is null */
  my_bool unsigned_flag;
  my_bool with_sum_func;
  my_bool fixed;                        /* If item fixed with fix_fields */
  DTCollation collation;
  Item_result cmp_context;              /* Comparison context */
 protected:
  my_bool with_subselect;               /* If this item is a subselect or some
                                           of its arguments is or contains a
                                           subselect. Computed by fix_fields
                                           and updated by update_used_tables. */
  my_bool with_stored_program;          /* If this item is a stored program
                                           or some of its arguments is or
                                           contains a stored program.
                                           Computed by fix_fields and updated
                                           by update_used_tables. */

  /**
    This variable is a cache of 'Needed tables are locked'. True if either
    'No tables locks is needed' or 'Needed tables are locked'.
    If tables are used, then it will be set to
    current_thd->lex->is_query_tables_locked().

    It is used when checking const_item()/can_be_evaluated_now().
  */
  bool tables_locked_cache;
 public:
  // alloc & destruct is done as start of select using sql_alloc
  Item();
  /*
     Constructor used by Item_field, Item_ref & aggregate (sum) functions.
     Used for duplicating lists in processing queries with temporary
     tables
     Also it used for Item_cond_and/Item_cond_or for creating
     top AND/OR structure of WHERE clause to protect it from
     optimization changes in prepared statements
  */
  Item(THD *thd, Item *item);
  virtual ∼Item()
  {
#ifdef EXTRA_DEBUG
    item_name.set(0);
#endif
  } /*lint -e1509 */
  void rename(char *new_name);
  void init_make_field(Send_field *tmp_field,enum enum_field_types type);
  virtual void cleanup();
  virtual void make_field(Send_field *field);
  virtual Field *make_string_field(TABLE *table);
  virtual bool fix_fields(THD *, Item **);
  ...

};
```

LEX 结构

`LEX`结构负责查询及其部分的内部表示(内存存储)。然而，不仅仅如此。`LEX`结构用于以有组织的方式存储查询的所有部分。有字段、表、表达式以及构成任何查询的所有部分的列表。

当解析器发现查询的各个部分时,`LEX`结构由解析器填充。因此，当解析器完成时，`LEX`结构包含了优化和执行查询所需的一切。[清单 3-18](#list18) 显示了`LEX`结构的浓缩视图。该结构在`/sql/sql_lex.h`源文件中定义。

[***清单 3-18***](#_list18)LEX 结构

```sql
struct LEX: public Query_tables_list
{
  SELECT_LEX_UNIT unit;                         /* most upper unit */
  SELECT_LEX select_lex;                        /* first SELECT_LEX */
  /* current SELECT_LEX in parsing */
  SELECT_LEX *current_select;
  /* list of all SELECT_LEX */
  SELECT_LEX *all_selects_list;

  char *length,*dec,*change;
  LEX_STRING name;
  char *help_arg;
  char* to_log;                                 /* For PURGE MASTER LOGS TO */
  char* x509_subject,*x509_issuer,*ssl_cipher;
  String *wild;
  sql_exchange *exchange;
  select_result *result;
  Item *default_value, *on_update_value;
  LEX_STRING comment, ident;
  LEX_USER *grant_user;
  XID *xid;
  THD *thd;

  /* maintain a list of used plugins for this LEX */

  DYNAMIC_ARRAY plugins;
  plugin_ref plugins_static_buffer[INITIAL_LEX_PLUGIN_LIST_SIZE];

  const CHARSET_INFO *charset;

...

};
```

网状结构

`NET`结构负责存储与客户端通信相关的所有信息。[清单 3-19](#list19) 显示了`NET`结构的浓缩视图。`buff`成员变量用于存储原始的通信数据包(当它们组合起来形成 SQL 语句时)。正如您将在后面的章节中看到的，帮助器函数填充、读取和传输来自客户端的数据包。两个例子是:

*   `my_net_write()`，将数据包从`NET`结构写入网络协议
*   `my_net_read()`，将数据包从网络协议读入`NET`结构

您可以在`/include/mysql_com.h`中找到整套网络通信功能。

[***清单 3-19***](#_list19) 网络结构

```sql
typedef struct st_net {
#if !defined(CHECK_EMBEDDED_DIFFERENCES) || !defined(EMBEDDED_LIBRARY)
  Vio *vio;
  unsigned char *buff,*buff_end,*write_pos,*read_pos;
  my_socket fd; /* For Perl DBI/dbd */
  /*
    The following variable is set if we are doing several queries in one
    command ( as in LOAD TABLE ... FROM MASTER ),
    and do not want to confuse the client with OK at the wrong time
  */
  unsigned long remain_in_buf,length, buf_length, where_b;
  unsigned long max_packet,max_packet_size;
  unsigned int pkt_nr,compress_pkt_nr;
  unsigned int write_timeout, read_timeout, retry_count;
  int fcntl;
  unsigned int *return_status;
  unsigned char reading_or_writing;
  char save_char;
  my_bool unused1; /* Please remove with the next incompatible ABI change */
  my_bool unused2; /* Please remove with the next incompatible ABI change */
  my_bool compress;
  my_bool unused3; /* Please remove with the next incompatible ABI change. */
  /*
    Pointer to query object in query cache, do not equal NULL (0) for
    queries in cache that have not stored its results yet
  */
#endif
  /*
    Unused, please remove with the next incompatible ABI change.
  */
  unsigned char *unused;
  unsigned int last_errno;
  unsigned char error; 
  my_bool unused4; /* Please remove with the next incompatible ABI change. */
  my_bool unused5; /* Please remove with the next incompatible ABI change. */
  /** Client library error message buffer. Actually belongs to struct MYSQL. */
  char last_error[MYSQL_ERRMSG_SIZE];
  /** Client library sqlstate buffer. Set along with the error message. */
  char sqlstate[SQLSTATE_LENGTH+1];
  /**
    Extension pointer, for the caller private use.
    Any program linking with the networking library can use this pointer,
    which is handy when private connection specific data needs to be
    maintained.
    The mysqld server process uses this pointer internally,
    to maintain the server internal instrumentation for the connection.
  */
  void *extension;
} NET;
```

THD 类

在前面的源代码之旅中，您看到了许多对`THD`类的引用。事实上，对于每个连接，正好有一个`THD`对象。thread 类对于成功的线程执行至关重要，它参与了从实现访问控制到向客户端返回结果的所有操作。结果，`THD`类出现在服务器中运行的几乎每个子系统或功能中。清单 3-20 显示了一个`THD`类的浓缩视图。花点时间浏览一些成员变量和方法。如您所见，这是一个很大的类(我已经省略了很多方法)。该类在`/sql/sql_class.h`源文件中定义，并在`/sql/sql_class.cc`源文件中实现。

[***清单 3-20***](#_list20) 。THD 类

```sql
class THD :public MDL_context_owner,
           public Statement,
           public Open_tables_state
{
private:

  ...

  String  packet; // dynamic buffer for network I/O
  String  convert_buffer;               // buffer for charset conversions
  struct  rand_struct rand; // used for authentication
  struct  system_variables variables;       // Changeable local variables
  struct  system_status_var status_var; // Per thread statistic vars
  struct  system_status_var *initial_status_var; /* used by show status */
  THR_LOCK_INFO lock_info;              // Locking info of this thread
  /**
    Protects THD data accessed from other threads:
    - thd->query and thd->query_length (used by SHOW ENGINE
      INNODB STATUS and SHOW PROCESSLIST
    - thd->mysys_var (used by KILL statement and shutdown).
    Is locked when THD is deleted.
  */
  mysql_mutex_t LOCK_thd_data;

  ...

};
```

读取记录结构

正如我们前面看到的，`READ_RECORD`结构用于包含来自存储引擎的元组，一旦优化器将它标识为要返回给用户的行。我们将存储引擎的讨论留到第 10 章[中。清单 3-21](10.html) 显示了`READ_RECORD`的结构。请注意，这里有回调到`JOIN`类方法的函数指针、引用`THD`类的变量、记录长度以及指向记录缓冲区本身的指针。如果您对了解行在系统中的存储方式感兴趣，可以研究一下这个类中的许多方法。

[***清单 3-21***](#_list21) 。读取记录结构

```sql
struct READ_RECORD
{
  typedef int (*Read_func)(READ_RECORD*);
  typedef void (*Unlock_row_func)(st_join_table *);
  typedef int (*Setup_func)(JOIN_TAB*);

  TABLE *table;                                 /* Head-form */
  TABLE **forms;                                /* head and ref forms */
  Unlock_row_func unlock_row;
  Read_func read_record;
  THD *thd;
  SQL_SELECT *select;
  uint cache_records;
  uint ref_length,struct_length,reclength,rec_cache_size,error_offset;
  uint index;
  uchar *ref_pos; /* pointer to form->refpos */
  uchar *record;
  uchar *rec_buf;                /* to read field values  after filesort */
  uchar       *cache,*cache_pos,*cache_end,*read_positions;
  struct st_io_cache *io_cache;
  bool print_error, ignore_not_found_rows;

...

  Copy_field *copy_field;
  Copy_field *copy_field_end;
public:
  READ_RECORD() {}
};
```

MySQL 外挂程式

不提到架构中最重要和最新的创新之一，MySQL 系统之旅是不完整的。MySQL 现在支持一个插件工具，允许动态加载系统特性。这不仅意味着用户可以通过只加载她需要的东西来定制她的系统，还意味着 MySQL 的开发者可以以更加模块化的设计来开发功能。存储引擎子系统是为使用新的插件机制而重新设计的子系统的一个例子。还有很多其他的。我们将在后面的章节中更详细地看到插件是如何工作的。现在，让我们讨论插件是如何加载和卸载的，以及如何确定插件的状态。

`mysql`数据库中的`plugins`表用于在启动时加载插件。该表只包含两列，`name`和`dl`，它们存储插件名和库名。启动时，除非用户关闭了插件，否则系统会加载在`dl`栏中指定的每个库，并为其各自的库启动在`name`栏中指定的每个插件。然后，可以手动修改这个表来管理插件，但是不推荐这样做，因为有些库可以包含多个插件。稍后，当我们检查`mysql_plugin`客户端应用时，您将看到这个概念的实际应用。

有些插件被认为是“内置”的，在默认情况下是可用的，在某些情况下是自动加载(安装)的。这包括许多存储引擎以及标准身份验证机制、二进制日志等。其他插件可以通过安装来使用，同样，也可以通过卸载来禁用。您可以在在线参考手册的“服务器插件”部分找到关于管理插件的完整文档。

安装和卸载插件

插件可以使用特殊的 SQL 命令作为启动选项来加载和卸载，也可以通过`mysql_plugin`客户端应用来加载和卸载。要加载一个插件，首先需要将正确的库放入由系统变量`plugin_dir`中的路径指定的插件目录中。您可以从 MySQL 中找到该变量的当前值，如下所示:

```sql
mysql> SHOW VARIABLES LIKE 'plugin_dir';
+---------------+------------------------------+
| Variable_name | Value                        |
+---------------+------------------------------+
| plugin_dir    | /usr/local/mysql/lib/plugin/ |
+---------------+------------------------------+
1 row in set (0.00 sec)
```

可以看到路径是`/usr/local/mysql/lib/plugin/`。当你构建你的插件或者安装一个现存的插件时，你必须首先把你的库放到插件目录中。然后，您可以执行类似于以下内容的安装插件命令:

```sql
mysql> INSTALL PLUGIN something_cool SONAME some_cool_feature.so;
```

在这里，我们正在加载一个名为`something_cool`的插件，它包含在名为`some_cool_feature.so`的已编译库模块中。

卸载插件更容易，如下所示。这里，我们正在卸载刚刚安装的同一个插件。

```sql
mysql> UNINSTALL PLUGIN something_cool;
```

插件也可以在启动时使用`--plugin-load`选项安装。这个选项可以被多次列出——每个插件一次——或者，它可以接受一个分号分隔的列表(没有空格)。如何使用此选项的示例包括:

```sql
mysqld ... --plugin-load=something_cool=some_cool_feature.so   
mysqld ... --plugin-load=something_cool=some_cool_feature.so;something_even_better=even_better.so
```

![image](img/sq.jpg) **注意**MySQL 文档使用术语*安装*和*卸载*来动态加载和卸载插件。文档使用术语 *load* 来指定通过启动选项使用的插件。

还可以使用`mysql_plugin`客户端应用加载和卸载插件。该应用要求服务器停止工作。它将以引导模式启动服务器，加载或卸载插件，然后关闭引导的服务器。该应用主要用于停机期间的服务器维护，或者作为一种诊断工具，用于通过消除插件(以简化诊断)来尝试重启故障服务器。

客户端应用使用一个配置文件来保存关于插件的相关数据，比如库的名称和其中包含的所有插件。是的，一个插件库可能包含不止一个插件。以下是`daemon_example`插件的配置文件示例:

```sql
#
# Plugin configuration file. Place the following on a separate line:
#
# library binary file name (without .so or .dll)
# component_name
# [component_name] - additional components in plugin
#
libdaemon_example
daemon_example
```

要使用`mysql_plugin`应用安装(启用)或卸载(禁用)插件，请至少指定插件的名称:`ENABLE`或`DISABLE`、`basedir`、`datadir`、`plugin-dir`和`plugin-ini`选项。如果 mysql_plugin 应用不在您的路径上，您可能还需要指定`my-print-defaults`选项。应用以静默方式运行，但是您可以打开详细度来查看应用的运行情况。(使用选项:`-vvv`)。下面展示了如何使用 mysql_plugin 客户端应用加载`daemon_example`插件。该示例从 MySQL 安装的 bin 文件夹中运行。

```sql
cbell$ sudo ./mysql_plugin --datadir=/mysql_path/data/ --basedir=/mysql_path/ --plugin-dir=../plugin/daemon_example/ --plugin-ini=../plugin/daemon_example/daemon_example.ini --my-print-defaults=../extra daemon_example ENABLE -vvv
# Found tool 'my_print_defaults' as '/mysql_path/bin/my_print_defaults'.
# Command: /mysql_path/bin/my_print_defaults mysqld > /var/tmp/txtdoaw2b
#    basedir = /mysql_path/
# plugin_dir = ../plugin/daemon_example/
#    datadir = /mysql_path/data/
# plugin_ini = ../plugin/daemon_example/daemon_example.ini
# Found tool 'mysqld' as '/mysql_path/bin/mysqld'.
# Found plugin 'daemon_example' as '../plugin/daemon_example/libdaemon_example.so'
# Enabling daemon_example...
# Query: REPLACE INTO mysql.plugin VALUES ('daemon_example','libdaemon_example.so');
# Command: /mysql_path/bin/mysqld --no-defaults --bootstrap --datadir=/mysql_path/data/ --basedir=/mysql_path/ < /var/tmp/sqlft1mF7
# Operation succeeded.
```

从输出中可以注意到，我必须依赖超级用户权限。如果您试图从安装在隔离 mysql 文件夹访问的平台(如 Linux 和 Mac OS X)上的服务器安装或卸载插件，您将需要使用这些权限。

还要注意，详细输出显示了应用正在做什么。在这种情况下，它用我们指定的插件的信息替换了`mysql.plugin`表中的任何行。类似地，将发出删除查询来禁用插件。

发现可用插件的状态

您可以通过检查`INFORMATION_SCHEMA PLUGINS`视图来发现系统上可用的插件。[清单 3-22](#list22) 是该视图输出的摘录。请注意，每个存储引擎以及每个插件的版本和状态都有条目。该视图还包含用于存储插件类型版本(创建插件时的系统版本)和作者的字段。通过使用`EXPLAIN`命令，您可以看到这个视图的所有字段。

[***清单 3-22***](#_list22) 。信息 _ 模式。插件视图

```sql
mysql> SELECT plugin_name, plugin_version, plugin_status, plugin_type 
       FROM INFORMATION_SCHEMA.PLUGINS;
+-----------------------+----------------+---------------+--------------------+
| plugin_name           | plugin_version | plugin_status | plugin_type        |
+-----------------------+----------------+---------------+--------------------+
| binlog                | 1.0            | ACTIVE        | STORAGE ENGINE     |
| mysql_native_password | 1.0            | ACTIVE        | AUTHENTICATION     |
| mysql_old_password    | 1.0            | ACTIVE        | AUTHENTICATION     |
| CSV                   | 1.0            | ACTIVE        | STORAGE ENGINE     |
| MEMORY                | 1.0            | ACTIVE        | STORAGE ENGINE     |
| MyISAM                | 1.0            | ACTIVE        | STORAGE ENGINE     |
| MRG_MYISAM            | 1.0            | ACTIVE        | STORAGE ENGINE     |
| ARCHIVE               | 3.0            | ACTIVE        | STORAGE ENGINE     |
| BLACKHOLE             | 1.0            | ACTIVE        | STORAGE ENGINE     |
| FEDERATED             | 1.0            | DISABLED      | STORAGE ENGINE     |
| InnoDB                | 1.1            | ACTIVE        | STORAGE ENGINE     |
| INNODB_TRX            | 1.1            | ACTIVE        | INFORMATION SCHEMA |
| INNODB_LOCKS          | 1.1            | ACTIVE        | INFORMATION SCHEMA |
| INNODB_LOCK_WAITS     | 1.1            | ACTIVE        | INFORMATION SCHEMA |
| INNODB_CMP            | 1.1            | ACTIVE        | INFORMATION SCHEMA |
| INNODB_CMP_RESET      | 1.1            | ACTIVE        | INFORMATION SCHEMA |
| INNODB_CMPMEM         | 1.1            | ACTIVE        | INFORMATION SCHEMA |
| INNODB_CMPMEM_RESET   | 1.1            | ACTIVE        | INFORMATION SCHEMA |
| PERFORMANCE_SCHEMA    | 0.1            | ACTIVE        | STORAGE ENGINE     |
| partition             | 1.0            | ACTIVE        | STORAGE ENGINE     |
+-----------------------+----------------+---------------+--------------------+
20 rows in set (0.00 sec)
```

现在，您已经浏览了源代码，并研究了系统中使用的一些重要的类和结构，我将重点转移到有助于您实现自己对 MySQL 系统的修改的项目上。让我们暂时离开源代码，考虑软件开发的编码指南和文档方面。

编码指南

如果我描述的源代码看起来有一种奇怪的格式，那可能是因为您的风格与源代码作者的风格不同。考虑这样一种情况，有许多开发者编写一个大型软件程序，如 MySQL，每个人都有自己的风格。可以想象，代码很快就会变得像一大堆杂乱的语句。为了避免这种情况，Oracle 发布了各种形式的编码指南。当您自己开始探索代码时，您将会看到，似乎有一些开发者没有遵循编码指南。唯一合理的解释是指导方针随着时间的推移而改变，这可能发生在大型项目的整个生命周期中。因此，代码的某些部分是使用一组规则编写的，而其他部分可能使用不同版本的规则。不管这个结果如何，开发者确实努力遵循了指导方针。

编码指南有一个巨大的列表，包含了为 MySQL 服务器编写 C/C++代码的注意事项。我已经捕捉到了最重要的指导方针，并在下面的段落中为您进行了总结。

一般准则

指南中最强调的一个方面是，您应该编写尽可能优化的代码。这个目标与敏捷开发方法相反，在敏捷开发方法中，您只编写您需要的代码，而将细化和优化留给重构。如果您使用敏捷方法进行开发，您可能希望等到重构之后再签入代码。

另一个非常重要的总体目标是避免使用直接的 API 或操作系统调用。您应该总是在相关的库中寻找包装函数。这些函数中有许多都经过优化，可以快速安全地执行。比如，千万不要用 C `malloc()`函数。而是使用`sql_alloc` `()`或`my` `_alloc()`功能。

所有代码行的长度必须少于 80 个字符。如果需要将一行代码延续到另一行，请对齐代码，以便参数垂直对齐，或者延续代码与缩进空间计数对齐。

注释是使用标准 C 风格的注释编写的，例如，`/* this is a comment */`。您应该在代码中自由地使用注释。

![image](img/sq.jpg) **提示**抵制使用 C++ `// comment`选项的冲动。MySQL 编码指南明确反对这种技术。

文件

源代码选择的语言是英语。这包括所有变量、函数名、常量和注释。编写和维护 MySQL 源代码的开发者遍布欧洲和美国。在源代码中选择英语作为默认语言很大程度上是由于美国计算机科学发展的影响。在许多欧洲国家，英语也作为第二语言在许多小学和中学教育项目中教授。

编写函数时，使用注释块来描述函数、其参数和预期的返回值。注释块的内容应该分成几个部分，每个部分的名称都要大写。您应该在注释后的第一行包含一个简短的函数描述名，并且至少要包含部分、概要、描述和返回值。您还可以包括可选部分，如警告、注释、另请参见、待办事项、错误和 REFERENCED_BY。各部分和内容描述如下:

*   *简介*(必需)—简要概述该功能中的流程和控制机制。它应该允许读者理解函数的基本算法。这有助于读者理解该功能，并对其功能有一个大致的了解。该部分还包括所有参数的描述(用 IN 表示输入，用 OUT 表示输出，用 IN/OUT 表示其值可以更改的引用参数)。
*   *描述*(必选)——功能的描述。它应该包括函数的目的和它的使用的简要描述。
*   *返回值*(必选)—显示所有可能的返回值以及它们对调用者的意义。
*   *警告*—包括这一部分来描述呼叫者应该注意的任何不寻常的副作用。
*   *注释*—包括这一部分，为读者提供您认为重要的任何信息。
*   *参见*—当您正在编写一个与另一个函数相关联的函数，或者需要另一个函数的特定输出，或者打算由另一个函数以特定的调用顺序使用的函数时，请包括这一节。
*   *TODO*—包含此部分，以传达该功能的任何未完成功能。完成这些项目后，请将其从本节中删除。我倾向于忘记做这件事，这经常会让我有点挠头，因为我已经完成了待办事项。
*   *错误*—包含这一部分来记录您的函数所具有的任何异常错误处理。
*   *REFERENCED _ BY*—包含此部分以传达此函数与其他函数或对象之间关系的特定方面——例如，无论何时您的函数被另一个函数调用，该函数都是另一个函数的原语，或者该函数是友元方法甚至是虚方法。

![image](img/sq.jpg) **提示** Oracle 建议没有必要为只有几行代码的短函数提供注释块，但是我建议为您创建的所有函数编写一个注释块。当您探索源代码并遇到许多很少或没有文档的小(和一些大)函数时，您会喜欢这个建议。

清单 3-23 中显示了一个函数注释块的例子。

[***清单 3-23***](#_list23) 示例函数注释块

```sql
/**
  Find tuples by key.

  SYNOPSIS
    find_by_key()
    string key            IN     A string containing the key to find.
    Handler_class *handle IN     The class containing the table to be searched.
    Tuple *               OUT    The tuple class containing the key passed.

    Uses B Tree index contained in the Handler_class. Calls Index::find()
    method then returns a pointer to the tuple found.

  DESCRIPTION
    This function implements a search of the Handler_class index class to find
    a key passed.

  RETURN VALUE
    SUCCESS (TRUE)                 Tuple found.
    != SUCCESS (FALES)             Tuple not found.

  WARNING
    Function can return an empty tuple when a key hit occurs on the index but
    the tuple has been marked for deletion.

  NOTES
    This method has been tested for empty keys and keys that are greater or
    less than the keys in the index.

  SEE ALSO
    Query:;execute(), Tuple.h

  TODO
    * Change code to include error handler to detect when key passed in exceeds
    the maximum length of the key in the index.

  ERRORS
    -1                              Table not found.
    1                               Table locked.

  REFERENCED_BY
    This function is called by the Query::execute() method.
*/
```

功能和参数

我想特别指出这些项目，因为源代码中存在一些不一致的地方。如果您使用源代码作为格式化的指南，您可能会偏离编码指南。函数及其参数应该对齐，以便参数垂直对齐。这适用于定义函数和从其他代码调用它。同样，在声明变量时，变量也应该对齐。对齐的间距不是这些项目垂直外观的问题。您还应该添加关于每个变量的行注释。行注释应该从第 49 列开始，并且不能超过最大 80 列的规则。如果变量的注释超过 80 列，请将该注释放在单独的一行。清单 3-24 显示了函数、变量和参数的对齐类型的例子。

[***清单 3-24***](#_list24) 变量、函数和参数对齐示例

```sql
int     var1;                                 /* comment goes here */
long    var2;                                 /* comment goes here too */
/* variable controls something of extreme interest and is documented well */
bool    var3;

return_value *classname::classmethod(int  var1,
                                    int  var2
                                    bool var3);

if (classname->classmethod(myreallylongvariablename1,
                          myreallylongvariablename2,
                          myreallylongvariablename3) == -1)
{
  /* do something */
}
```

![image](img/sq.jpg) **警告**如果你在 Windows 上开发，你的编辑器的换行符可能设置不正确。当您在文件中放置一个换行符时，Windows 中的大多数编辑器都会发出一个 CRLF ( `/r/n`)。Oracle 要求您使用单个 LF ( `/n`)，而不是 CRLF。这是在 Windows 上创建的文件与在 UNIX 或 Linux 上创建的文件之间常见的不兼容。如果您使用的是 Windows，请检查您的编辑器，并对其配置进行适当的更改。

命名惯例

Oracle 更喜欢使用带下划线的小写字母而不是大写字母为变量指定有意义的名称。例外情况是类名的使用，它需要有首字母大写。枚举应该以短语`enum_`为前缀。所有的结构和定义都应该用大写字母书写。命名约定的例子如清单 3-25 所示。

[***清单 3-25***](#_list25) 示例命名约定

```sql
class My_classname;
int   my_integer_counter;
bool  is_saved;

#define CONSTANT_NAME 12;

int my_function_name_goes_here(int variable1);
```

间距和缩进

MySQL 编码指南规定每个缩进层次的间距应该总是两个字符。千万不要用制表符。如果您的编辑器允许，请更改编辑器的默认行为以关闭自动格式，并用两个空格替换所有制表符。当使用 Doxygen(我稍后将讨论)或行解析工具等文档工具在文本中定位字符串时，这一点尤其重要。

当标识符和运算符之间有空格时，变量和运算符之间不包含空格，运算符和操作数之间只包含一个空格(运算符的右侧)。同样，函数中的左括号后面也不能有空格，但是参数之间要有一个空格，最后一个参数名和右括号之间不能有空格。最后，包含一个空行来描述变量声明与控制代码，控制代码与方法调用，块注释与其他代码，函数与其他声明。清单 3-26 描述了一段格式正确的代码摘录，包含一个赋值语句、一个函数调用和一个控制语句。

[***清单 3-26***](#_list26) 间距和缩进

```sql
return_value= do_something_cool(i, max_limit, is_found);
if (return_value)
{
  int var1;
  int var2;

  var1= do_something_else(i);

  if (var1)
  {
    do_it_again();
  }
}
```

在源代码的某些部分，花括号的对齐方式也不一致。MySQL 编码指南规定花括号应该和它上面的控制代码对齐，正如我在所有例子中展示的那样。如果您需要缩进另一个级别，请使用与花括号中的代码相同的列对齐方式(两个空格)。如果在代码块中执行一行代码，也没有必要使用花括号。

花括号区域中的一个奇怪之处是 switch 语句。应该编写一个 switch 语句，将 switch 条件后面的左花括号对齐，并将右花括号与 switch 关键字对齐。case 语句应该与 switch 关键字在同一列中对齐。清单 3-27 说明了这一准则。

[***清单 3-27***](#_list27) 开关语句示例

```sql
switch (some_var) {
case 1:
   do_something_here();
   do_something_else();
   break;
case 2:
   do_it_again();
   break;
}
```

![image](img/sq.jpg) **注意**前面代码中的最后一个`break`不需要。为了完整起见，我通常将它包含在我的代码中。

文档实用程序

检查源代码的另一个有用的方法是使用自动文档生成器，它读取源代码并生成基于函数和基于类的方法列表。这些程序列出了所使用的结构，并提供了它们在源代码中的使用方式和位置的线索。这对于研究 MySQL 很重要，因为源代码依赖于许多关键结构来操作和操纵数据。

一个这样的项目叫做 Doxygen。Doxygen 的好处是，它也是开源的，由 GPL 管理。当您调用 Doxygen 时，它读取源代码并生成一组可读性很高的 HTML 文件，这些文件从函数之前的源代码中提取注释，它还列出了函数原语。Doxygen 可以阅读 C、C++和 Java 等编程语言。Doxygen 是研究复杂系统(如 MySQL)的有用工具——尤其是当您考虑到代码中有数百个位置调用了基本库函数时。

Doxygen 可用于 UNIX 和 Windows 平台。要在 Linux 上使用该程序，请从 Doxygen 网站`http://www.doxygen.com`下载源代码。

下载安装后，按照安装说明(也在网站上)进行操作。Doxygen 使用配置文件来生成输出的外观以及输入中包含的内容。要生成默认配置文件，请发出以下命令:

```sql
doxygen -s -g /path_to_new_file/doxygen_config_filename
```

指定的路径应该是您想要存储文档的路径。一旦有了默认配置文件，就可以编辑该文件并更改参数以满足您的特定需求。有关选项及其参数的更多信息，请参见 Doxygen 文档。您通常会指定要处理的文件夹、项目名称以及其他与项目相关的设置。一旦设置了所需的配置，就可以通过发出以下命令为 MySQL 生成文档:

```sql
doxygen </path_to_new_file/Doxygen_config_filename>
```

![image](img/sq.jpg) **注意**根据您的设置，Doxygen 可能会运行很长时间。如果您希望 Doxygen 在合理的时间内生成文档，请避免使用高级绘图命令。

最新版本的 Doxygen 可以使用提供的 GUI 在 Windows 上运行。GUI 允许您使用向导创建配置文件，该向导将引导您逐步完成该过程，并创建基本配置文件、允许您设置自己的参数的专家模式，以及加载配置文件的能力。我发现使用向导界面生成的输出足以满足偶然到深入的查看。

我建议在深入研究源代码之前，花一些时间运行 Doxygen 并检查输出文件。这将节省你大量的查找时间。光是这些结构就值得贴在你显示器旁边的墙上，或者贴在你的工程日志上。Doxygen 可以生成的文件类型示例如图 3-3 所示。

![9781430246596_Fig03-03.jpg](img/9781430246596_Fig03-03.jpg)

[图 3-3。](#_Fig3)示例 MySQL Doxygen 输出

保存工程日志

许多开发者记录他们的项目。一些比另一些更详细，但大多数在会议和电话交谈中做笔记，从而为口头交流提供书面记录。如果你没有记录工程日志的习惯，你应该考虑这样做。我发现日志是我工作中的一个重要工具。是的，写东西确实需要更多的努力，如果你试图包含所有你认为重要的各种图纸和电子邮件，日志可能会变得混乱(我的日志经常塞满了从重要文件上剪下的剪报，就像某种工程师的剪贴簿)。然而，回报可能是巨大的。

当你在研究 MySQL 源代码的时候做一些调查工作时，尤其如此。把你的每一个发现都记录下来。写下每一个顿悟、重要的设计决策、重要纸质文档的片段，甚至偶尔的*啊哈*！随着时间的推移，你会建立起你的发现的纸质记录(我的一个前老板称之为她的纸质大脑！)这将证明对于评论和您自己的文档工作是非常宝贵的。如果你真的使用日志，做日志条目或粘贴重要的文件片段，你很快就会发现各种日志并不适合被很好地组织。大多数工程师(比如我)更喜欢无法重组的有线条的精装期刊(除非你用很多剪刀和胶水)。其他人更喜欢便于重组的活页日志。如果你打算使用精装期刊，可以考虑在使用过程中建立一个“活”索引。

![image](img/sq.jpg) **提示**如果你的日记本没有编号，花几分钟时间在每一页上都标上页码。

有许多方法可以建立生活索引。你可以在页面顶部或页边空白处写下任何有趣的关键词。这可以让你快速浏览日志，找到感兴趣的项目。活索引的特点是能够随着时间的推移添加引用。我发现创建 living index 的最好方法是使用电子表格列出你写在日志页上的所有术语，并在旁边写上页码。我大约每周更新一次电子表格，打印出来，贴在我的日志前面。我见过一些期刊前面有一个口袋，但磁带的方法也很有效。随着时间的推移，您可以对索引项和参考页码进行重新排序，以使列表更易于阅读；您也可以在日志的前面放置一个更新的列表，这样您可以更容易地找到页面。

考虑使用工程日志。到了向上级汇报进展的时候，你不会后悔的。当你被要求报告六个月或更久以前做的事情时，它也可以为你节省大量的重复工作。

跟踪您的更改

当您创建的代码对读者来说不直观时，请始终使用注释。例如，代码语句`if (found)`非常简单明了。如果变量评估为`TRUE`，将执行控制语句后的代码。然而，代码`if (func_call_17(i, x, lp))`需要一些解释。当然，您希望编写的所有代码都是不言自明的，但有时这是不可能的。当您访问支持库函数时尤其如此。有些名称不直观，参数列表可能会令人困惑。当你编码时，记录下这些情况，你的生活将会得到改善。

编写注释时，可以使用行内注释、单行注释或多行注释。行内注释从第 49 列开始写，不能超过 80 列。单行注释应该与它所引用的代码对齐(缩进标记)，并且不应该超过 80 列。同样，多行注释应该与它们解释的代码对齐，并且不应该超过 80 列，但是它们应该将开始和结束注释标记放在单独的行上。清单 3-28 说明了这些概念。

[***清单 3-28***](#_list28) 。注释位置和间距示例

```sql
if (return_value)
{
  int     var1;                                 /* comment goes here */
  long    var2;                                 /* comment goes here too */

  /* this call does something else based on i */
  var1= do_something_else(i);

  if (var1)
  {
    /*
      This comment explains
      some really interesting thing
      about the following statement(s).
    */
    do_it_again();
  }
}
```

![image](img/sq.jpg) **提示**永远不要使用重复的`*`来强调代码的某些部分。它分散了读者对代码的注意力，看起来杂乱无章。此外，将所有这些东西排列起来太麻烦了——尤其是当你以后编辑评论的时候。

如果您正在使用诸如 bazaar 这样的源代码控制应用修改 MySQL 源代码，您不必担心跟踪您的更改。Bazaar 为您提供了几种方法来检测和报告哪些变化是您自己的，哪些是别人的。如果您没有使用源代码管理应用，您可能会忘记哪些更改是您自己的，特别是当您直接对现有的系统函数进行更改时。在这种情况下，很难区分你写的和已经存在的。保持工程日志对这个问题有很大帮助，但是有一个更好的方法。

您可以在更改前后添加注释，以指示哪些代码行是您修改的。例如，您可以在代码前放置一个像`/* BEGIN CAB MODIFICATION */`这样的注释，在代码后放置一个像`/* END CAB MODIFICATION */`这样的注释。这允许您将更改括起来，并帮助您使用许多文本和行解析实用程序轻松地搜索更改。这种技术的一个例子显示在[清单 3-29](#list29) 中。

[***清单 3-29***](#_list29) 评论您对 MySQL 源代码的修改

```sql
/* BEGIN CAB MODIFICATION */
/* Reason for Modification: */
/* This section adds my revision note to the MySQL version number. */
   /* original code:   */
   /*strmov(end, "."); */
   strmov(end, "-CAB Modifications");
/* END CAB MODIFICATION */
```

请注意，我还包括了修改的原因和原始代码的注释行(这个例子是虚构的)。使用这种技术将帮助您快速访问您的更改，并增强您以后诊断问题的能力。

如果您进行了修改以便在您的组织中使用，并且不打算与 Oracle 共享这些更改，这种技术也会很有帮助。如果您不共享这些更改，每次 Oracle 发布您想要使用的新版本系统时，您都将被迫对源代码进行修改。在源代码中使用注释标记将帮助您快速确定哪些文件需要更改，以及这些更改应该是什么。如果你创造了一些新的功能，你可能最终会想要分享这些功能，如果没有别的原因，只是为了避免每次 MySQL 新版本发布时都进行修改。

![image](img/sq.jpg) **注意**虽然在使用配置控制下的源代码(BitKeeper)时这种技术没有被禁止，但通常是不鼓励的。事实上，开发者以后可能会完全删除你的评论。仅当您做出不打算与任何人共享的更改时，才使用此技巧。

首次构建系统

既然您已经看到了 MySQL 源代码的内部工作方式，并遵循了源代码中的典型查询路径，那么是时候开始了。如果您已经在使用 MySQL 源代码，并且您正在阅读本书以了解更多关于源代码以及如何修改它的信息，您可以跳过这一节。

在开始之前，我建议您下载源代码(如果您还没有下载的话),然后下载并安装适用于您选择的平台的可执行文件。将编译好的二进制文件放在手边很重要，以防在实验过程中出错。试图在没有参考点的情况下诊断一个修改过的 MySQL 源代码版本的问题是相当具有挑战性的。如果在遇到困难的调试问题时可以恢复到基本编译的二进制文件，您将会节省很多时间。我将在第 5 章中更详细地介绍调试。如果你发现自己遇到了系统问题，你可以重新安装二进制文件，让你的 MySQL 系统恢复正常。

编译源代码很容易。如果您使用的是 Linux，打开一个命令 shell，切换到源代码树的根目录，运行`cmake`和 make 命令。cmake 脚本将检查系统的依赖性并创建适当的 makefiles。下面概述了首次在 Linux 上构建源代码的典型构建过程:

```sql
$ cmake .

-- The C compiler identification is GNU
-- The CXX compiler identification is GNU
-- Check for working C compiler: /usr/bin/gcc
-- Check for working C compiler: /usr/bin/gcc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Looking for SHM_HUGETLB
-- Looking for SHM_HUGETLB - found
-- Looking for sys/types.h
-- Looking for sys/types.h - found
-- Looking for stdint.h
-- Looking for stdint.h - found
-- Looking for stddef.h
-- Looking for stddef.h - found

...

-- Configuring done
-- Generating done
-- Build files have been written to: /source/mysql-5.6.6

$ make

[  0%] Built target INFO_BIN
[  0%] Built target INFO_SRC
[  0%] Built target abi_check
[  0%] Building C object zlib/CMakeFiles/zlib.dir/adler32.c.o
[  0%] Building C object zlib/CMakeFiles/zlib.dir/compress.c.o
[  0%] Building C object zlib/CMakeFiles/zlib.dir/crc32.c.o
[  0%] Building C object zlib/CMakeFiles/zlib.dir/deflate.c.o
[  0%] Building C object zlib/CMakeFiles/zlib.dir/gzio.c.o
[  0%] Building C object zlib/CMakeFiles/zlib.dir/infback.c.o
[  0%] Building C object zlib/CMakeFiles/zlib.dir/inffast.c.o
[  0%] Building C object zlib/CMakeFiles/zlib.dir/inflate.c.o
[  0%] Building C object zlib/CMakeFiles/zlib.dir/inftrees.c.o
[  0%] Building C object zlib/CMakeFiles/zlib.dir/trees.c.o
[  0%] Building C object zlib/CMakeFiles/zlib.dir/uncompr.c.o
[  1%] Building C object zlib/CMakeFiles/zlib.dir/zutil.c.o
Linking C static library libzlib.a
[  1%] Built target zlib
[  1%] Building CXX object extra/yassl/CMakeFiles/yassl.dir/src/buffer.cpp.o

...

Linking CXX executable my_safe_process
[100%] Built target my_safe_process

$
```

![image](img/sq.jpg) **提示**关于设置复杂条件的更多信息，参见`http://www.cmake.org/cmake/help/documentation.html`。您还可以使用`cmake-gui`应用通过图形界面设置选项。你可以从 cmake.org 网站下载`cmake`和`cmake-gui`。在线参考手册还包含一些使用条件编译 MySQL 的好例子。

您可以使用 Microsoft Visual Studio 编译 Windows 平台源代码。要在 Windows 上编译系统，请打开 Visual Studio 命令窗口(确保运行 vcvarsall.bat 批处理文件以加载所需的路径)，然后发出`cmake .`命令，后跟`devenv mysql.sln /build debug`。

![image](img/sq.jpg) **注意**您必须在当前目录中包含告知 cmake 开始工作的点。

这将构建服务器的调试版本。如果您希望从源代码树安装服务器，请参见 MySQL 参考手册`http://dev.mysql.com/doc/refman/5.6/en/source-installation.html`中的“源代码安装概述”一节。

运行 cmake 命令后，您还可以从 Visual Studio 的源代码分发树的根目录中打开`mysql.sln`项目工作区。在那里，您将活动项目设置为`mysqld`类，并将项目配置设置为`mysqld - Win32 nt`。当您单击 Build mysqld 时，该项目将编译任何必要的库，并将它们链接到您指定的项目。带一杯新鲜的饮料来娱乐自己，因为第一次建立所有的库可能需要一段时间。不管你使用哪个平台，编译后的可执行文件都会被放在`client_release`或`client_debug`文件夹中，这取决于你选择的编译选项。

![image](img/sq.jpg) **注意**大多数编译问题都可以追溯到开发工具配置不当或缺少库。有关如何解决最常见编译问题的详细信息，请参考 MySQL 论坛。

关于新编译的二进制文件(除非有问题),您首先会注意到的是，您无法判断该二进制文件是否是您编译的！您可以检查文件的日期，以查看可执行文件是否是您刚刚创建的文件，但是没有办法从客户端知道这一点。尽管 Oracle 不推荐这种方法，其他人也可能会回避这种方法，但是您可以更改 MySQL 编译的版本号，以表明它是您编译的版本号。

让我们假设您想一眼就识别出您的修改。例如，您希望在客户端窗口中看到一些指示，表明服务器是您的修改版本。您可以更改版本号来显示这一点。[图 3-4](#Fig4) 是这种修改的一个例子。

![9781430246596_Fig03-04.jpg](img/9781430246596_Fig03-04.jpg)

[图 3-4。](#_Fig4)带有版本修改的 MySQL 命令示例

请注意，在头和发出命令`SELECT Version();`的结果中，返回的版本号是您编译的服务器的相同版本号加上我放在字符串中的附加标签。要自己做这个改变，只需编辑`mysqld.cpp`文件中的`set_server_version()`函数，如清单 3-30 中的[所示。在示例中，我加粗了一行代码，您可以添加它来创建这种效果。](#list30)

[***清单 3-30***](#_list30) 修改 set_server_version 函数

```sql
/*
  Create version name for running mysqld version
  We automaticly add suffixes -debug, -embedded and -log to the version
  name to make the version more descriptive.
  (MYSQL_SERVER_SUFFIX is set by the compilation environment)
*/

static void set_server_version(void)
{
  char *end= strxmov(server_version, MYSQL_SERVER_VERSION,
                     MYSQL_SERVER_SUFFIX_STR, NullS);
#ifdef EMBEDDED_LIBRARY
  end= strmov(end, "-embedded");
#endif
#ifndef DBUG_OFF
  if (!strstr(MYSQL_SERVER_SUFFIX_STR, "-debug"))
    end= strmov(end, "-debug");
#endif
  if (opt_log || opt_slow_log || opt_bin_log)
    strmov(end, "-log");                        // This may slow down system
  /* BEGIN CAB MODIFICATION */
  /* Reason for modification: */
  /* This section adds my revision note to the MySQL version number. */
  strmov(end, "-CAB MODIFICATION");
  /* END CAB MODIFICATION */
}
```

还要注意，我已经包含了我前面提到的修改意见。这将帮助您确定您更改了哪些代码行。这一变化还有一个好处，即新的版本号将显示在其他 MySQL 工具中，如 MySQL Workbench。[图 3-5](#Fig5) 显示了在 MySQL Workbench 中运行`SELECT @@version`查询的结果，该查询针对的是修改后编译的代码。

![9781430246596_Fig03-05.jpg](img/9781430246596_Fig03-05.jpg)

[图 3-5。](#_Fig5)使用 MySQL Workbench 访问修改后的 MySQL 服务器

![image](img/sq.jpg) **警告**我有没有说过这是不被认可的方法？如果您正在使用 MySQL 进行您自己的实验，或者您正在修改源代码供您自己使用，那么您可以按照我的建议去做。然而，如果您正在创建将在以后添加到基本源代码中的修改，您应该*而不是*实现这种技术。

摘要

在本章中，你学习了几种获取源代码的方法。无论您选择下载源代码树的快照或 GA 版本源代码的副本，还是使用开发者里程碑版本来获得最新和最好的版本，您都可以获得并开始使用源代码。这就是开源的美妙之处！

也许这一章最吸引人的地方是你对 MySQL 源代码的引导之旅。我希望通过一个简单的系统查询，您在理解 MySQL 源代码的探索中取得了很大的进展。我还希望，如果你在编译源代码时遇到了问题，你不会沮丧地扔掉这本书。一个优秀的开源开发者的主要素质是她系统地诊断和调整环境以适应当前项目需求的能力。如果你遇到问题，不要绝望。解决问题是学习周期的自然组成部分。

您还研究了 MySQL 编码指南文档中的主要元素，并看到了一些代码格式和文档指南的示例。虽然不完整，但我提供的编码指南足以让您感受到 Oracle 希望您如何编写修改的源代码。如果你遵循这些简单的指导方针，你以后就不会被要求遵守。

在接下来的两章中，我将带您了解软件开发中经常被忽视的两个非常重要的概念。下一章将向您展示如何应用测试驱动的开发方法来探索和扩展 MySQL 系统，下一章将讨论 MySQL 源代码的调试。*