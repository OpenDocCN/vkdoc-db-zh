# 五、文件系统

Abstract

我们生活在一个高清视频、1200 万像素摄像头和可以在光盘大小的光盘上存储 50GB 数据的存储介质的世界。在这种情况下，MongoDB 文档的最大大小限制为 16MB 可能显得不够。事实上，您可能想知道为什么 MongoDB，这个被设计为当今高科技时代的数据库，有这样一个看似奇怪的限制。简单的答案是性能。

我们生活在一个高清视频、1200 万像素摄像头和可以在光盘大小的光盘上存储 50GB 数据的存储介质的世界。在这种情况下，MongoDB 文档的最大大小限制为 16MB 可能显得不够。事实上，您可能想知道为什么 MongoDB，这个被设计为当今高科技时代的数据库，有这样一个看似奇怪的限制。简单的答案是性能。

如果数据存储在文档本身中，它显然会变得非常大，这反过来会使数据更难处理。例如，拉回整个文档也需要加载文档中的文件。您可以解决这个问题，但是无论何时访问它，您仍然需要拉回整个文件，即使您只想要其中的一小部分。你不能在文档中间要求一大块数据——这是一个要么全有要么全无的命题。幸运的是，MongoDB 为这个问题提供了一个独特而优雅的解决方案。MongoDB 使您能够非常容易地存储大文件，但它也允许您访问文件的一部分，而不必检索整个文件——同时保持高性能。它通过利用一种称为 GridFS 的规范来实现这一点。

Note

关于 GridFS 的一个有趣的事情是，它实际上不是一个软件特性。例如，MongoDB 中没有任何管理 GridFS 的特殊服务器端代码。相反，GridFS 是一个简单的规范，MongoDB 上所有受支持的驱动程序都使用它。这种规范的主要好处是，一个驱动程序存储的文件可以被遵循相同约定的任何其他驱动程序访问。

这种方法严格遵循 MongoDB 保持简单的原则。因为 GridFS 使用标准的 MongoDB 特性，所以从驱动程序的角度来看，很容易实现和使用该规范。这也意味着如果你真的想的话，你可以用手去摸索，因为 GridFS 规范中的 MongoDB 文件只是包含文档的普通集合。

## 填充一些背景

第一章提到了这样一个事实，多年来我们一直被教导使用数据库进行简单的存储。例如，我们中的一个人在 15 年前买了一本书来帮助提高他的 PHP，这本书在第三章第一节介绍了 MySQL。考虑到现实世界中 SQL 和数据库的复杂性(更不用说理论上了)，您可能想知道为什么一本面向初学者的书实际上是从 SQL 开始的。毕竟，这是一本 PHP 书籍，而不是 MySQL 书籍。

有一件事大多数人直到尝试过之后才意识到，那就是直接在磁盘上读写数据是很难的。在这一点上，有些人不同意我们的观点——毕竟，用 Python 打开和读取文件可能看起来微不足道。事实就是:在更简单的场景中，使用 PHP 处理文件是相当容易的。如果你想做的只是读入行并处理它们，你不太可能有任何麻烦。

另一方面，如果您想要搜索文件或存储复杂或结构化的数据，事情会变得困难得多。即使您能够解决这个问题并创建一个解决方案，您的解决方案也不可能比依赖数据库更快或更有效。今天的应用依赖于快速查找和存储数据——对于我们这些不能或不想自己编写这样一个系统的人来说，数据库使这成为可能。

许多书都忽略了一个领域，那就是文件的存储。大多数教你使用数据库存储数据的书也教你在需要存储文件时读写文件系统。在某些方面，这通常不是问题，因为读写简单的文件比处理其中的内容要容易得多。然而，还是有一些问题。首先，开发者必须首先拥有写这些文件的权限，这需要给 web 服务器写本地文件系统的权限。这看起来不太可能造成问题，但是它给系统管理员带来了噩梦——将文件加载到服务器上是能够破坏它的第一步。

数据库可以存储二进制文件；通常，他们这样做并不优雅。MySQL 有一个特殊的列类型叫做`BLOB`。PostgreSQL 要求遵循特殊的过程来存储这样的文件——并且数据不存储在表本身中。换句话说，就是乱。这些解决方案显然是附加的。因此，人们选择将数据写入磁盘就不足为奇了。但是这种方法也有问题。除了安全性问题之外，它还增加了另一个需要备份的目录，并且您还必须确保这些信息被复制到所有适当的服务器上。有些文件系统提供了写入磁盘并完全复制内容的能力(包括 GFS)；但是这些解决方案很复杂并且增加了开销；此外，这些特性通常会使您的解决方案更难维护。

另一方面，MongoDB 强制规定最大文档大小为 16MB。对于存储富文档来说，这已经足够了，而且在几年前，对于存储许多其他类型的文件来说，这也已经足够了。然而，这个限制对于今天的环境是完全不够的。

## 使用 GridFS

接下来，我们将简要了解 GridFS 是如何实现的。正如 MongoDB 网站所指出的，使用它不需要理解或了解 GridFS 的底层实现。事实上，你可以简单地让司机为你处理重物。在很大程度上，支持 GridFS 的驱动程序以特定于语言的方式实现文件处理。例如，Python 的 MongoDB 驱动程序的工作方式与 Python 完全一致，您很快就会看到这一点。如果您对 GridFS 的详细内容不感兴趣，那么直接跳到下一节。我们保证你不会错过任何能让你有效使用 MongoDB 的东西！

GridFS 由两部分组成。更确切地说，它由两个集合组成。一个集合保存文件名和相关信息，如大小(称为元数据)，而另一个集合保存文件数据本身，通常是 256K 的块。规范要求将它们分别命名为`files`和`chunks`。默认情况下，`files`和`chunks`集合是在`fs`命名空间中创建的，但是这是可以改变的。如果您想要存储不同类型的文件，更改默认命名空间的功能非常有用。例如，您可能希望将图像和电影文件分开。

## 命令行工具入门

现在我们已经了解了一些背景知识，让我们看看如何通过探索可利用的命令行工具来开始使用 GridFS。首先，我们需要一个文件来玩。为了简单起见，让我们使用字典文件。在 Ubuntu 上，你可以在`/usr/share/dict/words`找到这个。但是，符号链接有不同的级别，因此您可能希望首先运行以下命令:

`root@core2:/usr/share/dict# cat words > /tmp/dictionary`

Note

在 Ubuntu 中，你可能需要使用`apt-get install wbritish`来安装字典文件。

这个命令将文件的所有内容复制到一个简单明了的路径中，您可以很容易地使用它。当然，对于这个例子，您可以使用您希望的任何文件；它不需要任何特定的大小或类型。

与其描述您可以使用`mongofiles`的所有选项，不如让我们直接开始使用该工具的一些特性。这本书假设您在与 MongoDB 相同的机器上运行`mongofiles`。如果不是，那么您需要使用`–h`选项来指定运行 MongoDB 的主机。在测试完`mongofiles`命令后，您将了解到它的其他可用选项。

首先，让我们列出数据库中的所有文件。我们不希望有任何文件在那里，但让我们确定一下。`list`命令列出了到目前为止数据库中的文件:

`$ mongofiles list`

`connected to: 127.0.0.1`

`$`

好吧，那可能不是很令人兴奋。请记住，`mongofiles`是一个概念验证工具；在您自己的应用中，这可能不是一个常用的工具。但是，`mongofiles`对于学习和测试来说是很棒的。一旦创建了一个文件，就可以使用该工具来浏览所创建的文件和块。

让我们更进一步，使用`put`命令添加之前创建的字典文件(记住:在这个例子中，您可以使用您喜欢的任何文件):

`$ mongofiles put /tmp/dictionary`

`connected to: 127.0.0.1`

`added file: { _id: ObjectId('51cb61b26487b3d8ce7af440'), filename: "/tmp/dictionary", chunkSize: 262144, uploadDate: new Date(1372283314621), md5: "40c0825855792bd20e8a2d515fe9c3e3", length: 4953699 }}}`

`done!`

`$`

此示例返回一些有用的信息；但是，让我们通过确认文件是否存在来仔细检查它显示的信息。通过重新运行`list`命令来完成:

`$ mongofiles list`

`connected to: 127.0.0.1`

`/tmp/dictionary 4953699`

`$`

这个例子显示了字典文件及其大小。这些信息显然来自于`files`系列，但是我们正在超越自己。让我们花点时间回过头来，检查一下本例中从`put`命令返回的输出。

### 使用 _id 键

如您所知，MongoDB 中的每个文档都包含一个存储在`_id`键中的惟一标识符。像 MySQL 的`auto_increment`字段一样，`_id`键没有太大的直接意义，除了它允许你选择一个特定的文件。

### 使用文件名

`put`命令的输出还显示了一个`Filename`键，这本身需要一点解释。通常，您会希望保持该字段的唯一性，以帮助防止重大混淆；然而，这并不完全必要。事实上，如果您再次运行`put`命令，您将得到两个看起来完全相同的文档。在这种情况下，除了`_id`键之外，文件和元数据是相同的。您可能会对此感到惊讶，并想知道为什么 MongoDB 不更新现有的文件，而是创建一个新文件。原因是，在许多情况下，您可能会有相同的文件名。例如，如果你建立了一个系统来存储学生的作业，那么很有可能至少有一些文件名是相同的。MongoDB 不能假设相同的文件名(即使是大小相同的文件名)实际上是同一个文件。因此，在很多情况下，MongoDB 更新文件是错误的。当然，你可以使用`_id`键来更新一个特定的文件；在接下来的基于 Python 的实验中，您将了解到更多关于这个主题的内容。

### 确定文件的长度

`put`命令还返回文件的长度，这既是有用的信息，也是 GridFS 如何工作的关键。虽然知道一个文件有多大是很好的参考，但是当您编写自己的应用时，文件的大小也起着很大的作用。例如，当通过 Web(例如，通过 HTTP)发送文件时，您需要指定文件有多大。不是所有的服务器都这样做；例如，当从某些网站下载文件时，您可能已经注意到您的浏览器可以告诉您下载文件的速度，但不能告诉您完成文件下载需要多长时间。这是因为服务器没有提供大小信息。

了解文件的大小在另一方面也很重要。前面，我们提到文件被分解成块，也就是说，文件被分割成更小的部分。默认情况下，块大小是 256K，但是如果您愿意，可以将其更改为另一个值。要计算出一个文件占用了多少块，你需要知道两件事。首先你必须知道每块有多大；第二，你必须知道文件的大小，这样你才能知道有多少块。

你可能认为这不重要。毕竟，如果您有一个 1MB 的文件，块大小是 256K，那么您知道如果您想要访问从 800K 标记开始的数据，您必须从第四个块开始。然而，您仍然需要知道整个文件有多大，原因如下:如果您不知道大小，您就无法计算出有多少个有效的块。在前面的例子中，没有什么可以阻止您请求从 1.26MB 开始的数据(即第六个块)。在这种情况下，该块不存在，但是如果不参考文件大小，就无法知道这一点。当然，驱动程序会为您处理所有这些事情，因此您无需对此过于担心；然而，在调试应用时，了解 GridFS 的“幕后”工作方式肯定会有所帮助。

### 使用区块大小

`put`命令也返回块大小，因为尽管有一个默认的块大小，但这个默认大小可以逐个文件地更改。这允许灵活的规模。如果你的网站流视频，你可能想有许多块，以便你可以很容易地跳到一个给定的视频的任何部分。如果你有一个大文件，你必须返回整个文件，然后在其中找到指定部分的起始点。使用 GridFS，您可以在块级别拉回数据。如果您使用默认大小，那么您可以开始从任何 256K 的块中检索数据。当然，您也可以指定您实际需要的数据比特(例如，您可能在一部 60 分钟的电影中间只需要 5 分钟)。这是一个非常高效的系统，对于大多数用途来说，256K 是一个非常好的块大小。如果你决定改变它，你应该有一个好的理由。和往常一样，不要忘记对定制块大小的性能进行基准测试；理论上更好的系统达不到预期并不罕见。

Note

MongoDB 对文档大小有 16MB 的限制。因为 GridFS 只是标准 MongoDB 框架中存储文件的一种不同方式，所以 GridFS 中也存在这种限制。也就是说，您不能创建大于 16MB 的块。这不应该成为问题，因为 GridFS 的全部目的是缓解对大文档的需求。如果您担心您正在存储巨大的文件，这会给您带来太多的大块文档，您不必担心——生产中的 MongoDB 系统有超过 10 亿个文档！

### 跟踪上传日期

`uploadDate`键正如它的名字所暗示的那样:它在 MongoDB 中存储文件的创建日期。这是一个提及`files`集合只是一个普通的 MongoDB 集合，包含普通文档的好时机。这意味着您可以添加您需要的任何额外的键和值对，就像您对任何其他集合所做的那样。

例如，考虑一个现实世界的应用，它需要存储从各种文件中提取的文本内容。您可能需要这样做，以便执行一些额外的索引和搜索。为此，您可以添加一个`file_text`键并将文本存储在那里。GridFS 系统的优雅意味着您可以使用该系统做任何事情，就像使用任何其他 MongoDB 文档一样。优雅和强大是在 MongoDB 中工作的两个决定性特征。

### 散列你的文件

MongoDB 附带了 MD5 散列算法。你可能以前在网上下载软件时遇到过这种算法。MD5 背后的理论是每个文件都有一个唯一的签名。在该文件中的任何地方改变一个比特都将彻底地(并且显著地)改变签名。使用这种签名有两个原因:安全性和完整性。为了安全起见，如果您知道 MD5 散列应该是什么，并且您信任其来源(可能是一个朋友给您的)，那么如果散列(通常称为校验和)是正确的，您就可以确信文件没有被修改。这也确保了文件的完整性得到维护，并且没有数据丢失或损坏。特定文件的 MD5 哈希就像文件的指纹。哈希还可以用于识别文件名不同但内容相同的文件。

Warning

MD5 算法不再被认为是安全的，并且已经证明可以创建具有相同 MD5 校验和的两个不同文件，即使它们的内容不同。用密码术语来说，这叫做冲突。这种冲突是有害的，因为这意味着攻击者有可能以无法检测到的方式修改文件。这个警告在某种程度上仍然是理论上的，因为有意制造这样的碰撞需要大量的努力和时间；即使这样，这些文件也可能如此不同，以至于显然不是同一个文件。因此，MD5 仍然是确定文件完整性的首选方法，因为它得到了广泛的支持。但是，如果您希望使用散列来获得其安全性好处，那么您最好使用 SHA 系列规范之一—理想情况下是 SHA-256 或 SHA-512。甚至这些散列族也有一些理论上的漏洞；然而，还没有人展示过为 SHA 散列族制造有意碰撞的实际案例。MongoDB 使用 MD5 来确保文件的完整性，这对于大多数目的来说是很好的。但是，如果您想要散列重要的数据(比如用户密码)，您可能应该考虑使用 SHA 散列族。

## 在 MongoDB 的引擎盖下寻找

此时，您在 MongoDB 数据库中有了一些数据。现在，让我们更仔细地看看这些隐藏的数据。为此，您将再次使用一些命令行工具来连接并查询数据库。例如，尝试对之前创建的文件运行`find()`命令:

`$ mongo test`

`MongoDB shell version: 2.5.1-pre`

`connecting to: test`

`> db.fs.files.find()`

`{ "_id" : ObjectId("51cb61b26487b3d8ce7af440"), "filename" : "/tmp/dictionary", "chunkSize" : 262144, "uploadDate" : ISODate("2013-06-26T21:48:34.621Z"), "md5" : "40c0825855792bd20e8a2d515fe9c3e3", "length" : 4953699 }`

`>`

输出应该看起来很熟悉——毕竟，它是您在本章前面看到的相同数据。现在您可以看到由`mongofiles`打印的信息来自于`fs.files`集合中的文件条目。

接下来我们来看看`chunks`集合(要加滤镜；否则，它也会显示所有原始的二进制数据):

`$ mongo test`

`MongoDB shell version: 2.5.1-pre`

`connecting to: test`

`> db.fs.chunks.find({},{"data":0});`

`{ "_id" : ObjectId("51cb61b29b2daad9857ca205"), "files_id" : ObjectId("51cb61b26487b3d8ce7af440"), "n" : 4 }`

`{ "_id" : ObjectId("51cb61b29b2daad9857ca206"), "files_id" : ObjectId("51cb61b26487b3d8ce7af440"), "n" : 5 }`

`{ "_id" : ObjectId("51cb61b29b2daad9857ca207"), "files_id" : ObjectId("51cb61b26487b3d8ce7af440"), "n" : 6 }`

`{ "_id" : ObjectId("51cb61b29b2daad9857ca208"), "files_id" : ObjectId("51cb61b26487b3d8ce7af440"), "n" : 7 }`

`{ "_id" : ObjectId("51cb61b29b2daad9857ca209"), "files_id" : ObjectId("51cb61b26487b3d8ce7af440"), "n" : 8 }`

`{ "_id" : ObjectId("51cb61b29b2daad9857ca20a"), "files_id" : ObjectId("51cb61b26487b3d8ce7af440"), "n" : 9 }`

`{ "_id" : ObjectId("51cb61b29b2daad9857ca20b"), "files_id" : ObjectId("51cb61b26487b3d8ce7af440"), "n" : 10 }`

`{ "_id" : ObjectId("51cb61b29b2daad9857ca20c"), "files_id" : ObjectId("51cb61b26487b3d8ce7af440"), "n" : 11 }`

`{ "_id" : ObjectId("51cb61b29b2daad9857ca20d"), "files_id" : ObjectId("51cb61b26487b3d8ce7af440"), "n" : 12 }`

`{ "_id" : ObjectId("51cb61b29b2daad9857ca20e"), "files_id" : ObjectId("51cb61b26487b3d8ce7af440"), "n" : 13 }`

`{ "_id" : ObjectId("51cb61b29b2daad9857ca20f"), "files_id" : ObjectId("51cb61b26487b3d8ce7af440"), "n" : 14 }`

`{ "_id" : ObjectId("51cb61b29b2daad9857ca210"), "files_id" : ObjectId("51cb61b26487b3d8ce7af440"), "n" : 15 }`

`{ "_id" : ObjectId("51cb61b29b2daad9857ca211"), "files_id" : ObjectId("51cb61b26487b3d8ce7af440"), "n" : 16 }`

`{ "_id" : ObjectId("51cb61b29b2daad9857ca212"), "files_id" : ObjectId("51cb61b26487b3d8ce7af440"), "n" : 17 }`

`{ "_id" : ObjectId("51cb61b29b2daad9857ca201"), "files_id" : ObjectId("51cb61b26487b3d8ce7af440"), "n" : 0 }`

`{ "_id" : ObjectId("51cb61b29b2daad9857ca202"), "files_id" : ObjectId("51cb61b26487b3d8ce7af440"), "n" : 1 }`

`{ "_id" : ObjectId("51cb61b29b2daad9857ca203"), "files_id" : ObjectId("51cb61b26487b3d8ce7af440"), "n" : 2 }`

`{ "_id" : ObjectId("51cb61b29b2daad9857ca204"), "files_id" : ObjectId("51cb61b26487b3d8ce7af440"), "n" : 3 }`

`{ "_id" : ObjectId("51cb61b29b2daad9857ca213"), "files_id" : ObjectId("51cb61b26487b3d8ce7af440"), "n" : 18 }>`

您可能想知道为什么这里的输出有这么多条目。如前所述，GridFS 只是一个规范。也就是说，它使用 MongoDB 已经提供的内容。当我们测试这本书的命令时，字典文件被添加了几次。后来我们清空了`fs.files`集合，这个文件就被删除了。你可以亲眼看看接下来发生了什么！从一个集合中删除一些文档的事实与另一个集合中发生的事情没有关系。记住:MongoDB 不会以任何特殊的方式对待这些文档或集合。如果该文件已经通过驱动程序或`mongofiles`工具被正确删除，该工具也会清理掉`chunks`集合。

Warning

直接访问文档和集合是一个强大的特性，但是您需要小心。这个功能也使得同时拍摄自己的双脚变得容易得多。如果您决定手动编辑这些文档和集合，请确保您知道自己在做什么，并且执行大量的测试。另外，请记住，MongoDB 驱动程序中的 GridFS 支持不会知道您所做的任何定制。

### 使用搜索命令

接下来，我们仔细看看 MongoDB 的`search`命令。到目前为止，数据库中只有一个文件，这极大地限制了您可以进行的搜索类型！所以再补充点别的。以下代码片段将词典复制到另一个文件，然后导入该文件:

`$ cp /tmp/dictionary /tmp/hello_world`

`$ mongofiles put /tmp/hello_world`

`connected to: 127.0.0.1`

`added file: { _id: ObjectId('51cb63d167961ebc919edbd5'), filename: "/tmp/hello_world", chunkSize: 262144, uploadDate: new Date(1372283858021), md5: "40c0825855792bd20e8a2d515fe9c3e3", length: 4953699 }done!`

`root@core2:∼# mongofiles list`

`connected to: 127.0.0.1`

`/tmp/dictionary 4953699`

`/tmp/hello_world 4953699`

`$`

第一行复制文件，第二行将其导入 MongoDB。和前面的例子一样，`put`命令打印出 MongoDB 创建的新文档。接下来，您可以运行`mongofiles`命令`list`来检查文件是否被正确存储。如果这样做，您可以看到集合中现在有两个文件；不出所料，这两个文件大小相同。

`search`命令完全按照您的预期工作。你只需告诉`mongofiles`你在找什么，它就会帮你找到，如下例所示:

`$ mongofiles search hello`

`connected to: 127.0.0.1`

`/tmp/hello_world 4953699`

`$ mongofiles search dict`

`connected to: 127.0.0.1`

`/tmp/dictionary 4953699`

`$`

再说一次，这里没有什么太令人兴奋的事情发生。然而，有一点很重要，值得注意。MongoDB 可以根据您的需要简单或复杂。`mongofiles`工具仅供参考使用，包含非常基础的调试。好消息是:MongoDB 使得对文件执行简单的搜索变得很容易。更好的消息是:如果你想写一些非常复杂的搜索，MongoDB 也会支持你。

### 删除

`mongofiles`命令`delete`不需要太多解释，但它确实值得一个大警告。此命令根据文件名删除文件。因此，如果您有多个同名文件，此命令将删除所有文件。下面的代码片段显示了如何使用`delete`命令:

`$ mongofiles delete /tmp/hello_world`

`connected to: 127.0.0.1`

`$ mongofiles list`

`connected to: 127.0.0.1`

`/tmp/dictionary 4953699`

`$`

Note

许多人评论过这个问题，删除多个同名文件不是问题，因为没有应用会有重名。这根本不是真的；而且在很多情况下，强制使用唯一的名称甚至没有意义。例如，如果你的应用允许用户上传照片到他们的个人资料，你收到的一半文件很可能会被称为`photo.jpg`或`me.png`。

当然，如果你不太可能使用`mongofiles`来管理你的实时数据——事实上没有人期望它会被这样使用——那么你只需要在删除数据时小心。

### 从 MongoDB 检索文件

到目前为止，您实际上还没有从 MongoDB 中取出任何文件。任何数据库最重要的特征是，一旦数据被输入，它就能让你找到并检索数据。下面的代码片段使用`mongofiles`命令`get`从 MongoDB 中检索一个文件:

`$` `mongofiles get /tmp/dictionary`

`connected to: 127.0.0.1`

`done write to: /tmp/dictionary`

`$`

这个例子包括一个故意的错误。因为它指定了您想要检索的文件的完整名称和路径(根据需要)，`mongofiles`将数据写入具有相同名称和路径的文件。实际上，这会覆盖原来的字典文件！这并不是很大的损失，因为它被同一个文件覆盖了——而且字典文件首先只是一个临时副本。然而，如果你不小心抹掉了两周的工作，这种行为会给你一个相当严重的打击。相信我们，你不会知道你所有的工作去了哪里，直到活动结束后的某个时候！当使用`delete`命令时，你需要小心使用`get`命令。

### 总结 mongofiles

`mongofiles`实用程序是快速查看数据库内容的有用工具。如果你写了一些软件，你怀疑它可能有问题，那么你可以使用`mongofiles`来再次检查发生了什么。

这是一个非常简单的实现，所以不需要任何复杂的逻辑来完成手头的任务。你是否会在生产环境中使用`mongofiles`是个人喜好的问题。这不完全是瑞士军刀。但是，它确实提供了一组有用的命令，如果您的应用开始出现问题，您会非常感激。简而言之，你应该熟悉这个工具，因为有一天它可能正是你解决一个棘手问题所需要的工具。

## 利用 Python 的力量

至此，您已经对 GridFS 的工作原理有了一个很好的了解。接下来，您将学习如何从 Python 访问 GridFS。[第 2 章](02.html)讲述了如何安装 PyMongo 如果你对这些例子有任何疑问，请回头参考[第 2 章](02.html)并确保所有东西都安装正确。

如果你已经按照本章前面的例子做了，你现在应该在 GridFS 中有一个文件了。您还会记得，该文件是一个字典文件，因此它包含一个单词列表。在本节中，您将学习如何编写一个简单的 Python 脚本来打印出字典文件中的所有单词。当然，简化原始文件会更简单、更有效——但是这有什么意思呢？

首先启动 Python:

`Python 2.6.6 (r266:84292, Oct 12 2012, 14:23:48)`

`[GCC 4.4.6 20120305 (Red Hat 4.4.6-4)] on linux2`

`Type "help", "copyright", "credits" or "license" for more information.>>>`

Python 的标准驱动程序叫做 PyMongo，由 Mike Dirolf 编写。因为 PyMongo 驱动程序直接由 MongoDB，Inc .提供支持，MongoDB 的发布公司，您可以放心，它会定期更新和维护。因此，让我们继续导入库。您应该会看到如下所示的内容:

`>>> from pymongo import Connection`

`>>> import gridfs`

`>>>`

如果 PyMongo 安装不正确，您将会看到类似如下的错误:

`>>> import gridfs`

`Traceback (most recent call last):`

`File "<stdin>", line 1, in <module>`

`ImportError: No module named gridfs`

`>>>`

如果您看到后一条消息，可能是安装过程中遗漏了什么。在这种情况下，请返回到第 2 章并按照说明重新安装 PyMongo。

### 连接到数据库

在从数据库中检索信息之前，必须首先建立与数据库的连接。当您在本章前面使用`mongofiles`实用程序时，您可能注意到了对`127.0.0.1`的引用。这个值也称为 localhost，它代表您的计算机的回送地址。这个值只是告诉计算机自言自语的快捷方式。`mongofiles`提到这个 IP 地址的原因是它实际上是通过网络连接到 MongoDB 的。默认情况下，在默认的 MongoDB 端口上连接到本地机器。因为您没有更改默认设置，`mongofiles`可以毫不费力地找到并连接到您的数据库。

然而，在 Python 中使用 MongoDB 时，您需要连接到数据库，然后设置 GridFS。幸运的是，这很容易做到:

`>>> db = Connection().test`

`>>> fs = gridfs.GridFS(db)`

`>>>`

第一行打开连接并选择数据库。默认情况下，`mongofiles`使用`test`数据库；因此，您将在`test`中找到您的字典文件。第二行设置 GridFS 并准备使用。

### 获取单词

在最初的实现中，PyMongo 驱动程序使用类似文件的接口来利用 GridFS。这与你在本章前面的例子中看到的`mongofiles`有些不同，它们本质上更像 FTP。在 PyMongo 的原始实现中，您可以像对待普通文件一样读写数据。

这使得 PyMongo 使用起来非常像 Python，并且允许与现有脚本轻松集成。但是，在 1.6 版的驱动程序中，此行为已被更改，并且不再支持此功能。虽然非常类似于 Python，但该行为存在一些问题，使得该工具整体效率较低。

一般来说，PyMongo 驱动程序试图让 GridFS 文件看起来和感觉上像文件系统中的普通文件。一方面，这很好，因为这意味着没有学习曲线，驱动程序可以用于任何需要文件的方法。另一方面，这种方法有些局限性，不能很好地体现 GridFS 的强大。PyMongo 在 1.6 版本中的工作方式有了重要的改变，尤其是在`get`和`put`的工作方式上。

Note

PyMongo 的这个修订版与该工具的以前版本没有太大的不同，许多使用以前 API 的人发现适应修订版很容易。也就是说，迈克的改变并没有得到所有人的认可。例如，有些人发现旧 API 中基于文件的键控非常有用且易于使用。PyMongo 的修订版支持创建文件名的能力，因此缺失的行为可以在修订版中复制；然而，这样做确实需要更多的代码。

## 将文件放入 MongoDB

通过 PyMongo 将文件放入 GridFS 非常简单，这与使用命令行工具的方式非常相似。MongoDB 完全是关于吞吐量的，PyMongo 修订版中对 API 的更改反映了这一点。您不仅获得了更好的性能，而且这些变化还使 Python 驱动程序与其他 GridFS 实现保持一致。

让我们(再次)将字典放入 GridFS:

`>>> with open("/tmp/dictionary") as dictionary:`

`... uid = fs.put(dictionary)`

`...`

`>>> uid`

`ObjectId('51cb65be2f50332093f67b98') >>>`

在这个例子中，您使用了`put`方法来插入文件。从这个方法中获取结果很重要，因为它包含了您的文件的文档`_id`。PyMongo 采用了与`mongofiles`不同的方法，后者假设文件名是有效的键(即使你可以有重复的)。相反，PyMongo 基于它们的`_id`来引用文件。如果您没有捕获这些信息，那么您将无法可靠地再次找到该文件。实际上，这并不完全正确——你可以很容易地搜索一个文件——但是如果你想将这个文件链接到一个特定的用户帐户，那么你需要这个`_id`。

可以与`put`命令结合使用的两个有用参数是`filename`和`content_type`。如您所料，这些参数允许您分别设置文件的文件名和内容类型。这对于直接从磁盘加载文件很有用。然而，当您处理通过互联网接收或在内存中生成的文件时，它甚至更方便，因为在这些情况下，您可以使用类似文件的语义，但实际上不必在磁盘上创建一个真正的文件。

## 从 GridFS 中检索文件

最后，您现在可以返回您的数据了！此时，您已经有了自己的`unique _id`，所以找到文件很容易。`get`方法从 GridFS 中检索一个文件:

`>>> new_dictionary = fs.get(uid)`

就这样！前面的代码片段返回一个类似文件的对象；因此，您可以使用下面的代码片段打印字典中的所有单词:

`>>> for word in new_dictionary:`

`... print word`

现在敬畏地看着一个单词列表在屏幕上快速滚动！好吧，这不完全是火箭科学。然而，事实上这并不复杂，也不困难，这正是 GridFS 的魅力所在——它确实像宣传的那样工作，而且是以直观和容易理解的方式工作的！

## 删除文件

删除文件也很容易。您所要做的就是调用`fs.delete()`并传递文件的`_id`，如下例所示:

`>>> fs.delete(uid)`

`>>> new_dictionary = fs.get(uid)`

`Traceback (most recent call last):`

`File "<stdin>", line 1, in <module>`

`File "/usr/lib/python2.6/site-packages/pymongo-2.5.2-py2.6-linux-x86_64.egg/gridfs/__init__.py", line 140, in get`

`return GridOut(self.__collection, file_id)`

`File "/usr/lib/python2.6/site-packages/pymongo-2.5.2-py2.6-linux-x86_64.egg/gridfs/grid_file.py", line 392, in __init__`

`(files, file_id))`

`gridfs.errors.NoFile: no file in gridfs collection Collection(Database(Connection('localhost', 27017), u'test'), u'fs.files') with _id ObjectId('51cb65be2f50332093f67b98') >>>`

这些结果可能看起来有点可怕，但它们只是 PyMongo 表示找不到文件的方式。这并不奇怪，因为你刚刚删除了它！

## 摘要

在本章中，您对 GridFS 进行了快速浏览。您了解了什么是 GridFS，它如何与 MongoDB 结合在一起，以及如何使用它的基本语法。本章没有深入探讨 GridFS，但是在下一章，您将学习如何使用 PHP 将 GridFS 与一个真实的应用集成。现在，理解 GridFS 如何在存储文件和其他大块数据时节省时间和麻烦就足够了。

在下一章，你将开始把你所学的应用到实际中——特别是，你将学习如何建立一个功能齐全的地址簿！