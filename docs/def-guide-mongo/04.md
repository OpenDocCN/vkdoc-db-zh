# 四、使用数据

Abstract

在前一章中，您学习了数据库在后端如何工作，什么是索引，如何使用数据库快速找到您正在寻找的数据，以及文档的结构是什么样的。您还看到了一个简单的例子，说明了如何添加数据并使用 MongoDB shell 再次找到数据。在这一章中，我们将更多地关注如何使用 shell 中的数据。

在前一章中，您学习了数据库在后端如何工作，什么是索引，如何使用数据库快速找到您正在寻找的数据，以及文档的结构是什么样的。您还看到了一个简单的例子，说明了如何添加数据并使用 MongoDB shell 再次找到数据。在这一章中，我们将更多地关注如何使用 shell 中的数据。

在本章中，我们将使用一个数据库(名为`library`)，我们将执行诸如添加数据、搜索数据、修改数据、删除数据和创建索引之类的操作。我们还将了解如何使用各种命令导航数据库，以及 DBRef 是什么和它做什么。如果您已经按照前面章节中的说明设置了 MongoDB 软件，那么您可以按照本章中的示例来习惯这个界面。在这个过程中，您还将对哪些命令可以用于何种操作有一个坚实的理解。

## 浏览您的数据库

你需要知道的第一件事是如何浏览你的数据库和收藏。对于传统的 SQL 数据库，您需要做的第一件事是创建一个实际的数据库；但是，您可能还记得前面的章节，MongoDB 并不需要这样做，因为当您在其中存储数据时，程序会自动为您创建数据库和底层集合。

要切换到一个现有的数据库或创建一个新的数据库，您可以在 shell 中使用`use`函数，后跟您想要使用的数据库的名称，无论它是否存在。这个代码片段展示了如何使用`library`数据库:

`> use library`

`Switched to db library`

仅仅是调用`use`函数，然后调用数据库的名称，就可以将您的`db`(数据库)全局变量设置为`library`。这样做意味着您传递到 shell 中的所有命令将自动假定它们需要在`library`数据库上执行，直到您将这个变量重置到另一个数据库。

### 查看可用的数据库和集合

MongoDB 自动假设在您将数据保存到数据库时需要创建数据库。它也区分大小写。由于这些原因，确保您在正确的数据库中工作是相当棘手的。因此，在切换到一个数据库之前，最好先查看一下 MongoDB 当前可用的所有数据库的列表，以防忘记数据库的名称或确切的拼写。您可以使用`show dbs`功能来完成此操作:

`> show dbs`

`admin`

`local`

注意，这个函数只显示已经存在的数据库。在这个阶段，数据库还不包含任何数据，所以不会列出任何其他内容。如果您想查看当前数据库的所有可用集合，您可以使用`show collections`功能:

`> show collections`

`system.indexes`

请注意，`system.indexes`集合是在保存数据时自动创建的。此集合包含一个基于刚刚插入的文档中的`_id key`值的索引；它还包括您定义的任何自定义创建的索引。

Tip

要查看您当前正在使用的数据库，只需在 MongoDB shell 中键入`db`。

## 将数据插入集合

您想了解的最常用的功能之一是如何将数据插入到集合中。所有数据都是以 BSON 格式存储的(这种格式既紧凑，扫描速度也相当快)，所以您还需要插入 BSON 格式的数据。你可以用几种方法做到这一点。例如，您可以首先定义它，然后使用`insert`函数将其保存在集合中，或者您可以在运行时使用`insert`函数键入文档:

`> document = ( { "Type" : "Book", "Title" : "Definitive Guide to MongoDB 2nd ed.`，

`The", "ISBN" : "978-1-4302-5821-6", "Publisher" : "Apress", "Author": [`

`"Hows, David", "Plugge, Eelco", "Membrey, Peter", "Hawkins, Tim" ] } )`

Note

当你在 shell 中定义一个变量时(例如`document = ( { ... } )`，变量的内容会被立即打印出来。

`> db.media.insert(document)`

在 shell 中键入时也可以使用换行符。如果您正在编写一个相当长的文档，这可能很方便，如下例所示:

`> document = ( { "Type" : "Book"`，

`..."Title" : "Definitive Guide to MongoDB 2nd ed., The"`，

`..."ISBN" : "978-1-4302-5821-6"`，

`..."Publisher" : "Apress"`，

`..."Author" : ["Hows, David", Plugge, Eelco", "Membrey, Peter"," "Hawkins, Tim"]`

`...} )`

`> db.media.insert(document)`

如上所述，另一种选择是直接通过 shell 插入数据，而不需要首先定义文档。您可以通过立即调用`insert`函数，然后调用文档的内容来做到这一点:

`> db.media.insert( { "Type" : "CD", "Artist" : "Nirvana", "Title" : "Nevermind" })`

或者您可以像以前一样，在使用换行符的同时插入数据。例如，您可以通过添加轨迹数组来扩展前面的示例。请密切注意以下示例中逗号和括号的用法:

`> db.media.insert( { "Type" : "CD"`，

`..."Artist" : "Nirvana"`，

`..."Title" : "Nevermind"`，

`... "Tracklist" : [`

`... {`

`... "Track" : "1"`，

`... "Title" : "Smells Like Teen Spirit"`，

`... "Length" : "5:02"`

`... }`，

`... {`

`... "Track" : "2"`，

`... "Title" : "In Bloom"`，

`... "Length" : "4:15"`

`... }`

`... ]`

`...}`

`... )`

如您所见，通过 Mongo shell 插入数据非常简单。

插入数据的过程非常灵活，但是在这样做的时候，您必须遵守一些规则。例如，插入文档时键的名称有以下限制:

*   `$`字符不能是键名中的第一个字符。示例:`$tags`
*   句点[ `.` ]字符不得出现在键名中的任何位置。示例:`ta.gs`
*   名称`_id`保留用作主键 ID；虽然不建议这样做，但它可以将任何唯一的东西存储为值，如字符串或整数。

同样，创建集合时也有一些限制。例如，集合的名称必须遵循以下规则:

*   集合名称不能超过 128 个字符。
*   空字符串(" ")不能用作集合名称。
*   集合名称必须以字母或下划线开头。
*   集合名`system`是为 MongoDB 保留的，不能使用。
*   集合名称不能包含“\0”空字符。

## 查询数据

您已经看到了如何切换到您的数据库以及如何插入数据；接下来，您将学习如何查询集合中的数据。让我们在前一个例子的基础上，研究所有可能的方法，以便清楚地查看给定集合中的数据。

Note

当查询数据时，您有大量的选项、操作符、表达式、过滤器等可供选择。我们将在接下来的几节中回顾这些选项。

`find()`函数提供了从一个集合中的多个文档中检索数据的最简单方法。该功能是您将经常使用的功能之一。

让我们假设您已经将前面的两个例子插入到了数据库`library`中名为`media`的集合中。如果您要在这个集合上使用一个简单的`find()`函数，您将会得到到目前为止您添加的所有文档:

`> db.media.find()`

`{ "_id" : "ObjectId("4c1a8a56c603000000007ecb"), "Type" : "Book", "Title" :`

`"Definitive Guide to MongoDB 2nd ed., The", "ISBN" : "978-1-4302-5821-6", "Publisher" :`

`"Apress", "Author" : ["Hows, David ", "Plugge, Eelco", "Membrey, Peter", "Hawkins, Tim"]}`

`{ "_id" : "ObjectId("4c1a86bb2955000000004076"), "Type" : "CD", "Artist" :`

`"Nirvana", "Title" : "Nevermind", "Tracklist" : [`

`{`

`"Track" : "1"`，

`"Title" : "Smells Like Teen Spirit"`，

`"Length" : "5:02"`

`}`，

`{`

`"Track" : "2"`，

`"Title" : "In Bloom"`，

`"Length" : "4:15"`

`}`

`] }`

这很简单，但是通常您不希望从集合中的所有文档中检索所有信息。相反，您可能希望检索某种类型的文档。例如，您可能想要归还 Nirvana 的所有 CD。如果是这样，您可以指定只请求和返回所需的信息:

`> db.media.find ( { Artist : "Nirvana" } )`

`{ "_id" : "ObjectId("4c1a86bb2955000000004076"), "Type" : "CD", "Artist" :`

`"Nirvana", "Title" : "Nevermind", "Tracklist" : [`

`{`

`"Track" : "1"`，

`"Title" : "Smells Like Teen Spirit"`，

`"Length" : "5:02"`

`}`，

`{`

`"Track" : "2"`，

`"Title" : "In Bloom"`，

`"Length" : "4:15"`

`}`

`] }`

好吧，这样看起来好多了！您不必查看已添加到收藏中的所有其他项目的所有信息，只需查看您感兴趣的信息。但是，如果您仍然对返回的结果不满意，该怎么办呢？例如，假设您想要获取一个列表，该列表只显示您拥有的 Nirvana CD 的标题，而忽略任何其他信息，比如曲目列表。您可以通过在查询中插入一个附加参数来实现这一点，该参数指定您想要返回的键的名称，后跟一个`1`:

`> db.media.find ( {Artist : "Nirvana"}, {Title: 1} )`

`{ "_id" : ObjectId("4c1a86bb2955000000004076"), "Title" : "Nevermind" }`

插入`{ Title : 1 }`信息指定只返回来自标题字段的信息。结果被排序并以升序呈现给你。

Note

升序基于文档的插入顺序。

您也可以完成相反的操作:插入`{ Type : 0 }`检索您从 Nirvana 存储的所有项目的列表，显示除了`Type`字段之外的所有信息。

Note

默认情况下,`_id`字段将保持可见，除非您明确要求它不要显示自己。

花点时间运行插入了`{ Title : 1 }`的修改后的查询；根本不会返回任何不必要的信息。这将节省您的时间，因为您只看到您想要的信息。它还节省了数据库返回不必要信息所需的时间。

### 使用点符号

当您开始处理更复杂的文档结构(如包含数组或嵌入对象的文档)时，您也可以开始使用其他方法从这些对象中查询信息。例如，假设您想要查找包含您喜欢的特定歌曲的所有 CD。以下代码执行更详细的查询:

`> db.media.find( { "Tracklist.Title" : "In Bloom" } )`

`{ "_id" : "ObjectId("4c1a86bb2955000000004076"), "Type" : "CD", "Artist" :`

`"Nirvana", "Title" : "Nevermind", "Tracklist" : [`

`{`

`"Track" : "1"`，

`"Title" : "Smells Like Teen Spirit"`，

`"Length" : "5:02"`

`}`，

`{`

`"Track" : "2"`，

`"Title" : "In Bloom"`，

`"Length" : "4:15"`

`}`

`] }`

在键名后使用句点[ `.` ]告诉您的`find`函数查找文档中嵌入的信息。使用数组时，事情要简单一些。例如，如果要查找 Peter Membrey 所写的书籍列表，可以执行以下查询:

`> db.media.find( { "Author" : "Membrey, Peter" } )`

`{ "_id" : "ObjectId("4c1a8a56c603000000007ecb"), "Type" : "Book", "Title" :`

`"Definitive Guide to MongoDB 2nd ed., The", "ISBN" : "978-1-4302-5821-6", "Publisher" :`

`"Apress", "Author" : ["Hows, David ", "Plugge, Eelco", "Membrey, Peter", "Hawkins, Tim"] }`

但是，以下命令不会匹配任何文档，即使它可能看起来与前面的 track list 查询相同:

`> db.media.find ( { "Tracklist" : {"Track" : "1" }} )`

子对象必须完全匹配；因此，前面的查询只匹配不包含其他信息的文档，比如`Track.Title`:

`{"Type" : "CD"`，

`"Artist" : "Nirvana"`

`"Title" : "Nevermind"`，

`"Tracklist" : [`

`{`

`"Track" : "1"`，

`}`，

`{`

`"Track" : "2"`，

`"Title" : "In Bloom"`，

`"Length" : "4:15"`

`}`

`]`

`}`

### 使用排序、限制和跳过功能

MongoDB 包括几个函数，您可以使用它们来更精确地控制您的查询。我们将在本节讲述如何使用`sort`、`limit`和`skip`功能。

您可以使用`sort`函数对查询返回的结果进行排序。您可以分别使用`1`或`-1`对结果进行升序或降序排序。该函数本身类似于 SQL 中的`ORDER BY`语句，它使用键的名称和排序方法作为标准，如下例所示:

`> db.media.find().sort( { Title: 1 })`

这个例子根据`Title`键值对结果进行升序排序。当没有指定参数时，这是默认的排序顺序。您可以添加`-1`标志来按降序排序。

Note

如果指定了一个不存在的排序键，则值将按升序插入顺序返回。

您可以使用`limit()`函数来指定返回结果的最大数量。这个函数只需要一个参数:返回的期望结果的数量。当您指定“0”时，将返回所有结果。以下示例仅返回媒体集合中的前十个项目:

`> db.media.find().limit( 10 )`

您可能想做的另一件事是跳过集合中的前 n 个文档。以下示例跳过媒体集合中的前二十个文档:

`> db.media.find().skip( 20 )`

正如您可能猜测的那样，这个命令返回集合中的所有文档，除了它找到的前二十个。记住:它按照文档插入的顺序查找文档。

如果 MongoDB 不能组合这些命令，它就不会特别强大。然而，实际上任何功能都可以与任何其他功能结合使用。以下示例通过跳过一些结果来限制结果，然后按降序对结果进行排序:

`> db.media.find().sort ( { Title : -1 } ).limit ( 10 ).skip ( 20 )`

如果希望在应用中实现分页，可以使用这个示例。正如您可能已经猜到的那样，该命令不会返回到目前为止创建的媒体集合中的任何结果，因为该集合包含的文档比本例中跳过的要少。

Note

您可以在`find()`功能中使用以下快捷方式来跳过和限制您的结果:`find ( {}, {}, 10, 20 )`。这里，您将结果限制为 10 个，并跳过前 20 个文档。

### 使用封顶集合、自然顺序和$natural

在使用 MongoDB 对查询进行排序时，您应该了解一些额外的概念和特性，包括上限集合、自然顺序和`$natural`。我们将在本节解释所有这些术语的含义，以及如何在您的分类中利用它们。

自然顺序是数据库对(正常)集合中的对象的本机排序方法。因此，当您查询集合中的项时，默认情况下，这些项以正向自然顺序返回。这通常与插入项目的顺序相同；但是，这并不能保证，因为当数据被修改后不再适合原来的位置时，它可能会移动。

capped 集合是数据库中的一个集合，其中自然顺序保证是文档插入的顺序。当您查询数据并且需要绝对确定返回的结果已经根据插入顺序进行了排序时，保证自然顺序始终与插入顺序相匹配特别有用。

有上限的集合还有另一个好处:它们的大小是固定的。一旦封顶的集合已满，最旧的数据将被清除，较新的数据将被添加到末尾，从而确保自然顺序遵循记录的插入顺序。这种类型的收集可用于记录和自动归档数据。

与标准集合不同，封顶集合必须使用`createCollection`函数显式创建。您还必须提供指定要添加的集合的大小(以字节为单位)的参数。例如，假设您想要创建一个名为`audit`的上限集合，最大大小为 20480 字节:

`> db.createCollection("audit", {capped:true, size:20480})`

`{ "ok" : 1 }`

假设有上限的集合保证了自然顺序与插入顺序相匹配，那么在查询数据时，您也不需要包含任何特殊的参数或任何其他特殊的命令或函数，当然，当您想要反转默认结果时除外。这就是`$natural`参数的用武之地。例如，假设您想从列出失败登录尝试的 capped 集合中找到最近的 10 个条目。您可以使用`$natural`参数来查找这些信息:

`> db.audit.find().sort( { $natural: -1 } ).limit ( 10 )`

Note

已经添加到 capped 集合的文档可以更新，但是它们的大小不能增加。如果这样，更新将会失败。从封顶的集合中删除文档也是不可能的；相反，如果要这样做，必须删除并重新创建整个集合。在本章的后面，您将了解更多关于删除收藏的信息。

您还可以在创建集合时使用`max:`参数来限制添加到 capped 集合中的项目数量。但是，必须注意确保集合中有足够的空间来容纳要添加的项目数。如果在达到项目数之前集合已满，集合中最旧的项目将被移除。MongoDB shell 包含一个实用程序，可以让您查看现有集合使用的空间量，无论它是否有上限。您可以使用`validate()`函数调用这个实用程序。如果您想估计集合可能会变得有多大，这可能特别有用。

如前所述，您可以使用`max:`参数来限制可以插入到集合中的项目数量，如下例所示:

`> db.createCollection("audit100", { capped:true, size:20480, max: 100})`

`{ "ok" : 1 }`

接下来，使用`validate()`函数检查集合的大小:

`> db.audit100.validate()`

`{`

`"ns" : "media.audit100"`，

`"result" : "`

`validate`

`capped:1 max:100`

`firstExtent:0:54000 ns:media.audit100`

`lastExtent:0:54000 ns:media.audit100`

`# extents:1`

`datasize?:0 nrecords?:0 lastExtentSize:20736`

`padding:1`

`first extent:`

`loc:0:54000 xnext:null xprev:null`

`nsdiag:media.audit100`

`size:20736 firstRecord:null lastRecord:null`

`capped outOfOrder:0 (OK)`

`0 objects found, nobj:0`

`0 bytes data w/headers`

`0 bytes data wout/headers`

`deletedList: 1100000000000000000`

`deleted: n: 2 size: 20560`

`nIndexes:0`

`"`，

`"ok" : 1`，

`"valid" : true`，

`"lastExtentSize" : 20736`

`}`

结果输出显示，表(名为`audit100`)是一个上限集合，最多可以添加 100 个条目，目前它不包含任何条目。

### 检索单个文档

到目前为止，我们只看了展示如何检索多个文档的例子。然而，如果您只想接收一个结果，查询所有文档——这是您在执行`find()`函数时通常会做的——将会浪费 CPU 时间和内存。对于这种情况，您可以使用`findOne()`函数从您的集合中检索单个项目。总的来说，结果和添加`limit(1)`函数时的结果是一样的，但是为什么要给自己增加不必要的困难呢？

`findOne()`函数的语法与`find()`函数的语法相同:

`> db.media.findOne()`

如果你只期望一个结果，通常建议使用`findOne()`函数。

### 使用聚合命令

MongoDB 附带了一组很好的聚合命令。一开始您可能看不到它们的重要性，但是一旦您掌握了它们，您将会看到聚合命令形成了一套极其强大的工具。例如，您可以使用它们来获得关于数据库的一些基本统计信息的概述。在这一节中，我们将仔细研究如何使用可用的聚合命令中的三个函数:`count`、`distinct`和`group`。

除了这三个基本的聚合命令，MongoDB 还包括一个聚合框架。这个强大的特性将允许您计算聚合值，而无需使用通常过于复杂的 map/reduce 框架。聚合框架将在第 5 章中讨论。

#### 使用 count()返回文档数

函数的作用是:返回指定集合中文档的数量。到目前为止，我们已经在媒体集合中添加了许多文档。`count()`函数可以告诉您确切的数量:

`> db.media.count()`

Two

您还可以通过将`count()`与条件操作符结合起来执行额外的过滤，如下所示:

`> db.media.find( { Publisher : "Apress", Type: "Book" } ).count()`

`1`

本示例仅返回添加到集合中的由出版社出版且类型为 Book 的文档数。注意，`count()`功能默认忽略一个`skip()`或`limit()`参数。为了确保您的查询不会跳过这些参数，并且您的计数结果将匹配`limit`和/或`skip`参数，请使用`count(true)`:

`> db.media.find( { Publisher: "Apress", Type: "Book" }).skip ( 2 ) .count (true)`

`0`

#### 使用 distinct()检索唯一值

前面的示例展示了一种从特定发布者处检索文档总数的好方法。然而，这种方法绝对不精确。毕竟，如果你拥有多本同名的书(例如，纸质书和电子书)，那么从技术上讲，你就只有一本书。这就是`distinct()`可以帮助你的地方:它只会返回唯一的值。

为了完整起见，您可以向集合中添加一个额外的项目。这个项目有相同的标题，但有不同的 ISBN 号:

`> document = ( { "Type" : "Book","Title" : "Definitive Guide to MongoDB 2nd ed., The", ISBN:`

`"978-1-4302-5821-6", "Publisher" : "Apress", "Author" :`

`["Hows, David","Membrey, Peter","Plugge, Eelco","Hawkins, Tim"] } )`

`> db.media.insert (document)`

此时，数据库中应该有两本书名相同的书。对该系列中的标题使用`distinct()`功能时，您将总共获得两个独特的项目。但两本书的书名都是独一无二的，所以会归为一项。另一个结果将是专辑的名字“没关系:”

`> db.media.distinct( "Title")`

`[ "Definitive Guide to MongoDB, The", "Nevermind" ]`

类似地，如果您查询唯一的 ISBN 号列表，您将得到两个结果:

`> db.media.distinct ("ISBN")`

`[ "1-4302-3051-7", "987-4302-3051-9" ]`

`distinct()`函数在查询时也采用嵌套键；例如，该命令将为您提供 CD 的唯一标题列表:

`> db.media.distinct ("Tracklist.Title")`

`[ "In Bloom", "Smells Like Teen Spirit" ]`

#### 将您的结果分组

最后但同样重要的是，你可以将你的结果分组。MongoDB 的`group()`函数类似于 SQL 的`GROUP BY`函数，虽然语法有点不同。该命令的目的是返回分组项目的数组。`group()`函数有三个参数:`key`、`initial`和`reduce`。

`key`参数指定您想要分组的结果。例如，假设您想按`Title`对结果进行分组。`initial`参数允许您为每个分组结果提供一个基数(也就是开始时项目的基数)。默认情况下，如果希望返回一个精确的数字，可以将该参数设置为零。`reduce`参数将所有相似的项目组合在一起。Reduce 有两个参数:正在迭代的当前文档和聚合计数器对象。在下面的例子中，这些参数被称为`items`和`prev`。从本质上来说，`reduce`参数会将一个`1`加到它遇到的每个与它已经找到的标题相匹配的条目的总和上。

当您在寻找一个`tagcloud`类型的函数时，`group()`函数是理想的。例如，假设您想要获取收藏中任何类型项目的所有唯一标题的列表。此外，假设您希望根据标题将它们分组在一起(如果找到了任何重复项):

`> db.media.group (`

`{`

`key: {Title : true}`，

`initial: {Total : 0}`，

`reduce : function (items,prev)`

`{`

`prev.Total += 13`

`}`

`}`

`)`

`[`

`{`

`"Title" : "Nevermind"`，

`"Total" : 1`

`}`，

`{`

`"Title" : "Definitive Guide to MongoDB, The"`，

`"Total" : 2`

`}`

`]`

除了`key`、`initial`和`reduce`参数外，您还可以指定三个可选参数:

*   `keyf`:如果您不希望根据文档中的现有关键字对结果进行分组，您可以使用此参数替换`key`参数。相反，您可以使用您设计的另一个指定如何进行分组的函数对它们进行分组。
*   `cond`:您可以使用此参数来指定一个附加语句，该语句在文档被分组之前必须为真。您可以像使用`find()`查询在您的集合中搜索文档一样使用它。如果未设置该参数(默认)，则将检查集合中的所有文档。
*   `finalize`:您可以使用该参数来指定在最终结果返回之前您想要执行的功能。例如，您可以计算平均值或执行计数，并将此信息包含在结果中。

Note

`group()`函数目前在分片环境中不工作。对于这些，你应该使用`mapreduce()`函数。此外，使用`group()`函数得到的输出不能包含超过 10，000 个键，否则将引发异常。这也可以通过使用`mapreduce()`来绕过。

### 使用条件运算符

MongoDB 支持大量的条件操作符来更好地过滤您的结果。以下部分提供了这些运算符的概述，包括一些向您展示如何使用它们的基本示例。然而，在浏览这些示例之前，您应该向数据库中添加一些条目；这样做会让您更清楚地看到这些运算符的效果:

`dvd = ( { "Type" : "DVD", "Title" : "Matrix, The", "Released" : 1999`，

`"Cast" : ["Keanu Reeves","Carrie-Anne Moss","Laurence Fishburne","Hugo`

`Weaving","Gloria Foster","Joe Pantoliano"] } )`

`{`

`"Type" : "DVD"`，

`"Title" : "Matrix, The"`，

`"Released" : 1999`，

`"Cast" : [`

`"Keanu Reeves"`，

`"Carrie-Anne Moss"`，

`"Laurence Fishburne"`，

`"Hugo Weaving"`，

`"Gloria Foster"`，

`"Joe Pantoliano"`

`]`

`}`

`> db.media.insert(dvd)`

`> dvd = ( { "Type" : "DVD", Title : "Blade Runner", Released : 1982 } )`

`{ "Type" : "DVD", "Title" : "Blade Runner", "Released" : 1982 }`

`> db.media.insert(dvd)`

`> dvd = ( { "Type" : "DVD", Title : "Toy Story 3", Released : 2010 } )`

`{ "Type" : "DVD", "Title" : "Toy Story 3", "Released" : 2010 }`

`> db.media.insert(dvd)`

#### 执行大于和小于比较

您可以使用以下特殊参数在查询中执行大于和小于比较:`$gt`、`$lt`、`$gte`和`$lte`。在这一节中，我们将看看如何使用这些参数。

我们将涉及的第一个是`$gt`(大于)参数。您可以使用它来指定某个整数应该大于指定的值才能被返回:

`> db.media.find ( { Released : {$gt : 2000} }, { "Cast" : 0 } )`

`{ "_id" : ObjectId("4c4369a3c603000000007ed3"), "Type" : "DVD", "Title" :`

`"Toy Story 3", "Released" : 2010 }`

请注意，2000 年本身将不包括在前面的查询中。为此，您可以使用`$gte`(大于或等于)参数:

`> db.media.find ( { Released : {$gte : 1999 } }, { "Cast" : 0 } )`

`{ "_id" : ObjectId("4c43694bc603000000007ed1"), "Type" : "DVD", "Title" :`

`"Matrix, The", "Released" : 1999 }`

`{ "_id" : ObjectId("4c4369a3c603000000007ed3"), "Type" : "DVD", "Title" :`

`"Toy Story 3", "Released" : 2010 }`

同样，您可以使用`$lt`(小于)参数来查找您的集合中早于 1999 年的项目:

`> db.media.find ( { Released : {$lt : 1999 } }, { "Cast" : 0 } )`

`{ "_id" : ObjectId("4c436969c603000000007ed2"), "Type" : "DVD", "Title" : "Blade Runner", "Released" : 1982 }`

您还可以通过使用`$lte`(小于或等于)参数获得早于或等于 1999 年的项目列表:

`> db.media.find( {Released : {$lte: 1999}}, { "Cast" : 0 })`

`{ "_id" : ObjectId("4c43694bc603000000007ed1"), "Type" : "DVD", "Title" :`

`"Matrix, The", "Released" : 1999 }`

`{ "_id" : ObjectId("4c436969c603000000007ed2"), "Type" : "DVD", "Title" :`

`"Blade Runner", "Released" : 1982 }`

您也可以组合这些参数来指定范围:

`> db.media.find( {Released : {$gte: 1990, $lt : 2010}}, { "Cast" : 0 })`

`{ "_id" : ObjectId("4c43694bc603000000007ed1"), "Type" : "DVD", "Title" :`

`"Matrix, The", "Released" : 1999 }`

您可能会觉得这些参数使用起来相对简单；但是，在查询特定范围的数据时，您会经常用到它们。

#### 检索除指定文档之外的所有文档

您可以使用`$ne` (not equals)参数来检索集合中的每个文档，除了那些符合特定标准的文档。例如，您可以使用这个代码片段来获取作者不是 Eelco Plugge 的所有书籍的列表:

`> db.media.find( { Type : "Book", Author: {$ne : "Plugge, Eelco"}})`

#### 指定匹配的数组

您可以使用`$in`操作符来指定一个可能匹配的数组。SQL 的等价物是`IN`操作符。

您可以使用下面的代码片段通过使用`$in`操作符从媒体集合中检索数据:

`> db.media.find( {Released : {$in : [1999,2008,2009] } }, { "Cast" : 0 } )`

`{ "_id" : ObjectId("4c43694bc603000000007ed1"), "Type" : "DVD", "Title" : "Matrix, The", "Released" : 1999 }`

此示例只返回一个项目，因为只有一个项目与 1999 年的发布年份匹配，而 2008 年和 2009 年没有匹配项。

#### 查找不在数组中的值

`$nin`操作符的功能类似于`$in`操作符，除了它搜索指定字段在指定数组中没有值的对象:

`> db.media.find( {Released : {$nin : [1999,2008,2009] },Type : "DVD" }`，

`{ "Cast" : 0 } )`

`{ "_id" : ObjectId("4c436969c603000000007ed2"), "Type" : "DVD", "Title" :`

`"Blade Runner", "Released" : 1982 }`

`{ "_id" : ObjectId("4c4369a3c603000000007ed3"), "Type" : "DVD", "Title" :`

`"Toy Story 3", "Released" : 2010 }`

#### 匹配文档中的所有属性

`$all`操作符的工作方式与`$in`操作符类似。然而，`$all`要求文档中的所有属性都匹配，而对于`$in`操作符，只有一个属性必须匹配。让我们看一个例子来说明这些差异。首先，这里有一个使用`$in`的例子:

`> db.media.find ( { Released : {$in : ["2010","2009"] } }, { "Cast" : 0 } )`

`{ "_id" : ObjectId("4c4369a3c603000000007ed3"), "Type" : "DVD", "Title" :`

`"Toy Story 3", "Released" : 2010 }`

为`$in`操作符返回一个文档，因为有 2010 年的匹配，但没有 2009 年的匹配。但是，`$all`参数不返回任何结果，因为没有值为 2009 的匹配文档:

`> db.media.find ( { Released : {$all : ["2010","2009"] } }, { "Cast" : 0 } )`

#### 在文档中搜索多个表达式

您可以使用`$or`操作符在单个查询中搜索多个表达式，其中只需要匹配一个标准来返回给定的文档。与`$in`操作符不同，`$or`允许您指定键和值，而不仅仅是值:

`> db.media.find({ $or : [ { "Title" : "Toy Story 3" }, { "ISBN" :`

`"987-1-4302-3051-9" } ] } )`

`{ "_id" : ObjectId("4c5fc7d8db290000000067c5"), "Type" : "Book", "Title" :`

`"Definitive Guide to MongoDB, The", "ISBN" : "987-1-4302-3051-9"`，

`"Publisher" : "Apress", "Author" : ["Hows, David", "Membrey, Peter", "Plugge, Eelco"`，

`"Hawkins, Tim" ] }`

`{ "_id" : ObjectId("4c5fc943db290000000067ca"), "Type" : "DVD", "Title" :`

`"Toy Story 3", "Released" : 2010 }`

还可以将`$or`操作符与另一个查询参数结合起来。这将把返回的文档限制为只与第一个查询匹配的文档(强制)，然后是在`$or`操作符中指定的两个键/值对中的一个，如下例所示:

`> db.media.find({ "Type" : "DVD", $or : [ { "Title" : "Toy Story 3" }, {`

`"ISBN" : "987-1-4302-3051-9" } ] })`

`{ "_id" : ObjectId("4c5fc943db290000000067ca"), "Type" : "DVD", "Title" :`

`"Toy Story 3", "Released" : 2010 }`

您可以说,`$or`操作符允许您同时执行两个查询，将两个原本不相关的查询的结果组合起来。

#### 使用$slice 检索文档

您可以使用$ `slice`操作符从文档的数组中检索包含特定区域的文档。如果您想要限制添加的某一组项目以节省带宽，这可能特别有用。操作符还允许您在每页上检索 n 个结果，这个特性通常被称为分页。

理论上，`$slice`操作符结合了`limit()`和`skip()`函数的功能；然而，`limit()`和`skip()`不能在数组上工作，而`$slice`可以。操作符有两个参数:第一个指示要返回的项目总数。第二个参数是可选的；如果使用，它确保第一个参数定义偏移，而第二个参数定义限制。极限参数也可以指示负条件。

下面的示例将强制转换列表中的项目限制为前三项:

`> db.media.find({"Title" : "Matrix, The"}, {"Cast" : {$slice: 3}})`

`{ "_id" : ObjectId("4c5fcd3edb290000000067cb"), "Type" : "DVD", "Title" :`

`"Matrix, The", "Released" : 1999, "Cast" : [ "Keanu Reeves", "Carrie-Anne`

`Moss", "Laurence Fishburne" ] }`

通过使整数为负，也可以只获得最后三项:

`> db.media.find({"Title" : "Matrix, The"}, {"Cast" : {$slice: -3}})`

`{ "_id" : ObjectId("4c5fcd3edb290000000067cb"), "Type" : "DVD", "Title" :`

`"Matrix, The", "Released" : 1999, "Cast" : [ "Hugo Weaving", "Gloria Foster"`，

`"Joe Pantoliano" ] }`

或者，您可以跳过前两项，从该特定点开始将结果限制为三项(注意括号):

`> db.media.find({"Title" : "Matrix, The"}, {"Cast" : {$slice: [2,3] }})`

`{ "_id" : ObjectId("4c5fcd3edb290000000067cb"), "Type" : "DVD", "Title" :`

`"Matrix, The", "Released" : 1999, "Cast" : [ "Laurence Fishburne", "Hugo`

`Weaving", "Gloria Foster" ] }`

最后，当指定负整数时，可以跳到最后五项，并将结果限制为四项，如下例所示:

`> db.media.find({"Title" : "Matrix, The"}, {"Cast" : {$slice: [-5,4] }})`

`{ "_id" : ObjectId("4c5fcd3edb290000000067cb"), "Type" : "DVD", "Title" :`

`"Matrix, The", "Released" : 1999, "Cast" : [ "Carrie-Anne Moss","Laurence`

`Fishburne","Hugo Weaving","Gloria Foster"] }`

Note

在 2.4 版本中，MongoDB 还为`$push`操作引入了`$slice`操作符，允许您在向数组追加值时限制数组元素的数量。本章稍后将讨论该运算符。但是，不要混淆这两者。

#### 搜索奇/偶整数

`$mod`运算符允许您搜索由偶数或奇数组成的特定数据。这是可行的，因为操作符取`2`的模数并检查`0`的余数，从而只提供偶数的结果。

例如，以下代码返回集合中的任何项目，该项目的`Released`字段设置为偶数整数:

`> db.media.find ( { Released : { $mod: [2,0] } }, {"Cast" : 0 } )`

`{ "_id" : ObjectId("4c45b5c18e0f0000000062aa"), "Type" : "DVD", "Title" :`

`"Blade Runner", "Released" : 1982 }`

`{ "_id" : ObjectId("4c45b5df8e0f0000000062ab"), "Type" : "DVD", "Title" :`

`"Toy Story 3", "Released" : 2010 }`

同样，您可以通过更改`$mod`中的参数来查找任何在`Released`字段中包含不均匀值的文档，如下所示:

`> db.media.find ( { Released : { $mod: [2,1] } }, { "Cast" : 0 } )`

`{ "_id" : ObjectId("4c45b5b38e0f0000000062a9"), "Type" : "DVD", "Title" :`

`"Matrix, The", "Released" : 1999 }`

Note

`$mod`操作符只对整数值有效，对包含数字值的字符串无效。例如，您不能在`{ Released : "2010" }`上使用操作符，因为它在引号中，因此是一个字符串。

#### 使用$size 过滤结果

`$size`操作符允许您过滤结果，以匹配一个包含指定数量元素的数组。例如，您可以使用此运算符来搜索那些恰好包含两首歌曲的 CD:

`> db.media.find ( { Tracklist : {$size : 2} } )`

`{ "_id" : ObjectId("4c1a86bb2955000000004076"), "Type" : "CD", "Artist" :`

`"Nirvana", "Title" : "Nevermind", "Tracklist" : [`

`{`

`"Track" : "1"`，

`"Title" : "Smells Like Teen Spirit"`，

`"Lenght" : "5:02"`

`}`，

`{`

`"Track" : "2"`，

`"Title" : "In Bloom"`，

`"Length" : "4:15"`

`}`

`] }`

Note

您不能使用`$size`运算符来查找尺寸范围。例如，不能用它来查找包含多个元素的数组。

#### 返回特定的字段对象

`$exists`操作符允许您在指定的字段丢失或找到时返回一个特定的对象。以下示例返回集合中具有名为`Author`的关键字的所有项目:

`> db.media.find ( { Author : {$exists : true } } )`

类似地，如果用值`false`调用这个操作符，那么将返回所有没有名为`Author`的键的文档:

`> db.media.find ( { Author : {$exists : false } } )`

Warning

目前，`$exists`操作符不能使用索引；因此，使用它需要全表扫描。

#### 基于 BSON 类型的匹配结果

`$type`操作符允许您根据 BSON 类型匹配结果。例如，下面的代码片段让您找到所有具有类型为`Embedded Object`的跟踪列表的项目(也就是说，它包含一个信息列表):

`> db.media.find ( { Tracklist: { $type : 3 } } )`

`{ "_id" : ObjectId("4c1a86bb2955000000004076"), "Type" : "CD", "Artist" :`

`"Nirvana", "Title" : "Nevermind", "Tracklist" : [`

`{`

`"Track" : "1"`，

`"Title" : "Smells Like Teen Spirit"`，

`"Lenght" : "5:02"`

`}`，

`{`

`"Track" : "2"`，

`"Title" : "In Bloom"`，

`"Length" : "4:15"`

`}`

`] }`

表 [4-1](#Tab1) 中定义了已知的数据类型。

表 4-1。

Known BSON Types and Codes

<colgroup><col> <col></colgroup> 
| 密码 | 数据类型 |
| --- | --- |
| –1 | 迷你键 |
| one | 两倍 |
| Two | 字符串(UTF8) |
| three | 嵌入对象 |
| four | 嵌入式阵列 |
| five | 二进制数据 |
| 七 | 对象 ID |
| eight | 布尔型 |
| nine | 日期类型 |
| Ten | 零型 |
| Eleven | 正则表达式 |
| Thirteen | JavaScript 代码 |
| Fourteen | 标志 |
| Fifteen | 带作用域的 JavaScript 代码 |
| Sixteen | 32 位整数 |
| Seventeen | 时间戳 |
| Eighteen | 64 位整数 |
| One hundred and twenty-seven | MaxKey |
| Two hundred and fifty-five | 最小键 |

#### 匹配整个数组

如果想匹配文档中的整个数组，可以使用`$elemMatch`操作符。如果您的集合中有多个文档，其中一些文档包含一些相同的信息，这将非常有用。这可能会使默认查询无法找到您正在寻找的确切文档。这是因为标准查询语法并不局限于数组中的单个文档。

让我们看一个例子来说明这个原则。要做到这一点，我们需要向集合中添加另一个文档，这个文档中有一个相同的条目，但在其他方面有所不同。具体来说，我们将添加 Nirvana 的另一张 CD，这张 CD 恰好与前面提到的 CD 有相同的曲目(“闻起来像青少年精神”)。然而，在这个版本的 CD 上，歌曲是音轨 5，而不是音轨 1:

`{`

`"Type" : "CD"`，

`"Artist" : "Nirvana"`，

`"Title" : "Nirvana"`，

`"Tracklist" : [`

`{`

`"Track" : "1"`，

`"Title" : "You know you're right"`，

`"Length" : "3:38"`

`}`，

`{`

`"Track" : "5"`，

`"Title" : "Smells like teen spirit"`，

`"Length" : "5:02"`

`}`

`]`

`}`

`> nirvana = ( { "Type" : "CD", "Artist" : "Nirvana", "Title" : "Nirvana"`，

`"Tracklist" : [ { "Track" : "1", "Title" : "You Know You're Right", "Length"`

`: "3:38"}, {"Track" : "5", "Title" : "Smells Like Teen Spirit", "Length" :`

`"5:02" } ] } )`

`> db.media.insert(nirvana)`

如果您想在 CD 上搜索歌曲“smokes Like Teen Spirit”作为曲目 1 的 Nirvana 专辑，您可能会认为下面的查询可以满足您的要求:

`> db.media.find ( { "Tracklist.Title" : "Smells Like Teen Spirit"`，

`"Tracklist.Track" : "1" } )`

不幸的是，前面的查询将返回这两个文档。这样做的原因是两个文档都有一个标题为“smokes Like Teen Spirit”的音轨，并且都有音轨编号 1。如果想要匹配数组中的整个文档，可以使用`$elemMatch`，如下例所示:

`> db.media.find ( { Tracklist: { "$elemMatch" : { Title:`

`"Smells like teen spirit", Track : "1" } } } )`

`{ "_id" : ObjectId("4c1a86bb2955000000004076"), "Type" : "CD", "Artist" :`

`"Nirvana", "Title" : "Nevermind", "Tracklist" : [`

`{`

`"Track" : "1"`，

`"Title" : "Smells Like Teen Spirit"`，

`"Lenght" : "5:02"`

`}`，

`{`

`"Track" : "2"`，

`"Title" : "In Bloom"`，

`"Length" : "4:15"`

`}`

`] }`

这个查询给出了期望的结果，并且只返回了第一个文档。

#### $not(元运算符)

您可以使用`$not`元操作符来否定标准操作符执行的任何检查。以下示例返回集合中的所有文档，除了在`$elemMatch`示例中看到的文档:

`> db.media.find ( { Tracklist : { $not : { "$elemMatch" : { Title:`

`"Smells Like Teen Spirit", "Track" : "1" } } } } )`

#### 指定附加查询表达式

除了到目前为止您已经看到的结构化查询语法之外，您还可以在 JavaScript 中指定附加的查询表达式。这样做的最大好处是 JavaScript 非常灵活，允许您做大量额外的事情。使用 JavaScript 的缺点是比 MongoDB 内置的原生操作符慢一点。

例如，假设您想在您的收藏中搜索一张 1995 年以前的 DVD。以下所有代码示例都将返回此信息:

`db.media.find ( { "Type" : "DVD", "Released" : { $lt : 1995 } } )`

`db.media.find ( { "Type" : "DVD", $where: "this.Released < 1995" } )`

`db.media.find ("this.Released < 1995")`

`f = function() { return this.Released < 1995 }`

`db.media.find(f)`

这就是 MongoDB 的灵活性！使用这些操作符应该能够让您在您的收藏中找到任何东西。

### 利用正则表达式

正则表达式是另一个可以用来查询信息的强大工具。正则表达式(简称 regex)是特殊的文本字符串，可以用来描述搜索模式。这些功能很像通配符，但是它们更强大、更灵活。

MongoDB 允许您在集合中搜索数据时使用这些正则表达式；但是，对于简单的前缀查询，它将尽可能使用索引。

以下示例在查询中使用 regex 来查找媒体集合中以单词“Matrix”开头的所有项目

`> db.media.find ( { Title : /Matrix*/i } )`

使用 MongoDB 的正则表达式可以让您的生活变得更加简单，所以我们建议在时间允许的情况下更详细地探索这个特性，或者您的环境可以从中受益。

## 更新数据

到目前为止，您已经学习了如何在数据库中插入和查询数据。接下来，您将学习如何更新这些数据。MongoDB 支持相当多的更新操作符，您将在下面的小节中学习如何使用这些操作符。

### 使用 update()更新

MongoDB 附带了用于更新数据的`update()`函数。`update()`函数有三个主要参数:`criteria`、`objNew`和`options`。

`criteria`参数允许您指定选择想要更新的记录的查询。您使用`objNew`参数来指定更新的信息；或者你可以使用一个运营商来为你做这件事。`options`参数允许您在更新文档时指定选项，有两个可能的值:`upsert`和`multi`。`upsert`选项让您指定更新是否应该是 up sert——也就是说，它告诉 MongoDB 如果记录存在就更新它，如果不存在就创建它。最后，`multi`选项让您指定是应该更新所有匹配的文档还是只更新第一个文档(默认操作)。

下面这个简单的例子使用了`update()`函数，没有任何花哨的操作符:

`> db.media.update( { "Title" : "Matrix, The"}, {"Type" : "DVD", "Title" :`

`"Matrix, The", "Released" : 1999, "Genre" : "Action"}, { upsert: true} )`

本示例覆盖集合中的文档，并用指定的新值保存。请注意，您遗漏的任何字段都将被删除(文档基本上被重写)。因为`upsert`参数被指定为`true`，所以任何尚不存在的字段都将被添加进来(在本例中是`Genre`键/值对)。

如果碰巧有多个文档符合标准，并且您希望将它们全部向上插入，可以在使用`$set`修饰符操作符的同时添加`upsert`和`multi`选项，如下所示:

`> db.media.update( { "Title" : "Matrix, The"}, {$set: {"Type" : "DVD", "Title" :`

`"Matrix, The", "Released" : 1999, "Genre" : "Action"} }, {upsert: true, multi: true} )`

Note

一个`upsert`告诉数据库“如果一个文档存在就更新一个记录，如果不存在就插入记录。”

### 使用 save()命令实现 Upsert

您也可以使用`save()`命令执行向上插入。为此，您需要指定`_id`值；您可以自动添加该值，也可以自己手动指定。如果您没有指定`_id`值，`save()`命令将假设它是一个插入，并简单地将文档添加到您的集合中。

使用`save()`命令的主要好处是你不需要指定`upsert`方法应该和`update()`命令一起使用。因此，`save()`命令为您提供了一种更快捷的方式来更新数据。实际上，`save()`和`update()`命令看起来很相似:

`> db.media.update( { "Title" : "Matrix, The"}, {"Type" : "DVD", "Title" :`

`"Matrix, The", "Released" : "1999", "Genre" : "Action"}, { upsert: true} )`

`> db.media.save( { "Title" : "Matrix, The"}, {"Type" : "DVD", "Title" :`

`"Matrix, The", "Released" : "1999", "Genre" : "Action"})`

显然，这个例子假设`Title`值作为`id`字段。

### 自动更新信息

您可以使用修饰符操作快速、简单地更新文档中的信息，但不需要手动键入所有内容。例如，您可以使用这些操作来增加一个数字或从数组中移除一个元素。

接下来我们将探索这些操作符，提供实际的例子来展示如何使用它们。

#### 用$inc 增加一个值

`$inc`操作符使您能够对一个键执行(原子)更新，以给定的增量增加值，假设该字段存在。如果该字段不存在，将会被创建。要查看这一过程，首先向集合中添加另一个文档:

`> manga = ( { "Type" : "Manga", "Title" : "One Piece", "Volumes" : 612`，

`"Read" : 520 } )`

`{`

`"Type" : "Manga"`，

`"Title" : "One Piece"`，

`"Volumes" : "612"`，

`"Read" : "520"`

`}`

`> db.media.insert(manga)`

现在您已经准备好更新文档了。例如，假设您已经阅读了另外四卷《海贼王》漫画，并且您想要增加文档中的`Read`卷数。以下示例向您展示了如何做到这一点:

`> db.media.update ( { "Title" : "One Piece"}, {$inc: {"Read" : 4} } )`

`> db.media.find ( { "Title" : "One Piece" } )`

`{`

`"Type" : "Manga"`，

`"Title" : "One Piece` `"`，

`"Volumes" : "612"`，

`"Read" : "524"`

`}`

#### 设置字段的值

您可以使用`$set`操作符将字段的值设置为您指定的值。这适用于任何数据类型，如下例所示:

`> db.media.update ( { "Title" : "Matrix, The" }, {$set : { Genre :`

`"Sci-Fi" } } )`

这个代码片段将更新之前创建的文档中的流派，将其设置为`Sci-Fi`。

#### 删除指定的字段

`$unset`操作符允许您删除给定的字段，如下例所示:

`> db.media.update ( {"Title": "Matrix, The"}, {$unset : { "Genre" : 1 } } )`

这个代码片段将从文档中删除`Genre`键及其值。

#### 向指定字段追加值

`$push`操作符允许您将一个值添加到指定的字段中。如果该字段是一个现有的数组，那么该值将被添加。如果该字段尚不存在，则该字段将被设置为数组值。如果字段存在，但它不是一个数组，那么将引发一个错误条件。

首先将另一位作者添加到您的收藏条目中:

`> db.media.update ( {"ISBN" : "978-1-4302-5821-6"}, {$push: { Author : "Griffin`，

`Stewie"} } )`

下一个代码片段引发了一条错误消息，因为`Title`字段不是一个数组:

`> db.media.update ( {"ISBN" : "978-1-4302-5821-6"}, {$push: { Title :`

`"This isn't an array"} } )`

`Cannot apply $push/$pushAll modifier to non-array`

以下示例显示了文档在此期间的外观:

`> db.media.find ( { "ISBN" : "978-1-4302-5821-6" } )`

`{`

`"Author" :`

`[`

`"Hows, David"`，

`"Membrey, Peter"`，

`"Plugge, Eelco"`，

`"Griffin, Stewie"`，

`]`，

`"ISBN" : "978-1-4302-5821-6"`，

`"Publisher" : "Apress"`，

`"Title" : "Definitive Guide to MongoDB 2nd ed., The"`，

`"Type" : "Book"`，

`"_id" : ObjectId("4c436231c603000000007ed0")`

`}`

#### 在数组中指定多个值

使用数组时，$push 操作符将把指定的值附加到给定的数组中，扩展存储在给定元素中的数据。如果您希望将几个单独的值添加到给定的数组中，可以使用可选的`$each`修饰符，如下例所示:

`> db.media.update( { "ISBN" : "978-1-4302-5821-6" }, { $push: { Author : { $each: ["Griffin, Peter", "Griffin, Brian"] } } } )`

`{`

`"Author" :`

`[`

`"Hows, David"`，

`"Membrey, Peter"`，

`"Plugge, Eelco"`，

`"Hawkins, Tim"`，

`"Griffin, Stewie"`，

`"Griffin, Peter"`，

`"Griffin, Brian"`

`]`，

`"ISBN" : "978-1-4302-5821-6"`，

`"Publisher" : "Apress"`，

`"Title" : "Definitive Guide to MongoDB 2nd ed., The"`，

`"Type" : "Book"`，

`"_id" : ObjectId("4c436231c603000000007ed0")`

`}`

可选地，当使用`$each`时，可以使用`$slice`操作符。这允许你在一个`$push`操作中限制数组中元素的数量。`$slice`接受负数或零。使用负数可以确保数组中只保留最后 n 个元素，而使用零会清空数组。注意，`$slice`操作符必须是`$push`操作符的第一个修饰符，这样才能起作用:

`> db.media.update( { "ISBN" : "978-1-4302-5821-6" }, { $push: { Author : { $each: ["Griffin, Meg", "Griffin, Louis"], $slice: -2 } } } )`

`{`

`"Author" :`

`[`

`"Griffin, Meg"`，

`"Griffin, Louis"`

`]`，

`"ISBN" : "978-1-4302-5821-6"`，

`"Publisher" : "Apress"`，

`"Title" : "Definitive Guide to MongoDB 2nd ed., The"`，

`"Type" : "Book"`，

`"_id" : ObjectId("4c436231c603000000007ed0")`

`}`

如您所见，`$slice`操作符确保了不仅两个新值被推入，数组中保存的数据也被限制为指定的值(2)。在处理固定大小的数组时,`$slice`操作符是一个很有价值的工具。

#### 用$addToSet 向数组中添加数据

`$addToSet`操作符是另一个允许您向数组添加数据的命令。但是，只有当数据不在数组中时，该运算符才会将数据添加到数组中。这样看来，`$addToSet`不像`$push`。默认情况下，`$addToSet`操作符接受一个参数。然而，在使用 t `$addToSet`时，您可以使用`$each`操作符来指定额外的参数。下面的代码片段将作者`Griffin, Brian`添加到 authors 数组中，因为它还不在那里:

`> db.media.update( { "ISBN" : "1-4302-3051-7" }, {$addToSet : { Author :`

`"Griffin, Brian" } } )`

再次执行代码片段不会改变任何事情，因为作者已经在数组中了。

然而，要添加多个值，您应该采用不同的方法，并使用`$each`操作符:

`> db.media.update( { "ISBN" : "1-4302-3051-7" }, {$addToSet : { Author :`

`{ $each : ["Griffin, Brian","Griffin, Meg"] } } } )`

至此，我们这个曾经看起来整洁可信的文档，已经被改造成这样了:

`{`

`"Author" :`

`[`

`"Hows, David"`，

`"Membrey, Peter"`，

`"Plugge, Eelco"`，

`"Hawkins, Tim"`，

`"Griffin, Stewie"`，

`"Griffin, Peter"`，

`"Griffin, Brian"`，

`"Griffin, Louis"`，

`"Griffin, Meg"`

`]`，

`"ISBN" : "1-4302-3051-7"`，

`"Publisher" : "Apress"`，

`"Title" : "Definitive Guide to MongoDB, The"`，

`"Type" : "Book"`，

`"_id" : ObjectId("4c436231c603000000007ed0")`

`}`

#### 从数组中移除元素

MongoDB 还包括几个方法，可以让你从数组中移除元素，包括`$pop`、`$pull`、`$pullAll`。在接下来的小节中，您将学习如何使用这些方法从数组中移除元素。

`$pop`操作符允许您从数组中删除单个元素。该运算符允许您删除数组中的第一个或最后一个值，这取决于您传递给它的参数。例如，下面的代码片段删除了数组中的最后一个元素:

`> db.media.update( { "ISBN" : "1-4302-3051-7" }, {$pop : {Author : 1 } } )`

在这种情况下，`$pop`操作符会将 Meg 的名字从作者列表中弹出。传递一个负数会从数组中移除第一个元素。以下示例从作者列表中删除 Peter Membrey 的名字:

`> db.media.update( { "ISBN" : "1-4302-3051-7" }, {$pop : {Author : -1 } } )`

Note

指定值`-2`或`1000`不会改变删除哪个元素。任何负数都将删除第一个元素，而任何正数都将删除最后一个元素。使用数字`0`从数组中删除最后一个元素。

#### 移除指定值的每个匹配项

`$pull`操作符允许您从数组中删除指定值的每一次出现。如果数组中有多个值相同的元素，这可能特别有用。让我们从使用`$push`参数将 Stewie 添加回作者列表开始这个例子:

`> db.media.update ( {"ISBN" : "1-4302-3051-7"}, {$push: { Author :`

`"Griffin, Stewie"} } )`

当我们浏览这本书的例子时，Stewie 将多次进出数据库。您可以使用以下代码删除文档中出现的该作者的所有内容:

`> db.media.update ( {"ISBN" : "1-4302-3051-7"}, {$pull : { Author : "Griffin`，

`Stewie" } } )`

#### 从数组中删除多个元素

您也可以从数组中移除多个具有不同值的元素。`$pullAll`操作符使您能够完成这个任务。`$pullAll`操作符接受一个包含所有要删除的元素的数组，如下例所示:

`> db.media.update( { "ISBN" : "1-4302-3051-7"}, {$pullAll : { Author :`

`["Griffin, Louis","Griffin, Peter","Griffin, Brian"] } } )`

从中移除元素的字段(上例中的`Author`)需要是一个数组。如果不是，您将收到一条错误消息。

### 指定匹配数组的位置

您可以在查询中使用`$`操作符来指定查询中匹配数组项的位置。找到数组成员后，可以使用该运算符进行数据操作。例如，假设您在曲目列表中添加了另一首曲目，但在输入曲目编号时不小心打错了:

`> db.media.update( { "Title" : "Nirvana" }, {$addToSet : { Tracklist :`

`{"Track" : 2,"Title": "Been a Son", "Length":"2:23"} } } )`

`{`

`"Artist" : "Nirvana"`，

`"Title" : "Nirvana"`，

`"Tracklist" : [`

`{`

`"Track" : "1"`，

`"Title" : "You Know You're Right"`，

`"Length" : "3:38"`

`}`，

`{`

`"Track" : "5"`，

`"Title" : "Smells Like Teen Spirit"`，

`"Length" : "5:02"`

`}`，

`{`

`"Track" : 2`，

`"Title" : "Been a Son"`，

`"Length" : "2:23"`

`}`

`]`，

`"Type" : "CD"`，

`"_id" : ObjectId("4c443ad6c603000000007ed5")`

`}`

碰巧你知道最近项目的轨道号应该是`3`而不是`2`。您可以将`$inc`方法与`$`操作符结合使用，将值从`2`增加到`3`，如下例所示:

`> db.media.update( { "Tracklist.Title" : "Been a son"}`，

`{$inc:{"Tracklist.$.Track" : 1} } )`

请注意，只有它匹配的第一个项目才会被更新。因此，如果 comments 数组中有两个相同的元素，那么只有第一个元素会增加。

### 原子操作

MongoDB 支持对单个文档执行原子操作。原子操作是一组操作，这些操作可以以这样的方式组合，使得这组操作对于系统的其余部分来说看起来仅仅是一个操作。这组操作的最终结果要么是正面的，要么是负面的。

如果一组操作满足以下一对条件，则可以将其称为原子操作:

No other process knows about the changes being made until the entire set of operations has completed.   If one of the operations fails, the entire set of operations (the entire atomic operation) will fail, resulting in a full rollback, where the data is restored to its state prior to running the atomic operation.  

执行原子操作时的一个标准行为是数据将被锁定，因此其他查询无法访问。但是，MongoDB 不支持锁定或复杂事务，原因有很多:

*   在分片环境中(参见[第 12 章](12.html)了解更多关于这种环境的信息)，分布式锁可能是昂贵且缓慢的。MongoDB 的目标是轻量级和快速，所以昂贵和缓慢违背了原则。
*   MongoDB 开发者不喜欢死锁的想法。在他们看来，系统最好是简单且可预测的。
*   MongoDB 旨在很好地解决实时问题。当执行锁定大量数据的操作时，它还会在较长时间内停止一些较小的轻型查询。同样，这违背了 MongoDB 的速度目标。

MongoDB 包括几个更新操作符(如前所述)，所有这些操作符都可以自动更新元素:

*   `$set`:设定特定值。
*   `$unset`:删除特定值。
*   `$inc`:将特定值增加一定的量。
*   `$push`:向数组追加一个值。
*   `$pull`:从现有数组中删除一个或多个值。
*   `$pullAll`:从现有数组中删除几个值。

#### 使用“如果当前更新”方法

原子更新使用的另一个策略是 update-if-current。该方法采取以下三个步骤:

It fetches the object from the document.   It modifies the object locally (with any of the previously mentioned operations, or a combination of them).   It sends an update request to update the object to the new value, in case the current value still matches the old value fetched.  

你可以使用`getlasterror`方法来检查是否一切顺利。请注意，所有这些都是自动发生的。让我们重新看一下之前显示的示例:

`> db.media.update( { "Tracklist.Title" : "Been a son"}`，

`{$inc:{"Tracklist.$.Track" : 1} } )`

现在您可以使用`getlasterror`命令来检查更新是否顺利进行:

`> db.$cmd.findOne({getlasterror:1})`

如果原子更新成功执行，您将获得以下结果:

`{ "err" : null, "updatedExisting" : true, "n" : 1, "ok" : 1 }`

在本例中，您使用曲目列表标题作为标识符来增加`Tracklist.Track`。但是现在考虑一下，如果在 MongoDB 修改您的数据时，另一个用户使用相同的方法更改了曲目列表数据，会发生什么情况。因为`Tracklist.Title`保持不变，所以您可能会(错误地)认为您正在更新原始数据，而实际上您正在覆盖这些更改。

这就是众所周知的 ABA 问题。这种情况似乎不太可能，但是在多用户环境中，许多应用同时处理数据，这可能是一个严重的问题。

要避免此问题，您可以执行下列操作之一:

*   在更新的查询表达式中使用整个对象，而不仅仅是`_id`和`comments.by`字段。
*   使用`$set`设置您关心的字段。如果其他领域发生了变化，也不会受此影响。
*   在对象中放置一个版本变量，并在每次更新时递增。
*   如果可能的话，使用一个`$`操作符来代替更新当前操作序列。

Note

MongoDB 不支持在单个操作中自动更新多个文档。相反，您可以使用嵌套对象，这有效地使它们成为一个用于原子目的的文档。

### 原子地修改和返回文档

`findAndModify`命令还允许您对文档执行原子更新。这个命令修改文档并返回它。这个命令有三个主要的操作符:`<query>`，用来指定执行命令所针对的文档；`<sort>`，用于在多个匹配时对匹配的文档进行排序，以及`<operations>`，用于指定需要做什么。

现在让我们来看几个说明如何使用这个命令的例子。第一个示例查找您要搜索的文档，并在找到后删除它:

`> db.media.findAndModify( { "Title" : "One Piece",sort:{"Title": -1}, remove:`

`true} )`

`{`

`"_id" : ObjectId("4c445218c603000000007ede")`，

`"Type" : "Manga"`，

`"Title" : "One Piece"`，

`"Volumes" : 612`，

`"Read" : 524`

`}`

这段代码返回它找到的符合标准的文档。在本例中，它找到并删除了标题为“One Piece”的第一个项目。如果您现在执行一个`find()`函数，您将看到该文档不再位于集合中。

下一个示例修改文档，而不是删除它:

`> db.media.findAndModify( { query: { "ISBN" : "987-1-4302-3051-9" }, sort:`

`{"Title":-1}, update: {$set: {"Title" : " Different Title"} } } )`

前面的例子将标题从“Definitive Guide to MongoDB”更新为“Different Title”，并将旧文档(与更新前一样)返回到 shell。如果您希望看到文档的更新结果，可以在查询后添加`new`操作符:

`> db.media.findAndModify( { query: { "ISBN" : "987-1-4302-3051-9" }, sort:`

`{"Title":-1}, update: {$set: {"Title" : " Different Title"} }, new:true } )`

注意，你可以用这个命令使用任何修饰操作，不仅仅是`$set`。

## 重命名收藏

可能会发生这样的情况:您发现自己给一个集合命名不正确，但是您已经向其中插入了一些数据。这可能会使从零开始删除和再次读取数据变得很麻烦。

相反，您可以使用`renameCollection()`函数来重命名您现有的收藏。以下示例向您展示了如何使用这个简单明了的命令:

`> db.media.renameCollection("newname")`

`{ "ok" : 1 }`

如果命令执行成功，将返回一个`OK`。但是，如果失败(例如，如果集合不存在)，则返回以下消息:

`{ "errmsg" : "assertion: source namespace does not exist", "ok" : 0 }`

`renameCollection`命令不带很多参数(不像你目前看到的一些命令)；然而，在适当的情况下，它会非常有用。

## 删除数据

到目前为止，我们已经探索了如何添加、搜索和修改数据。接下来，我们将研究如何删除文档、整个集合以及数据库本身。

之前，您学习了如何从特定文档中删除数据(例如，使用`$pop`命令)。在本节中，您将学习如何删除完整的文档和集合。正如`insert()`功能用于插入，`update()`用于修改文档一样，`remove()`用于删除文档。

若要从收藏中删除单个文档，您需要指定用于查找该文档的条件。一个好的方法是先执行一个`find()`；这确保了所使用的标准特定于您的文档。一旦确定了标准，就可以使用该标准作为参数来调用`remove()`函数:

`> db.newname.remove( { "Title" : "Different Title" } )`

此语句删除之前添加的图书或您的收藏中任何其他同名的项目。该语句删除了该书名下的所有书籍，这也是为什么最好指定项目的`_id`值的原因之一——它总是唯一的。

或者您可以使用下面的代码片段从`newname`库中删除所有文档(记住，我们之前已经将这个集合重命名为`media`):

`> db.newname.remove({})`

Warning

当删除一个文档时，您需要记住对该文档的任何引用都将保留在数据库中。因此，请确保手动删除或更新这些引用；否则，这些引用在计算时将返回 null。引用将在下一节讨论。

如果您想删除整个收藏，您可以使用`drop()`功能。下面的代码片段删除了整个`newname`集合，包括它的所有文档:

`> db.newname.drop()`

`true`

根据操作是否成功完成，`drop()`函数返回`true`或`false`。同样，如果想从 MongoDB 中删除整个数据库，可以使用`dropDatabase()`函数，如下例所示:

`> db.dropDatabase()`

`{ "dropped" : "library", "ok" : 1 }`

请注意，这个代码片段将删除您当前正在工作的数据库(同样，一定要检查`db`以查看哪个数据库是您当前的数据库)。

## 引用数据库

此时，您又有了一个空数据库。您还熟悉向集合中插入各种数据。现在，您已经准备好进一步学习数据库引用。正如您已经看到的，在很多情况下，将数据嵌入到您的文档中就足以满足您的应用(例如图书条目中的曲目列表或作者列表)。但是，有时您确实需要引用另一个文档中的信息。以下部分将解释如何着手这样做。

与 SQL 一样，MongoDB 中文档之间的引用是通过在服务器上执行额外的查询来解决的。MongoDB 提供了两种方法来实现这一点:手动引用它们或者使用 DBRef 标准，许多驱动程序也支持 db ref 标准。

### 手动引用数据

引用数据最简单、最直接的方法是手动操作。当手动引用数据时，通过完整的 ID 或更简单的通用术语，将来自另一个文档的`_id`的值存储在您的文档中。在继续示例之前，让我们添加一个新文档，并在其中指定发布者的信息(密切注意`_id`字段:

`> apress = ( { "_id" : "Apress", "Type" : "Technical Publisher", "Category" :`

`["IT", "Software","Programming"] } )`

`{`

`"_id" : "Apress"`，

`"Type" : "Technical Publisher"`，

`"Category" : [`

`"IT"`，

`"Software"`，

`"Programming"`

`]`

`}`

`> db.publisherscollection.insert(apress)`

一旦添加了出版商的信息，就可以将实际的文档(例如，一本书的信息)添加到`media`集合中了。下面的示例添加一个文档，并将`Apress`指定为发布者的名称:

`> book = ( { "Type" : "Book", "Title" : "Definitive Guide to MongoDB 2nd ed., The"`，

`"ISBN" : "987-1-4302-5821-6", "Publisher" : "Apress","Author" : ["Hows, David",""Plugge, Eelco","Membrey,Peter",Hawkins, Tim"] } )`

`{`

`"Type" : "Book"`，

`"Title" : "Definitive Guide to MongoDB 2nd ed., The"`，

`"ISBN" : "987-1-4302-5821-6"`，

`"Publisher": "Apress"`，

`"Author" : [`

`"Hows, David"`

`"Membrey, Peter"`，

`"Plugge, Eelco"`，

`"` `Hawkins, Tim"`

`]`

`}`

`> db.media.insert(book)`

您需要的所有信息已经分别插入到了`publisherscollection`和`media`集合中。您现在可以开始使用数据库参考。首先，将包含发布者信息的文档指定给一个变量:

`> book = db.media.findOne()`

`{`

`"_id" : ObjectId("4c458e848e0f00000000628e")`，

`"Type" : "Book"`，

`"Title" : "Definitive Guide to MongoDB, The"`，

`"ISBN" : "987-1-4302-3051-9"`，

`"Publisher" : "Apress"`，

`"Author" : [`

`"Hows, David"`

`"Membrey, Peter"`，

`"Plugge, Eelco"`，

`"Hawkins, Tim"`

`]`

`}`

为了获得信息本身，您将`findOne`函数与一些点符号结合起来:

`> db.publisherscollection.findOne( { _id : book.Publisher } )`

`{`

`"_id" : "Apress"`，

`"Type" : "Technical Publisher"`，

`"Category" : [`

`"IT"`，

`"Software"`，

`"Programming"`

`]`

`}`

如本例所示，手动引用数据非常简单，不需要太多脑力劳动。这里，`users`集合中的文档中的`_id`是手工设置的，不是由 MongoDB 生成的(否则，`_id`将是一个对象 ID)。

### 使用 DBRef 引用数据

DBRef 标准为文档间引用数据提供了更正式的规范。使用 DBRef 而不是手动引用的主要原因是，集合可以从一个文档改变到下一个文档。因此，如果您引用的集合总是相同的，那么手动引用数据(如前所述)就可以了。

使用 DBRef，数据库引用被存储为标准的嵌入式(JSON/BSON)对象。用一种标准的方式来表示引用意味着驱动程序和数据框架可以添加以标准方式操作引用的助手方法。

添加 DBRef 引用值的语法如下所示:

`{ $ref :``<collectionname>``, $id :``<id value>``[, $db :``<database name>`T6】

这里，`<collectionname>`表示引用的集合的名称(例如，`publisherscollection`)；`<id value>`代表您正在引用的对象的`_id`字段的值；可选的`$db`允许您引用其他数据库中的文档。

让我们从头开始看另一个使用 DBRef 的例子。首先清空您的两个收藏并添加一个新文档:

`> db.publisherscollection.drop()`

`true`

`> db.media.drop()`

`true`

`> apress = ( { "Type" : "Technical Publisher", "Category" :`

`["IT","Software","Programming"] } )`

`{`

`"Type" : "Technical Publisher"`，

`"Category" : [`

`"IT"`，

`"Software"`，

`"Programming"`

`]`

`}`

`> db.publisherscollection.save(apress)`

到目前为止，您已经定义了变量`apress`并使用`save()`函数保存了它。接下来，通过键入变量名称来显示变量的更新内容:

`> apress`

`{`

`"Type" : "Technical Publisher"`，

`"Category" : [`

`"IT"`，

`"Software"`，

`"Programming"`

`]`，

`"_id" : ObjectId("4c4597e98e0f000000006290")`

`}`

到目前为止，您已经定义了发布者并将其保存到了`publisherscollection`集合中。现在，您已经准备好向引用数据的媒体集合添加一个项目:

`> book = { "Type" : "Book", "Title" : "Definitive Guide to MongoDB 2nd ed., The"`，

`"ISBN" : "978-1-4302-5821-6", "Author": ["Hows, David","Membrey, Peter","Plugge`，

`Eelco","Hawkins, Tim"], Publisher : [ new DBRef ('publisherscollection'`，

`apress._id) ] }`

`{`

`"Type" : "Book"`，

`"Title" : "Definitive Guide to MongoDB 2nd ed., The"`，

`"ISBN" : "987-1-4302-5821-6"`，

`"Author" : [`

`"Hows, David"`

`"Membrey, Peter"`，

`"Plugge, Eelco"`，

`"Hawkins, Tim"`

`]`，

`"Publisher" : [`

`DBRef("publishercollection", "Apress")`

`]`

`}`

`> db.media.save(book)`

就这样！当然，这个例子看起来没有引用数据的手工方法简单；但是，对于集合可能从一个文档变化到下一个文档的情况，这是一个很好的选择。

## 实现与索引相关的功能

在前一章中，您简要地看了一下索引能为您的数据库做些什么。现在是时候简要学习如何创建和使用索引了。索引将在第 10 章中更详细地讨论，但是现在让我们看看基础知识。MongoDB 包含了相当多的用于维护索引的函数；我们将从用`ensureIndex()`函数创建一个索引开始。

`ensureIndex()`函数至少接受一个参数，这个参数是您将用来构建索引的一个文档中的一个键的名称。在前面的例子中，您向使用了`Title`键的`media`集合添加了一个文档。这个键上的索引将很好地服务于这个集合。

Tip

MongoDB 的经验法则是为你想在 MySQL 中创建的相同场景创建一个索引。

您可以通过调用以下命令为此集合创建索引:

`> db.media.ensureIndex( { Title : 1 } )`

该命令确保为来自`media`集合中所有文档的所有`Title`值创建一个索引。行尾的`:1`指定了索引的方向:`1`按升序存储项目，而`-1`按降序存储项目。

`// Ensure ascending index`

`db.media.ensureIndex( { Title :1 } )`

`// Ensure descending index`

`db.media.ensureIndex( { Title :-1 } )`

Tip

搜索索引信息的速度很快。搜索非索引信息很慢，因为每个文档都需要检查是否匹配。

BSON 允许你在一个文档中存储完整的数组；然而，能够在嵌入式键上创建索引也是有益的。幸运的是，MongoDB 的开发者也想到了这一点，并增加了对这一特性的支持。让我们以本章前面的一个例子为基础，将另一个嵌入了信息的文档添加到数据库中:

`> db.media.insert( { "Type" : "CD", "Artist" : "Nirvana","Title" :`

`"Nevermind", "Tracklist" : [ { "Track" : "1", "Title" : "Smells Like Teen`

`Spirit", "Length" : "5:02" }, {"Track" : "2","Title" : "In Bloom", "Length" :`

`"4:15" } ] } )`

`{ "_id" : ObjectId("4c45aa2f8e0f000000006293"), "Type" : "CD", "Artist" :`

`"Nirvana", "Title" : "Nevermind", "Tracklist" : [`

`{`

`"Track" : "1"`，

`"Title" : "Smells Like Teen Spirit"`，

`"Length" : "5:02"`

`}`，

`{`

`"Track" : "2"`，

`"Title" : "In Bloom"`，

`"Length" : "4:15"`

`}`

`] }`

接下来，您可以在`Title`键上为曲目列表中的所有条目创建索引:

`> db.media.ensureIndex( { "Tracklist.Title" : 1 } )`

下一次你搜索收藏中的任何一个标题时——假设它们嵌套在`Tracklist`下——这些标题会立即显示出来。接下来，您可以进一步发展这个概念，使用整个(子)文档作为键，如下例所示:

`> db.media.ensureIndex( { "Tracklist" : 1 } )`

该语句索引数组的每个元素，这意味着您现在可以搜索数组中的任何对象。这些类型的键也称为多键。您还可以基于一组文档中的多个关键字创建索引。这个过程被称为复合索引。您用来创建复合索引的方法基本相同；不同之处在于您指定了几个键，而不是一个，如下例所示:

`> db.media.ensureIndex({"Tracklist.Title": 1, "Tracklist.Length": -1})`

这种方法的好处是可以在多个键上建立索引(就像前面的例子一样，可以索引整个子文档)。但是，与子文档方法不同，复合索引允许您指定是否希望两个字段中的一个按降序进行索引。如果使用子文档方法执行索引，则只能按升序或降序排列。第 10 章中有更多关于复合索引的内容。

### 与测量索引相关的命令

到目前为止，您已经快速浏览了一个与索引相关的命令，`ensureIndex()`。毫无疑问，这是您将主要用来创建索引的命令。然而，您可能还会发现一对有用的附加函数:`hint()`和`min()/max()`。您可以使用这些函数来查询数据。到目前为止，我们还没有介绍它们，因为没有自定义索引它们就无法工作。但是现在让我们来看看他们能为你做什么。

### 强制指定的索引查询数据

您可以使用`hint()`函数在查询数据时强制使用指定的索引。使用该命令的预期好处是提高查询性能。要了解这一原理的实际应用，请尝试在不定义索引的情况下使用`hint()`函数执行`find`:

`> db.media.find( { ISBN: " 978-1-4302-5821-6"} ) . hint ( { ISBN: -1 } )`

`error: { "$err" : "bad hint", "code" : 10113 }`

如果你在 ISBN 号上创建一个索引，这个技术会更成功。注意，第一个命令的`background`参数确保索引是在后台完成的:

`> db.media.ensureIndex({ISBN: 1}, {background: true});`

`> db.media.find( { ISBN: " 978-1-4302-5821-6"} ) . hint ( { ISBN: 1 } )`

`{ "_id" : ObjectId("4c45a5418e0f000000006291"), "Type" : "Book", "Title" : "Definitive Guide to MongoDB, The", "ISBN" : " 978-1-4302-5821-6", "Author" : ["Hows, David","Membrey, Peter", "Plugge, Eelco","Hawkins,Tim"], "Publisher" : [`

`{`

`"$ref" : "publisherscollection"`，

`"$id" : ObjectId("4c4597e98e0f000000006290")`

`}`

`] }`

为了确认给定的索引正在被使用，您可以选择添加`explain()`函数，返回关于所选查询计划的信息。这里，`indexBounds`值告诉您所使用的索引:

`> db.media.find( { ISBN: " 978-1-4302-5821-6"} ) . hint ( { ISBN: 1 } ).explain()`

`{`

`"cursor" : "BtreeCursor ISBN_1"`，

`"isMultiKey" : false`，

`"n" : 1`，

`"nscannedObjects" : 1`，

`"nscanned" : 1`，

`"nscannedObjectsAllPlans" : 1`，

`"nscannedAllPlans" : 1`，

`"scanAndOrder" : false`，

`"indexOnly" : false`，

`"nYields" : 0`，

`"nChunkSkips" : 0`，

`"millis" : 0`，

`"indexBounds" : {`

`"ISBN" : [`

`[`

`{`

`"$minElement" : 1`

`}`，

`{`

`"$maxElement" : 1`

`}`

`]`

`]`

`}`，

`"server" : "localhost:27017"`

`}`

### 约束查询匹配

`min()`和`max()`函数使您能够将查询匹配限制为那些索引键在指定的最小和最大键之间的匹配。因此，您需要为指定的键建立一个索引。此外，您可以将这两个功能结合使用，也可以单独使用。让我们首先添加一些文档，使您能够利用这些功能。首先，在`Released`字段上创建一个索引:

`> db.media.insert( { "Type" : "DVD", "Title" : "Matrix, The", "Released" :`

`1999} )`

`> db.media.insert( { "Type" : "DVD", "Title" : "Blade Runner", "Released" :`

`1982 } )`

`> db.media.insert( { "Type" : "DVD", "Title" : "Toy Story 3", "Released" :`

`2010} )`

`> db.media.ensureIndex( { "Released": 1 } )`

您现在可以使用`max()`和`min()`命令，如下例所示:

`> db.media.find() . min ( { Released: 1995 } ) . max ( { Released : 2005 } )`

`{ "_id" : ObjectId("4c45b5b38e0f0000000062a9"), "Type" : "DVD", "Title" :`

`"Matrix, The", "Released" : 1999 }`

如果没有创建索引，那么将返回一条错误消息，指出没有为指定的键模式找到索引。显然，您需要定义哪个索引必须与`hint()`函数一起使用:

`> db.media.find() . min ( { Released: 1995 } ) .`

`max ( { Released : 2005 } ). hint ( { Released : 1 } )`

`{ "_id" : ObjectId("4c45b5b38e0f0000000062a9"), "Type" : "DVD", "Title" :`

`"Matrix, The", "Released" : 1999 }`

Note

`min()`值将包含在结果中，而`max()`值将从结果中排除。

一般来说，建议您使用`$gt`和`$lt`(分别为大于和小于)，而不是`min()`和`max()`，因为`$gt`和`$lt`不需要索引。`min()`和`max()`功能主要用于复合按键。

## 摘要

在本章中，我们已经了解了可以用 MongoDB shell 来操作数据的最常用的命令和选项。我们还研究了如何搜索、添加、修改和删除数据，以及如何修改您的集合和数据库。接下来，我们快速地看了一下原子操作，如何使用聚合，以及何时使用像`$elemMatch`这样的操作符。最后，我们探讨了如何创建索引以及何时使用它们。我们研究了索引的用途，如何删除索引，如何使用创建的索引搜索数据，以及如何检查正在运行的索引操作。

在下一章中，我们将研究 GridFS 的基础知识，包括它是什么，它做什么，以及如何使用它为您带来好处。