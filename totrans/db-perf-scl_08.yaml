- en: 9. Benchmarking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. 基准测试
- en: '[Latency or Throughput: Choose Your Focus](#Sec1)[Less Is More (at First):
    Taking a Phased Approach](#Sec2)[Benchmarking Do’s and Don’ts](#Sec3)[Reporting
    Do’s and Don’ts](#Sec18)[Special Considerations for Various Benchmarking Goals](#Sec22)[Beyond
    the Usual Benchmark](#Sec27)[Summary](#Sec31)'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[延迟或吞吐量：选择你的重点](#Sec1)[少即是多（起初）：采取分阶段的方法](#Sec2)[基准测试的“做”和“不做”](#Sec3)[报告的“做”和“不做”](#Sec18)[针对各种基准测试目标的不同考虑](#Sec22)[超越常规基准](#Sec27)[总结](#Sec31)'
- en: 'We won’t sugarcoat it: database benchmarking is hard. There are many moving
    parts and nuances to consider and manage—and a bit of homework is required to
    really see what a database is capable of and measure it properly. It’s not easy
    to properly generate system load to reflect your real-life scenarios.^([1](#Fn1))
    It’s often not obvious how to correctly measure and analyze the end results. And
    after extracting benchmarking results, you need to be able to read them, understand
    potential performance bottlenecks, analyze potential performance improvements,
    and possibly dive into other issues. You need to make your benchmarking results
    meaningful, ensure they are easily reproducible, and also be able to clearly explain
    these results to your team and other interested parties in a way that reflects
    your business needs. There’s also hard mathematics involved: statistics and queueing
    theory to help with black boxes and measurements, not to mention domain-specific
    knowledge of the system internals of the servers, platforms, operating systems,
    and the software running on it.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会美化事实：数据库基准测试是困难的。有许多动态部分和细微差别需要考虑和管理——并且需要做一些准备工作才能真正看到数据库的能力并正确测量它。正确生成系统负载以反映现实生活场景并不容易。[1](#Fn1)
    通常并不明显如何正确测量和分析最终结果。在提取基准测试结果后，你需要能够阅读它们，理解潜在的性能瓶颈，分析潜在的性能改进，并可能深入研究其他问题。你需要让你的基准测试结果有意义，确保它们易于重复，并且能够清楚地解释这些结果，以反映你的业务需求。还涉及到一些复杂的数学：统计学和排队论，以帮助处理黑盒和测量，更不用说对服务器、平台、操作系统以及在其上运行的软件的内部系统领域的专业知识了。
- en: But when performance is a top priority, careful—and sometimes frequent—benchmarking
    is essential. And in the long run, it *will* pay off. An effective benchmark can
    save you from even worse pains, like the high-pressure database migration project
    that ensues after you realize—too late—that your existing solution can’t support
    the latest phase of company growth with acceptable latencies and/or throughput.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当性能是首要任务时，仔细——有时甚至是频繁的——基准测试是必不可少的。从长远来看，它*将会*带来回报。有效的基准测试可以让你避免更糟糕的痛苦，比如在你意识到——太迟了——现有的解决方案无法以可接受的延迟和/或吞吐量支持公司最新阶段增长之后，随之而来的高压力数据库迁移项目。
- en: The goal of this chapter is to share strategies that ease the pain slightly
    and, more importantly, increase the chances that the pain pays off by helping
    you select options that meet your performance needs. The chapter begins by looking
    at the two key types of benchmarks and highlighting critical considerations for
    each objective. Then, it presents a phased approach that should help you expose
    problems faster and with lower costs. Next, it dives into the do’s and don’ts
    of benchmark planning, execution, and reporting, with a focus on lessons learned
    from the best and worst benchmarks we’ve witnessed over the past several years.
    Finally, the chapter closes with a look at some less common benchmarking approaches
    you might want to consider for specialized needs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是分享一些策略，这些策略可以稍微减轻痛苦，更重要的是，通过帮助你选择满足性能需求的选择，增加痛苦带来回报的机会。本章首先查看两种主要的基准类型，并强调每个目标的关键考虑因素。然后，它提出了一种分阶段的方法，这应该有助于你更快、成本更低地发现问题。接下来，它深入探讨了基准规划、执行和报告的“做”和“不做”，重点关注过去几年我们见证的最佳和最差基准测试中学到的经验教训。最后，本章以查看一些你可能需要考虑用于特殊需求的较少见的基准测试方法结束。
- en: 'Latency or Throughput: Choose Your Focus'
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟或吞吐量：选择你的重点
- en: 'When benchmarking, you need to decide upfront whether you want to focus on
    throughput or latency. Latency is measured in both cases. But here’s the difference:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在基准测试时，你需要提前决定你想要关注吞吐量还是延迟。在两种情况下都会测量延迟。但这里是有区别的：
- en: '**Throughput focus**: You measure the maximum throughput by sending a new request
    as soon as the previous request completes. This helps you understand the highest
    number of IOPS that the database can sustain. Throughput-focused benchmarks are
    often the focus for analytics use cases (fraud detection, cybersecurity, etc.)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**吞吐量关注点**：你通过在完成上一个请求后立即发送新的请求来测量最大吞吐量。这有助于你了解数据库可以持续的最高IOPS数。吞吐量关注的基准测试通常是分析用例（欺诈检测、网络安全等）的关注点。'
- en: '**Latency focus**: You assess how many IOPS the database can handle without
    compromising latency. This is usually the focus for most user-facing and real-time
    applications.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟关注点**：你评估数据库在不影响延迟的情况下可以处理多少IOPS。这通常是大多数面向用户和实时应用程序的关注点。'
- en: Throughput tests are quite common, but latency tests are a better choice if
    you already know the desired throughput (e.g., 1M OPS). This is especially true
    if your production system must meet a specific latency goal (for example, the
    99.99 percentile should have a read latency of less than 10ms).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 吞吐量测试相当常见，但如果已经知道所需的吞吐量（例如，1M OPS），则延迟测试是一个更好的选择。如果你的生产系统必须满足特定的延迟目标（例如，99.99百分位数的读延迟应小于10ms），这一点尤其正确。
- en: If you’re focused solely on latency, you need to measure and compare latency
    at the same throughput rates. If you know only that database A can handle 30K
    OPS with a certain P99 latency and database B can handle 50K OPS with a slightly
    higher P99 latency, you can’t really say which one is “more efficient.” For a
    fair comparison, you would need to measure each database’s latencies at either
    30K OPS or 50K OPS—or both. Even better, you would track latency across a broader
    span of intervals (e.g., measuring at 10K OPS increments up until when neither
    database could achieve the required P99 latency, as demonstrated in Figure [9-1](#Fig1).)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只关注延迟，你需要测量和比较在相同吞吐量速率下的延迟。如果你只知道数据库A可以在某个P99延迟下处理30K OPS，而数据库B可以在略高的P99延迟下处理50K
    OPS，你实际上并不能说哪一个更“高效”。为了公平比较，你需要测量每个数据库在30K OPS或50K OPS下的延迟——或者两者都要测量。更好的是，你将跟踪更广泛的间隔内的延迟（例如，在10K
    OPS增量下测量，直到两个数据库都无法达到所需的P99延迟，如图[9-1](#Fig1)所示。）
- en: '![](../images/541783_1_En_9_Chapter/541783_1_En_9_Fig1_HTML.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图9-1](../images/541783_1_En_9_Chapter/541783_1_En_9_Fig1_HTML.jpg)'
- en: A line graph titled, 3 node cluster, 100 percent writes, latencies, plots six
    categories. One of the resources maxed out, in all categories. Only one line named,
    Scylla 4.4.3 90% stayed below the 5 milliseconds line.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一条名为“3节点集群，100%写入，延迟”的折线图显示了六个类别。所有类别中有一个资源达到了最大值。只有一条名为“Scylla 4.4.3 90%”的线保持在5毫秒以下。
- en: Figure 9-1
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-1
- en: A latency-oriented benchmark
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个以延迟为导向的基准测试
- en: Not all latency benchmarks need to take that form, however. Consider the example
    of an AdTech company with a real-time bidding use case. For them, a request that
    takes longer than 31ms is absolutely useless because it will fall outside of the
    bidding window. It’s considered a timeout. And any request that is 30ms or less
    is fine; a 2ms response is not any more valuable to them than a 20ms response.
    They care only about which requests time out and which don’t.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有延迟基准测试都需要采取那种形式。以一个拥有实时竞价用例的AdTech公司为例。对他们来说，超过31毫秒的请求是完全无用的，因为它将超出竞价窗口。这被视为超时。任何30毫秒或更短的请求都是可以接受的；2毫秒的响应对他们来说并不比20毫秒的响应更有价值。他们只关心哪些请求超时，哪些没有。
- en: Their benchmarking needs are best served by a latency benchmark measuring how
    many OPS were generating timeouts over time. For example, Figure [9-2](#Fig2)
    shows that the first database in their benchmark (the top line) resulted in over
    100K timeouts a second around 11:30; the other (the horizontal line near the bottom)
    experienced only around 200 timeouts at that same point in time, and throughout
    the duration of that test.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的基准测试需求最好通过一个测量随时间产生超时请求次数的延迟基准来满足。例如，图[9-2](#Fig2)显示，在他们基准测试中的第一个数据库（最上面的线条）在11:30左右每秒产生了超过10万次超时；另一个（接近底部的水平线）在同一时间点只经历了大约200次超时，并且在测试期间也是如此。
- en: '![](../images/541783_1_En_9_Chapter/541783_1_En_9_Fig2_HTML.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图9-2](../images/541783_1_En_9_Chapter/541783_1_En_9_Fig2_HTML.jpg)'
- en: A line graph illustrates that the first database in their benchmark, represented
    by a top line, resulted in over 100 K timeouts a second around 11 30, the other,
    represented by the horizontal line near the bottom, experienced only around 200
    timeouts at that same point in time, and throughout the duration of that test.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一条线图说明了他们在基准测试中的第一个数据库，由顶部线条表示，在11:30左右每秒超过100K次超时，另一个，由底部附近的水平线表示，在同一时间点只经历了大约200次超时，在整个测试过程中也是如此。
- en: Figure 9-2
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-2
- en: A latency-oriented benchmark measuring how many OPS were generating timeouts
    over time
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个以延迟为导向的基准，测量随时间生成的OPS超时数量
- en: For contrast, Figure [9-3](#Fig3) shows an example of a throughput benchmark.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对比，图[9-3](#Fig3)展示了吞吐量基准的一个示例。
- en: '![](../images/541783_1_En_9_Chapter/541783_1_En_9_Fig3_HTML.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/541783_1_En_9_Chapter/541783_1_En_9_Fig3_HTML.jpg)'
- en: A triple bar graph titled, 3 node cluster, maximum throughout, has five categories.
    One of the resources maxed out, in all categories.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个标题为“3节点集群，最大值”的三条杠图表，有五个类别。其中一个资源在所有类别中达到最大值。
- en: Figure 9-3
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-3
- en: A throughput-oriented benchmark
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以吞吐量为导向的基准
- en: With a throughput benchmark, you want to see one of the resources (e.g., the
    CPU or disk) maxing out in order to understand how much the database can deliver
    under extreme load conditions. If you don’t reach this level, it’s a sign that
    you’re not really effectively benchmarking the database’s throughput. For example,
    Figure [9-4](#Fig4) demonstrates the load of two clusters during a benchmark run.
    Note how one cluster is fully utilized whereas the other is very close to reaching
    its limits.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在吞吐量基准测试中，你希望看到资源之一（例如，CPU或磁盘）达到最大值，以便了解数据库在极端负载条件下能提供多少性能。如果你没有达到这个水平，这表明你并没有真正有效地基准测试数据库的吞吐量。例如，图[9-4](#Fig4)展示了基准运行期间两个集群的负载。注意一个集群被充分利用，而另一个集群非常接近其极限。
- en: '![](../images/541783_1_En_9_Chapter/541783_1_En_9_Fig4_HTML.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/541783_1_En_9_Chapter/541783_1_En_9_Fig4_HTML.jpg)'
- en: A graph is titled load, one cluster reached the top and remained flat at the
    top and drops sharply at the end. Another cluster stays just below the top, remain
    flat and drops sharply at the end.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图表标题为负载，一个集群达到顶部并保持在顶部，然后在末端急剧下降。另一个集群保持在顶部下方，保持平稳，然后在末端急剧下降。
- en: Figure 9-4
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-4
- en: 'Two clusters’ load comparison: one fully maxed out and another very close to
    reaching its limit'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集群的负载比较：一个完全达到最大值，另一个非常接近其极限
- en: 'Less Is More (at First): Taking a Phased Approach'
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 少即是多（起初）：采取分阶段的方法
- en: With either focus, the number one rule of benchmarking is to start simple. Always
    keep a laser focus on the specific questions you want the benchmark to answer
    (more on that shortly). But, realize that it could take a number of phases—each
    with a fair amount of trial and error—to get meaningful results.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种关注点，基准测试的第一条规则是保持简单。始终专注于你想让基准测试回答的具体问题（稍后将有更多介绍）。但，要意识到这可能需要多个阶段——每个阶段都有相当多的尝试和错误——才能得到有意义的结果。
- en: 'What could go wrong? A lot. For example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 会出什么问题？很多。例如：
- en: Your client might be a bottleneck
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的客户端可能是一个瓶颈
- en: Your database sizing might need adjustment
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能需要调整数据库的规模
- en: Your tests might need tuning
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的测试可能需要调整
- en: A sandbox environment could have very different resources than a production
    one
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沙盒环境可能拥有与生产环境非常不同的资源
- en: Your testing methodology might be too artificial to predict reality
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的测试方法可能过于人为，无法预测现实
- en: If you start off with too much complexity, it will be a nightmare to discover
    what’s going wrong and pinpoint the source of the problem. For example, assume
    you want to test if a database can handle 1M OPS of traffic from your client with
    a P99 latency of 1ms or less. However, you notice the latencies are exceeding
    the expected threshold. You might spend days adjusting database configurations
    to no avail, then eventually figure out that the problem stemmed from a bug in
    client-side concurrency. This would have been much more readily apparent if you
    started out with just a fraction of that throughput. In addition to avoiding frustration
    and lost time, you would have saved your team a lot of unnecessary infrastructure
    costs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一开始就引入了过多的复杂性，那么发现哪里出错以及确定问题根源将是一场噩梦。例如，假设你想测试数据库是否能处理来自客户端的1M OPS流量，P99延迟为1ms或更少。然而，你注意到延迟超出了预期的阈值。你可能花费数天调整数据库配置，但毫无成效，最终发现问题是客户端并发中的错误。如果你一开始只使用一小部分这种吞吐量，这个问题会更容易被发现。除了避免挫败感和浪费时间之外，你还会为你所在的团队节省大量的不必要的基础设施成本。
- en: 'As a general rule of thumb, consider at least two phases of benchmarking: one
    with a specialized stress tool and one with your real workload (or at least a
    sampling of it—e.g., sending 30 percent of your queries to a cluster for benchmarking).
    For each phase, start super small (at around 10 percent of the throughput you
    ultimately want to test), troubleshoot as needed, then gradually increase the
    scope until you reach your target loads. Keep optimization in mind throughout.
    Do you need to add more servers or more clients to achieve a certain throughput?
    Or are you limited (by budget or infrastructure) to a fixed hardware configuration?
    Can you achieve your performance goals with less?'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，考虑至少两个基准测试阶段：一个使用专门的压力工具，另一个使用您真实的负载（或者至少是它的一个样本——例如，将30%的查询发送到集群进行基准测试）。对于每个阶段，从超级小规模开始（大约是您最终想要测试的吞吐量的10%），根据需要排除故障，然后逐渐扩大范围，直到达到目标负载。在整个过程中始终考虑优化。您需要添加更多服务器或更多客户端来实现一定的吞吐量吗？或者您（由于预算或基础设施的限制）被固定硬件配置所限制？您能否用更少的资源实现您的性能目标？
- en: The key is to move incrementally. Of course, the exact approach will vary from
    situation to situation. Consider a leading travel company’s approach. Having recently
    moved from PostgreSQL to Cassandra, they were quite experienced benchmarkers when
    they decided to evaluate Cassandra alternatives. The goal was to test the new
    database candidate’s raw speed and performance, along with its support for their
    specific workloads.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是逐步进行。当然，具体方法会因情况而异。考虑一家领先的旅游公司的做法。最近从PostgreSQL迁移到Cassandra后，当他们决定评估Cassandra的替代方案时，他们已经相当有经验的基准测试者了。目标是测试新的数据库候选人的原始速度和性能，以及它对其特定工作负载的支持。
- en: First, they stood up a five-node cluster and ran database comparisons with synthetic
    traffic from cassandra-stress. This gave them confidence that the new database
    could meet their performance needs with *some* workloads. However, their real
    workloads are nothing like even customized cassandra-stress workloads. They experience
    highly variable and unpredictable traffic (for example, massive surges and disruptions
    stemming from a volcanic eruption). For a more realistic assessment, they started
    shadowing production traffic. This second phase of benchmarking provided the added
    confidence they needed to move forward with the migration.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，他们建立了一个五节点集群，并使用来自cassandra-stress的合成流量进行数据库比较。这让他们有信心，新的数据库能够在某些工作负载下满足他们的性能需求。然而，他们的实际工作负载与定制的cassandra-stress工作负载完全不同。他们经历了高度可变和不可预测的流量（例如，由火山爆发引起的巨大激增和中断）。为了进行更现实的评估，他们开始跟踪生产流量。这个基准测试的第二阶段为他们提供了所需的额外信心，使他们能够继续迁移。
- en: 'Finally, they used the same shadowed traffic to determine the best deployment
    option. Moving to a larger 21-node cluster, they tested across cloud provider
    A and cloud provider B on bare metal. They also experimented with many different
    options on cloud provider B: various storage options, CPUs, and so on.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，他们使用相同的跟踪流量来确定最佳的部署选项。迁移到一个更大的21节点集群，他们在云服务提供商A和云服务提供商B的裸金属上进行测试。他们还在云服务提供商B上尝试了许多不同的选项：各种存储选项、CPU等。
- en: 'The bottom line here: Start simple, confirm, then scale incrementally. It’s
    safer and ultimately faster. Plus, you’ll save on costs. As you move through the
    process, check if you need to tweak your setup during your testing. Once you are
    eventually satisfied with the results, scale your infrastructure accordingly to
    meet your defined criteria.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里底线是：从简单开始，确认，然后逐步扩展。这更安全，最终也更快。此外，您还可以节省成本。在您通过这个过程时，检查您是否需要在测试过程中调整您的设置。一旦您最终对结果满意，相应地扩展您的基础设施以满足您定义的标准。
- en: Benchmarking Do’s and Don’ts
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基准测试的“应该做和不应该做”
- en: The specific step-by-step instructions for how to configure and run a benchmark
    vary across databases and benchmarking tools, so we’re not going to get into that.
    Instead, let’s look at some of the more universal “do’s and don’ts” based on what
    we’ve seen in the field.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如何配置和运行基准测试的具体步骤因数据库和基准测试工具而异，所以我们不会深入探讨。相反，让我们看看一些更通用的“应该做和不应该做”的建议，这些是基于我们在现场看到的情况。
- en: Tip
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you haven’t done so yet, be sure to review the chapters on drivers, infrastructure,
    and topology considerations before you begin benchmarking.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请在开始基准测试之前，务必回顾有关驱动程序、基础设施和拓扑考虑因素的章节。
- en: Know What’s Under the Hood of Your Database (Or Find Someone Who Knows)
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解您数据库的“引擎盖下”是什么（或者找到知道的人）
- en: Understand and anticipate what parts of the system your chosen workload will
    affect and how. How will it stress your CPUs? Your memory? Your disks? Your network?
    Do you know if the database automatically analyzes the system it’s running on
    and prioritizes application requests as opposed to internal tasks? What’s going
    on as far as background operations and how these may skew your results? And why
    does all this matter if you’re just trying to run a benchmark?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 理解并预测你的选择的工作负载将如何影响系统的哪些部分以及如何影响。它将如何压力你的CPU？你的内存？你的磁盘？你的网络？你知道数据库是否会自动分析其运行在的系统并将应用请求优先于内部任务吗？背景操作在进行中，以及这些可能如何扭曲你的结果？如果你只是想运行基准测试，这一切为什么又很重要呢？
- en: Let’s take the example of compaction with LSM-tree based databases. As we’ll
    cover in Chapter [11](541783_1_En_11_Chapter.xhtml), compactions do have a significant
    impact on performance. But compactions are unlikely to kick in if you run a benchmark
    for just a few minutes. Given that compactions have dramatically different performance
    impacts on different databases, it’s essential to know that they will occur and
    ensure that tests last long enough to measure their impact.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以基于LSM-tree的数据库的压缩为例。正如我们将在第[11](541783_1_En_11_Chapter.xhtml)章中讨论的，压缩确实对性能有显著影响。但如果你只运行几分钟的基准测试，压缩不太可能启动。鉴于压缩对不同数据库的性能影响差异很大，了解它们将会发生并确保测试持续足够长的时间以衡量其影响是至关重要的。
- en: The important thing here is to try to understand the system that you’re benchmarking.
    The better you understand it, the better you can plan tests and interpret the
    results. If there are vendors and/or user groups behind the database you’re benchmarking,
    try to probe them for a quick overview of how the database works and what you
    should watch out for. Otherwise, you might overlook something that comes back
    to haunt you, such as finding out that your projected scale was too optimistic.
    Or, you might freak out over some KPI that’s really a non-issue.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是要尽量理解你正在基准测试的系统。你理解得越好，你就能更好地规划测试和解读结果。如果你正在基准测试的数据库背后有供应商和/或用户团体，尝试向他们询问关于数据库如何工作以及你应该注意什么的快速概述。否则，你可能会忽略一些会回来困扰你的事情，比如发现你预期的规模过于乐观。或者，你可能会对一些实际上是无关紧要的KPI感到恐慌。
- en: Choose an Environment That Takes Advantage of the Database’s Potential
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择一个能够发挥数据库潜能的环境
- en: This is really a corollary to the previous tip. With a firm understanding of
    your database’s superpowers, you can design benchmark scenarios that fully reveal
    its potential. For example, if you want to compare two databases designed for
    commodity hardware, don’t worry about benchmarking them on a broad array of powerful
    servers. But if you’re comparing a database that’s architected to take advantage
    of powerful servers, you’d be remiss to benchmark it only on commodity hardware
    (or even worse, using a Docker image on a laptop). That would be akin to test
    driving a race car on the crowded streets of New York City rather than your local
    equivalent of the Autobahn highway.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是对前一条建议的补充。对你数据库的超级能力有了一个坚定的理解后，你可以设计基准测试场景，以充分揭示其潜能。例如，如果你想比较两种为通用硬件设计的数据库，不必担心在广泛的强大服务器上进行基准测试。但如果你正在比较一个旨在利用强大服务器的数据库，只在其上（或者更糟糕的是，在笔记本电脑上使用Docker镜像）进行基准测试将是失职的。这就像在纽约市拥挤的街道上试驾赛车，而不是在你当地的Autobahn高速公路上一样。
- en: Likewise, if you think some aspect of the database or your data modeling will
    be problematic for your use case, now’s the time to push it to the limits and
    assess its true impact. For example, if you think a subset of your data might
    have imbalanced access patterns due to user trends, use the benchmark phase to
    reproduce that and assess the impacts.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你认为数据库或你的数据建模的某些方面可能会对你的用例造成问题，现在是时候将其推到极限并评估其真实影响。例如，如果你认为你的数据子集可能由于用户趋势而具有不平衡的访问模式，请使用基准测试阶段来重现这种情况并评估其影响。
- en: Use an Environment That Represents Production
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用一个代表生产环境的环境
- en: Benchmarking in the wrong environment can easily lead to an order-of-magnitude
    performance difference. For example, a laptop might achieve 20K OPS where a dedicated
    server could easily achieve 200K OPS. Unless you intend to have your production
    system running on a laptop, do not benchmark (or run comparisons) on a laptop.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在错误的环境中基准测试可能会轻易导致性能差异达到一个数量级。例如，一台笔记本电脑可能只能达到20K OPS，而一台专用服务器则能轻松实现200K OPS。除非你打算让你的生产系统在笔记本电脑上运行，否则不要在笔记本电脑上进行基准测试（或运行比较）。
- en: If you are using shared hardware in a containerized/virtualized environment,
    be aware that one guest can increase latency in other guests. As a result, you’ll
    typically want to ensure that hardware resources are dedicated to your database
    and that you avoid resource overcommitment by any means possible.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个容器化/虚拟化环境中使用共享硬件，请注意一个虚拟机可能会增加其他虚拟机的延迟。因此，你通常会想确保硬件资源是专门为你的数据库分配的，并且通过任何可能的方式避免资源过度承诺。
- en: 'Also, don’t overlook the environment for your load generators. If you underprovision
    load generators, the load generators themselves will be the bottleneck. Another
    consideration: Ensure that the database and the data loader are not running under
    the same nodes. Pushing and pulling data is resource intensive, so the loader
    will definitely steal resources from the database. This will impact your results
    with any database.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，也不要忽视负载生成器的环境。如果你为负载生成器分配的资源不足，负载生成器本身将成为瓶颈。另一个考虑因素：确保数据库和数据加载器不在同一节点上运行。推送和拉取数据是资源密集型的，因此加载器肯定会从数据库中窃取资源。这将影响任何数据库的结果。
- en: Don’t Overlook Observability
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要忽视可观察性
- en: Having observability into KPIs beyond throughput and latency is critical for
    identifying and troubleshooting issues. For instance, you might not be hitting
    the cache as much as intended. Or a network interface might be overwhelmed with
    data to the point that it interferes with latency. Observability is also your
    primary tool for validating that you’re not being overly optimistic—or pessimistic—when
    reviewing results. You may discover that even read requests served from disk,
    with a cold cache, are within your latency requirements.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在吞吐量和延迟之外，对关键性能指标的可观察性对于识别和解决问题至关重要。例如，你可能没有像预期的那样频繁地命中缓存。或者，网络接口可能因为数据过多而超负荷，以至于影响了延迟。可观察性也是你验证在审查结果时是否过于乐观或悲观的主要工具。你可能会发现，即使是来自磁盘的读取请求，在冷缓存的情况下，也符合你的延迟要求。
- en: Note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For extensive discussion on this topic, see Chapter [10](541783_1_En_10_Chapter.xhtml).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个主题的详细讨论，请参阅第 [10](541783_1_En_10_Chapter.xhtml) 章。
- en: Use Standardized Benchmarking Tools Whenever Feasible
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在可能的情况下，始终使用标准化的基准测试工具
- en: 'Don’t waste resources building—and debugging and maintaining—your own version
    of a benchmarking tool that has already been solved for. The community has developed
    an impressive set of tools that can cover a wide range of needs. For example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不要浪费资源去构建、调试和维护一个已经解决的问题的基准测试工具版本。社区已经开发了一套令人印象深刻的工具，可以满足广泛的需求。例如：
- en: YCSB^([2](#Fn2))
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YCSB^([2](#Fn2))
- en: TPC-C^([3](#Fn3))
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TPC-C^([3](#Fn3))
- en: NdBench^([4](#Fn4))
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NdBench^([4](#Fn4))
- en: Nosqlbench^([5](#Fn5))
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nosqlbench^([5](#Fn5))
- en: pgbench^([6](#Fn6))
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pgbench^([6](#Fn6))
- en: TLP-stress^([7](#Fn7))
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TLP-stress^([7](#Fn7))
- en: Cassandra-stress^([8](#Fn8))
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cassandra-stress^([8](#Fn8))
- en: and more…
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及更多…
- en: They are all relatively the same and provide similar configuration parameters.
    Your task is to understand which one better reflects the workload you are interested
    in and how to run it properly. When in doubt, consult with your vendor for specific
    tooling compatible with your database of choice.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都是相对相同的，并提供类似的配置参数。你的任务是理解哪一个更好地反映了你感兴趣的工作负载，以及如何正确运行它。如果有疑问，请咨询你的供应商，了解与所选数据库兼容的特定工具。
- en: 'Of course, these options won’t cover everything. It makes sense to develop
    your own tools if:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些选项不会涵盖一切。如果你：
- en: Your workloads look nothing like the ones offered by standard tools (for example,
    you rely on multiple operations that are not natively supported by the tools)
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的工作负载与标准工具提供的工作负载完全不同（例如，你依赖于工具本身不支持的多项操作）
- en: It helps you test against real (or more realistic) workloads in the later phases
    of your benchmarking strategy
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以帮助你在基准测试策略的后期阶段测试针对真实（或更真实）的工作负载
- en: 'Ideally, the final stages of your benchmarking would involve connecting your
    application to the database and seeing how it responds to your real workload.
    But what if, for example, you are comparing two databases that require you to
    implement the application logic in two totally different ways? In this case, the
    different application logic implementations could influence your results as much
    as the difference in databases. Again, we recommend starting small: Testing just
    the basic functionality of the application against both targets (following each
    one’s best practices) and seeing what the initial results look like.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，您的基准测试的最后阶段应该涉及将您的应用程序连接到数据库，并查看它对实际工作负载的反应。但是，如果您正在比较需要以两种完全不同的方式实现应用程序逻辑的两个数据库，那会怎样呢？在这种情况下，不同的应用程序逻辑实现可能会对结果产生的影响与数据库之间的差异一样大。再次强调，我们建议从小处着手：仅测试应用程序针对两个目标的基本功能（遵循每个目标的最佳实践），并查看初始结果如何。
- en: Use Representative Data Models, Datasets, and Workloads
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用代表性的数据模型、数据集和工作负载
- en: As you progress past the initial “does this even work” phase of your benchmarking,
    it soon becomes critical to gravitate to representative data models, datasets,
    and workloads. The closer you approximate your production environment, the better
    you can trust that your results accurately represent what you will experience
    in production.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您从基准测试的初始“这甚至能工作吗”阶段进展，很快就会变得关键的是转向代表性的数据模型、数据集和工作负载。您越接近生产环境，就越能信任您的结果准确地代表了您在生产环境中将经历的情况。
- en: Data Models
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据模型
- en: Tools such as cassandra-stress use a default data model that does not completely
    reflect what most teams use in production. For example, the cassandra-stress default
    data model has a replication factor set to 1 and uses `LOCAL_ONE` as a consistency
    level. Although cassandra-stress is a convenient way to get some initial performance
    impressions, it is critical to benchmark the same/similar data model that you
    will use in production. That’s why we recommend using a custom data model and
    tuning your consistency level and queries. cassandra-stress and other benchmarking
    tools commonly provide ways to specify a user profile, where you can specify your
    own schema, queries, replication factor, request distribution and sizes, throughput
    rates, number of clients, and other aspects.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，cassandra-stress这样的工具使用默认的数据模型，并不能完全反映大多数团队在生产环境中使用的数据模型。例如，cassandra-stress的默认数据模型将复制因子设置为1，并使用`LOCAL_ONE`作为一致性级别。虽然cassandra-stress是一种方便的方式来获得一些初始的性能印象，但关键是要基准测试您将在生产中使用的相同/类似的数据模型。这就是为什么我们建议使用自定义数据模型，并调整您的一致性级别和查询。cassandra-stress和其他基准测试工具通常提供指定用户配置文件的方法，您可以在其中指定自己的模式、查询、复制因子、请求分布和大小、吞吐量速率、客户端数量以及其他方面。
- en: Dataset Size
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据集大小
- en: If you run the benchmark with a dataset that’s smaller than your production
    dataset, you may have misleading or incorrect results due to the reduced number
    of I/O operations. Eventually, you should configure a test that realistically
    reflects a fraction of your production dataset size corresponding to your current
    scale.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用小于生产数据集的数据集运行基准测试，由于I/O操作数量的减少，您可能会得到误导性或不正确的结果。最终，您应该配置一个测试，以现实地反映您当前规模对应的生产数据集大小的部分。
- en: Workloads
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 工作负载
- en: Run the benchmark using a load that represents, as closely as possible, your
    anticipated production workload. This includes the queries submitted by the load
    generator. When you use the right type of queries, they are distributed over the
    cluster and the ratio between reads and writes remains relatively constant.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用尽可能接近您预期生产工作负载的负载运行基准测试。这包括由负载生成器提交的查询。当您使用正确的查询类型时，它们将在集群中分布，并且读和写之间的比例保持相对恒定。
- en: The read/write ratio is important. Different combinations will impact your disk
    in different ways. If you want results representative of production, use a realistic
    workload mix.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 读写比例很重要。不同的组合将以不同的方式影响您的磁盘。如果您想要代表生产环境的结果，请使用现实的工作负载混合。
- en: Eventually, you will max out your storage I/O throughput and starve your disk,
    which causes requests to start queuing on the database. If you continue pushing
    past that point, latency will increase. When you hit that point of increased latency
    with unsatisfactory results, stop, reflect on what happened, analyze how you can
    improve, and iterate through the test again. Rinse and repeat as needed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你会达到存储I/O吞吐量的极限，并使磁盘饥饿，这会导致请求开始在数据库上排队。如果你继续超过这个点，延迟会增加。当你达到这个增加延迟的点，并且结果不满意时，停下来，反思发生了什么，分析如何改进，然后再次迭代测试。根据需要重复冲洗和重复。
- en: 'Here are some tips on creating realistic workloads for common use cases:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于为常见用例创建真实工作负载的技巧：
- en: '**Ingestion**: Ingest data as fast as possible for at least a few hours, and
    do it in a way that doesn’t produce timeouts or errors. The goal here is to ensure
    that you’ve got a stable system, capable of keeping up with your expected traffic
    rate for long periods.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摄取**：尽可能快地摄取数据，至少持续几个小时，并且以不会产生超时或错误的方式进行。这里的目的是确保你有一个稳定的系统，能够在长时间内跟上你预期的流量速率。'
- en: '**Real-time bidding**: Use bulk writes coming in after hours or constantly
    low background loads; the core of the workload is a lot of reads with extremely
    strict latency requirements (perhaps below a specific threshold).'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时竞价**：使用下班后或持续的低背景负载的批量写入；工作负载的核心是大量的读取，具有极端严格的延迟要求（可能低于特定阈值）。'
- en: '**Time series**: Use heavy and constant writes to ever-growing partitions split
    and bucketed by time windows; reads tend to focus on the latest rows and/or a
    specific range of time.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间序列**：使用重负载和恒定的写入到不断增长的分区，这些分区由时间窗口分割和分桶；读取通常集中在最新的行和/或特定的时间范围内。'
- en: '**Metadata store**: Use writes occasionally, but focus on random reads representing
    users accessing your site. There’s usually good cacheability here.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元数据存储**：偶尔进行写入，但重点关注代表用户访问你的网站的随机读取。这里通常有很好的缓存性。'
- en: '**Analytics**: Periodically write a lot of information and perform a lot of
    full table scans (perhaps in parallel with some of the other workloads).'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析**：定期写入大量信息并执行大量全表扫描（可能与其他工作负载并行进行）。'
- en: The bottom line is to try to emulate what your workloads look like and run something
    that’s meaningful to you.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 核心是要尽量模拟你的工作负载的样子，运行对你有意义的事情。
- en: Exercise Your Cache Realistically
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现实地锻炼你的缓存
- en: Unless you can absolutely guarantee that your workload has a high cache hit
    rate frequency, be pessimistic and exercise it well.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你能绝对保证你的工作负载有高缓存命中率频率，否则要持悲观态度，并好好练习。
- en: You might be running workloads, getting great results, and seeing cache hits
    all the way up to 90 percent. That’s great. But is this the way you’re going to
    be running in practice all the time? Do you have periods throughout the day when
    your cache is not going to be that warm, maybe because there’s something else
    running? In real-life situations, you will likely have times when the cache is
    colder or even super cold (e.g., after an upgrade or after a hardware failure).
    Consider testing those scenarios in the benchmark as well.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能正在运行工作负载，得到很好的结果，并且看到缓存命中率高达90%。那很好。但这是你将一直运行的方式吗？你有没有一天中缓存不会那么热的时候，可能是因为有其他事情在运行？在现实情况下，你可能会遇到缓存较冷或超级冷的时间（例如，升级后或硬件故障后）。考虑在基准测试中也测试这些场景。
- en: If you want to make sure that all requests are coming from the disk, you can
    disable the cache altogether. However, be aware that this is typically an extreme
    situation, as most workloads (one way or another) exercise some caching. Sometimes
    you can create a cold cache situation by just restarting the nodes or restarting
    the processes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想确保所有请求都来自磁盘，你可以完全禁用缓存。然而，请注意，这通常是一种极端情况，因为大多数工作负载（无论如何）都会进行一些缓存。有时，只需重新启动节点或进程，就可以创建一个冷缓存情况。
- en: Look at Steady State
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看稳态
- en: Most databases behave differently in real life than they do in short transient
    test situations. They usually run for days or years—so when you test a database
    for two minutes, you’re probably not getting a deep understanding of how it behaves,
    unless you are working in memory only. Also, when you’re working with a database
    that is built to serve tens or hundreds of terabytes—maybe even petabytes—know
    that it’s going to behave rather differently at various data levels. Requests
    become more expensive, especially read requests. If you’re testing something that
    only serves a gigabyte, it really isn’t the same as testing something that’s serving
    a terabyte.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数据库在实际生活中的表现与在短暂的测试情况中的表现不同。它们通常运行几天或几年——所以当你测试数据库两分钟时，除非你只在工作内存中工作，否则你很可能不会深入了解它的行为。此外，当你与一个旨在服务数十或数百TB——甚至可能PB——的数据库一起工作时，要知道它在不同的数据级别上会有相当不同的表现。请求变得更为昂贵，尤其是读请求。如果你测试的是只服务一个GB的东西，这根本不同于测试服务一个TB的东西。
- en: Figure [9-5](#Fig5) exemplifies the importance of looking at steady state. Can
    you tell what throughput is being sustained by the database in question?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图[9-5](#Fig5)展示了观察稳定状态的重要性。你能说出所讨论数据库的吞吐量是多少吗？
- en: '![](../images/541783_1_En_9_Chapter/541783_1_En_9_Fig5_HTML.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图](../images/541783_1_En_9_Chapter/541783_1_En_9_Fig5_HTML.jpg)'
- en: A graph titled, Requests served. A line rises sharply, drops slightly, and remains
    flat for the rest of the duration.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一个标题为“请求服务”的图表。一条线急剧上升，略微下降，然后在剩余时间内保持平坦。
- en: Figure 9-5
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-5
- en: A throughput graph that is not focused on steady state
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一个没有关注稳定状态吞吐量的图表
- en: Well, if you look just at the first minute, it seems that it’s serving 40K OPS.
    But if you wait for a few minutes, the throughput decreases.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，如果你只看第一分钟，它似乎以40K OPS的速度提供服务。但如果你等待几分钟，吞吐量就会下降。
- en: Whenever you want to make a statement about the maximum throughput that your
    database can handle, do that from a steady state. Make sure that you’re inserting
    an amount of data that is meaningful, not just a couple of gigabytes, and make
    sure that it runs for enough time so it’s a realistic scenario. After you are
    satisfied with how many requests can be sustained over a prolonged period of time,
    consider adding noise, such as scaling clients, and introducing failure situations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你想陈述你的数据库可以处理的最大吞吐量时，请从稳定状态开始。确保你插入的数据量是有意义的，而不仅仅是几吉字节，并确保它运行足够长的时间，以便它是现实场景。在你对在长时间内可以持续多少请求感到满意后，考虑添加噪声，例如扩展客户端，并引入故障情况。
- en: Watch Out for Client-Side Bottlenecks
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意客户端瓶颈
- en: One of the most common mistakes with benchmarks is overlooking the fact that
    the bottleneck could be coming from the application side. You might have to tune
    your application clients to allow for a higher concurrency. You may also be running
    many application pods on the same tenant—with all instances contending for the
    same hardware resources. Make sure your application is running in a proper environment,
    as is your database.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试中最常见的错误之一是忽略了瓶颈可能来自应用侧的事实。你可能需要调整你的应用程序客户端以允许更高的并发性。你也可能在一个租户上运行许多应用程序Pod——所有实例都在争夺相同的硬件资源。确保你的应用程序在适当的环境中运行，就像你的数据库一样。
- en: Also Watch Out for Networking Issues
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还要注意网络问题
- en: Networking issues could also muddle the results of your benchmarking. If the
    database is consuming too much softirq from processing, this will degrade your
    performance. You can detect this by analyzing CPU interrupt shares, for example.
    And you can typically resolve it by using CPU pinning, which tells the system
    that all network interrupts should be handled by specific CPUs that are not being
    used by the database.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 网络问题也可能使你的基准测试结果变得混乱。如果数据库消耗了过多的软中断来处理，这将降低你的性能。你可以通过分析CPU中断份额来检测这一点，例如。通常，你可以通过使用CPU固定来解决这个问题，这告诉系统所有网络中断都应该由数据库未使用的特定CPU处理。
- en: Similarly, running your application through a slow link, such as routing traffic
    via the Internet rather than via a private link, can easily introduce a networking
    bottleneck.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，通过慢速链路运行你的应用程序，例如通过互联网而不是通过私有链路路由流量，可以轻易引入网络瓶颈。
- en: Document Meticulously to Ensure Repeatability
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 认真记录以确保可重复性
- en: It’s difficult to anticipate when or why you might want to repeat a benchmark.
    Maybe you want to assess the impact of optimizations you made after getting some
    great tips at the vendor’s user conference. Maybe you just learned that your company
    was acquired and you should prepare to support ten times your current throughput—or
    much stricter latency SLAs. Perhaps you learned about a cool new database that’s
    API-compatible with your current one, and you’re curious how the performance stacks
    up. Or maybe you have a new boss with a strong preference for another database
    and you suddenly need to re-justify your decision with a head-to-head comparison.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 预测何时以及为什么你可能想要重复基准测试是很困难的。也许你希望在供应商的用户会议上得到一些很好的建议后评估你进行的优化对性能的影响。也许你刚刚得知你的公司被收购，你应该准备支持比目前多十倍的吞吐量——或者更严格的延迟SLA。也许你了解到一个与当前数据库API兼容的新数据库，你很好奇性能如何。或者，也许你有一个对另一种数据库有强烈偏好的新老板，你需要突然通过面对面比较来重新证明你的决定。
- en: 'Whatever the reason you’re repeating a benchmark scenario, one thing is certain:
    You will be immensely appreciative of the time that you previously spent documenting
    exactly what you did and why.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你重复基准测试场景的原因是什么，有一点是确定的：你会非常感激之前花时间详细记录你所做的一切以及原因。
- en: Reporting Do’s and Don’ts
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 报告的注意事项
- en: So you’ve completed your benchmark and you’ve gathered all sorts of data—what’s
    the best way to report it? Don’t skimp on this final, yet critical step. Clear
    and compelling reporting is critical for convincing others to support your recommended
    course of action—be it embarking on a database migration, changing your configuration
    or data modeling, or simply sticking with what’s working well for you.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你已经完成了基准测试，并收集了各种数据——最好的报告方式是什么？不要在这个最终且关键的一步上节省。清晰而有说服力的报告对于说服他人支持你的建议方案至关重要——无论是开始数据库迁移、更改配置或数据建模，还是简单地坚持对你来说效果良好的方案。
- en: Here are some reporting-focused do’s and don’ts.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于报告的注意事项。
- en: Be Careful with Aggregations
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小心聚合
- en: When it comes to aggregations, proceed with extreme caution. You could report
    the result of a benchmark by saying something like “I ran this benchmark for three
    days, and this is my throughput.” However, this overlooks a lot of critical information.
    For example, consider the two graphs presented in Figures [9-6](#Fig6) and [9-7](#Fig7).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行聚合时，请极端小心。你可以通过说“我进行了为期三天的基准测试，这是我的吞吐量。”来报告基准测试的结果。然而，这忽略了大量关键信息。例如，考虑图[9-6](#Fig6)和[9-7](#Fig7)中展示的两个图表。
- en: '![](../images/541783_1_En_9_Chapter/541783_1_En_9_Fig7_HTML.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图9-6](../images/541783_1_En_9_Chapter/541783_1_En_9_Fig7_HTML.jpg)'
- en: A graph titled, Requests served. A line rises sharply, drops slightly, remains
    bumpier for a longer duration, and finally drops sharply.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个标题为“请求处理”的图表。一条线急剧上升，略微下降，在较长时间内保持更加颠簸，最后急剧下降。
- en: Figure 9-7
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-7
- en: A bumpier path to a similar throughput at the end
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到达相似吞吐量的道路更加颠簸
- en: '![](../images/541783_1_En_9_Chapter/541783_1_En_9_Fig6_HTML.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图9-6](../images/541783_1_En_9_Chapter/541783_1_En_9_Fig6_HTML.jpg)'
- en: A graph titled, Requests served. A line rises sharply, drops slightly, remains
    flat for a longer duration, and finally drops sharply.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个标题为“请求处理”的图表。一条线急剧上升，略微下降，在较长时间内保持平坦，最后急剧下降。
- en: Figure 9-6
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-6
- en: Lower baseline throughput that’s almost constant and predictable throughout
    a ten-minute period
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在十分钟期间几乎恒定且可预测的较低基线吞吐量
- en: Both of these loads have roughly the same throughput at the end. Figure [9-6](#Fig6)
    shows lower baseline throughput—but it’s constant and very predictable throughout
    the period. The OPS in Figure [9-7](#Fig7) dip much lower than the first baseline,
    but it also spikes to a much higher value. The behavior shown in Figure [9-6](#Fig6)
    is obviously more desirable. But if you aggregate your results, it would be really
    hard to notice a difference.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种负载在最后都大致具有相同的吞吐量。图[9-6](#Fig6)显示了较低的基线吞吐量——但在整个期间都是恒定且非常可预测的。图[9-7](#Fig7)中的OPS比第一个基线低得多，但它也急剧上升到更高的值。图[9-6](#Fig6)中显示的行为显然更可取。但如果你聚合你的结果，就很难注意到差异。
- en: 'Another aggregation mistake is aggregating tail latencies: taking the average
    of P99 latencies from multiple load generators. The correct way to determine the
    percentiles over multiple load generators is to merge the latency distribution
    of each load generator and then determine the percentiles. If that isn’t an option,
    then the next best alternative is to take the maximum (the P99, for example) of
    each of the load generators. The actual P99 will be equal to or smaller than the
    maximum P99.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个聚合错误是聚合尾部延迟：从多个负载生成器中取P99延迟的平均值。确定多个负载生成器百分位数的方法是合并每个负载生成器的延迟分布，然后确定百分位数。如果这不是一个选项，那么下一个最好的选择是取每个负载生成器的最大值（例如P99）。实际的P99将等于或小于最大P99。
- en: 'For example, assume you have the following clients:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您有以下客户端：
- en: 'Client1: 100 total requests: 98 of them took 1ms, 2 took 3ms'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端1：100个总请求：其中98个花费了1ms，2个花费了3ms
- en: 'Client2: 100 total requests: 99 of them took 30ms, 1 took 31ms'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端2：100个总请求：其中99个花费了30ms，1个花费了31ms
- en: The 99th percentile in the first example is 3 milliseconds. The 99th percentile
    for the second client is 30 milliseconds. Average that out, and you get 16.5 milliseconds.
    However, the true 99th percentile is acquired by putting those two arrays together
    and taking the 99th percentile from there. The actual 99th percentile was 30 milliseconds.
    That 16.5 millisecond “average” is meaningless—it doesn’t correlate to anything
    in reality.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，第99百分位数是3毫秒。第二个客户端的第99百分位数是30毫秒。平均一下，得到16.5毫秒。然而，真正的第99百分位数是通过将这两个数组合并，然后从中获取第99百分位数来获得的。实际的第99百分位数是30毫秒。那个16.5毫秒的“平均值”是没有意义的——它与现实中的任何事物都不相关。
- en: Also, do not blindly trust only your application latencies. In general, when
    evaluating benchmarking results, be sure to consult your database-reported latencies
    to rule out bottlenecks related to the database itself. Situations where the database
    latencies are within your specific thresholds, but the client-side results deviate
    from your expected numbers are fairly common—and may indicate a problem on either
    the network or at the client side.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，也不要盲目地只相信你的应用程序延迟。一般来说，在评估基准测试结果时，务必咨询数据库报告的延迟，以排除与数据库本身相关的瓶颈。数据库延迟在您特定的阈值内，但客户端结果偏离您预期的情况相当常见——这可能会表明网络或客户端存在问题。
- en: Don’t Assume People Will Believe You
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要假设人们会相信你
- en: Assume that any claim you make will be met with a healthy dose of skepticism.
    One of the best ways to combat this is to share fine granularity details about
    your setup. Just reporting something like “Our cluster has a P99 which is lower
    than 1ms” is not sufficient.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您提出的任何主张都会遇到一大堆怀疑。对抗这种怀疑的最好方法之一是分享您设置的精细粒度细节。仅仅报告“我们的集群P99低于1ms”是不够的。
- en: 'A better statement is: “We set up three cluster nodes with 3x i3.4xlarge (16vCPU,
    122GiB RAM, up to 10Gbps network, 2x1.9TB NVMe). For loaders, we used 3x c5n.9xlarge
    (36vCPU, 96GiB RAM, up to 50Gbps network). Here’s the graph of our P99 over time.
    Here’s the benchmarking profile used to stress the given workload.”'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的说法是：“我们设置了三个集群节点，每个节点有3x i3.4xlarge（16vCPU，122GiB RAM，最高10Gbps网络，2x1.9TB
    NVMe）。对于加载器，我们使用了3x c5n.9xlarge（36vCPU，96GiB RAM，最高50Gbps网络）。这是我们的P99随时间变化的图表。这是用来压力测试给定工作负载的基准测试配置文件。”
- en: 'Also, provide enough detail so that the benchmark can be repeated. For example,
    for a Cassandra benchmark, consider including details such as:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，提供足够的细节，以便可以重复基准测试。例如，对于Cassandra基准测试，考虑包括以下细节：
- en: JVM settings
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM设置
- en: Any non-default settings used in `cassandra.yaml`
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`cassandra.yaml`中使用的任何非默认设置
- en: Cassandra-stress parameters (driver version, replication factor, compaction
    strategy, etc.)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cassandra-stress参数（驱动程序版本、复制因子、压缩策略等）
- en: Exactly how you inserted data, warmed up the cache, and so on
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您确切地如何插入数据、预热缓存等等
- en: Finally, keep in mind that the richer your reports, the easier it is for someone
    to support your recommendation that option A is preferable to option B. For example,
    if you’re looking into how two different databases compare on the same hardware,
    you might share details in Table [9-1](#Tab1) in addition to the standard throughput
    and latency graphs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，您的报告越丰富，就越容易让某人支持您的建议，即选项A比选项B更可取。例如，如果您正在研究两个不同的数据库在同一硬件上的比较，您除了标准的吞吐量和延迟图外，还可能分享表[9-1](#Tab1)中的细节。
- en: Table 9-1
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 表9-1
- en: Communicating the Results of Comparing Two Different Databases on the Same Hardware
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同硬件上比较两个不同数据库的结果的沟通
- en: '| Test | Database A | Database B | Difference | Better Is: |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 测试 | 数据库 A | 数据库 B | 差异 | 较好的是： |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Time to populate | 5h 21m 29s | 4h 27m 19s | 20% | Lower |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 填充时间 | 5h 21m 29s | 4h 27m 19s | 20% | 较低 |'
- en: '| Time to compact | 7h 32m | 21m | 21x | Lower |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 压缩时间 | 7h 32m | 21m | 21x | 较低 |'
- en: '| Total quiesce time (populate and compact) | 12h 43m | 4h 48m | 2.68x | Lower
    |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 总空闲时间（填充和压缩） | 12h 43m | 4h 48m | 2.68x | 较低 |'
- en: '| Read throughput(small dataset) | 51,267 reads/second | 124,958 reads/second
    | 2.43x | Higher |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 读取吞吐量（小数据集） | 51,267 次/秒 | 124,958 次/秒 | 2.43x | 较高 |'
- en: '| Read throughput(medium dataset) | 7,363 reads/second | 6,958 reads/second
    | -5% | Higher |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 读取吞吐量（中等数据集） | 7,363 次/秒 | 6,958 次/秒 | -5% | 较高 |'
- en: '| Read throughput(large dataset) | 5,089 reads/second | 5,592 reads/second
    | 9.8% | Higher |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 读取吞吐量（大数据集） | 5,089 次/秒 | 5,592 次/秒 | 9.8% | 较高 |'
- en: '| Reads during writes | 547 reads/second | 920 reads/second | 68% | Higher
    |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 写入时的读取量 | 547 次/秒 | 920 次/秒 | 68% | 较高 |'
- en: '| 99.9th latency(at 5,000 writes/second) | 130.3 milliseconds | 11.9 milliseconds
    | 10.9x | Lower |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 99.9% 延迟（在 5,000 次/秒写入时） | 130.3 毫秒 | 11.9 毫秒 | 10.9x | 较低 |'
- en: '| 99.9th latency(at 10,000 writes/second) | 153.3 milliseconds | 16.9 milliseconds
    | 9.0x | Lower |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 99.9% 延迟（在 10,000 次/秒写入时） | 153.3 毫秒 | 16.9 毫秒 | 9.0x | 较低 |'
- en: Take Coordinated Omission Into Account
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 考虑协调遗漏
- en: A common problem when measuring latencies is the *coordinated omission* problem,
    which causes the worst latencies to be omitted from the measurements and, as a
    consequence, renders the higher percentiles useless.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 测量延迟时常见的常见问题是协调遗漏问题，这会导致最差的延迟被遗漏在测量中，因此使得较高的百分位数变得无用。
- en: Gil Tene coined this term to describe what happens when a measuring system inadvertently
    coordinates with the system being measured in a way that avoids measuring outliers
    and misses sending requests.^([9](#Fn9))
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Gil Tene 提出了这个术语来描述当测量系统无意中以一种避免测量异常值并遗漏发送请求的方式与被测系统协调时发生的情况.^([9](#Fn9))
- en: Here’s a great analogy by Ivan Prisyazhynyy:^([10](#Fn10))
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个由 Ivan Prisyazhynyy 提出的绝佳类比:^([10](#Fn10))
- en: “Let’s imagine a coffee-fueled office. Each hour a worker has to make a coffee
    run to the local coffee shop. But what if there’s a road closure in the middle
    of the day? You have to wait a few hours to go on that run. Not only is that hour’s
    particular coffee runner late, but all the other coffee runs get backed up for
    hours behind that. Sure, it takes the same amount of time to get the coffee once
    the road finally opens, but if you don’t measure that gap caused by the road closure,
    you’re missing measuring the total delay in getting your team their coffee. And,
    of course, in the meanwhile you will be woefully undercaffeinated.”
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: “让我们想象一个由咖啡驱动的办公室。每个小时，一个员工都要去当地的咖啡店买咖啡。但假设白天中间有道路封闭？你不得不等几个小时才能去那跑一趟。这不仅使那个小时的特定咖啡跑者迟到，而且所有其他的咖啡跑都要在后面排几个小时。当然，一旦道路最终开通，拿咖啡所需的时间是一样的，但如果你不测量由道路封闭造成的差距，你就是在遗漏测量获取团队咖啡的总延迟。而且，当然，在此期间，你将严重缺咖啡。”
- en: 'Prisyazhynyy notes that most standard benchmarking tools now account for coordinated
    omission (e.g., cassandra-stress and YCSB do; TLP-stress did not at the time of
    writing). However, by default, they do not *respect* coordinated omissions, so
    anyone using these tools still needs to be vigilant about spotting and combatting
    coordinated omission. We strongly recommend reading his complete article. But,
    for brevity’s sake, here’s his conclusion:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Prisyazhynyy 指出，现在大多数标准基准测试工具现在都考虑了协调遗漏（例如，cassandra-stress 和 YCSB 都考虑了；TLP-stress
    在写作时没有考虑）。然而，默认情况下，它们并不 *尊重* 协调遗漏，因此使用这些工具的人仍然需要警惕发现和对抗协调遗漏。我们强烈建议阅读他的完整文章。但为了简洁起见，这里是他结论的摘要：
- en: '“We found that the best implementation involves a static schedule with queueing
    and latency correction, and we showed how those approaches can be combined together
    to effectively solve coordinated omission issues: queueing with correction or
    simulation, or queueless with simulation.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: “我们发现最佳实现涉及静态调度、排队和延迟校正，我们展示了如何将这些方法结合起来有效地解决协调遗漏问题：带有校正的排队或模拟，或者无排队加模拟。
- en: 'To mitigate coordinated omission effects, you must:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻协调遗漏效应，你必须：
- en: Explicitly set the throughput target, the number of worker threads, the total
    number of requests to send, or the total test duration
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确设置吞吐量目标、工作线程数量、要发送的总请求数量或总测试持续时间
- en: Explicitly set the mode of latency measurement
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确设置延迟测量模式
- en: Correct for queueing implementations
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修正排队实现
- en: Simulate non-queuing implementations
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟非排队实现
- en: 'For example, for YCSB the correct flags are:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于YCSB，正确的标志是：
- en: '`-target 120000 -threads 840 -p recordcount=1000000000 -p measurement.interval=both`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-target 120000 -threads 840 -p recordcount=1000000000 -p measurement.interval=both`'
- en: 'For cassandra-stress, they are:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于cassandra-stress，它们是：
- en: '`duration=3600s -rate fixed=100000/s threads=840”`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`duration=3600s -rate fixed=100000/s threads=840`'
- en: Beyond these tips, there are even more parameters that impact coordinated omissions.
    We strongly recommend that you seek recommendations from your vendor, Stack Overflow,
    or other community resources.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些提示之外，还有更多影响协调遗漏的参数。我们强烈建议你寻求供应商、Stack Overflow或其他社区资源的建议。
- en: Special Considerations for Various Benchmarking Goals
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 针对各种基准测试目标的特殊考虑
- en: Many database benchmarks are performed primarily so the team can check a “due
    diligence” box in the selection process. Since you’re now pretty deep into a book
    focused on database performance, we assume that’s not *your* team. You have some
    lofty performance goals and you know that benchmarking is key to achieving them.
    So what exactly are you hoping to achieve with your latest and greatest benchmark?
    Here are some common reasons and use cases, as well as tips and caveats for each.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数据库基准测试主要是为了让团队在选择过程中勾选一个“尽职调查”的框。既然你现在已经深入到一本专注于数据库性能的书中，我们假设那不是你的团队。你有一些宏伟的性能目标，你知道基准测试是实现这些目标的关键。那么，你希望通过最新的基准测试实现什么？以下是一些常见的原因和用例，以及每个用例的技巧和注意事项。
- en: Preparing for Growth
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为增长做准备
- en: You just learned that your application is expected to handle increased traffic—perhaps
    as a result of a merger/acquisition, from some unexpected publicity or market
    movement, or just the slow and steady accumulation of more users over time. Is
    your database up to the task? You may want to test how your database scales under
    pressure. How long does it take to add more resources? What about scaling it up?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚了解到你的应用程序预计将处理增加的流量——可能是由于合并/收购、一些意外的宣传或市场变动，或者只是随着时间的推移缓慢而稳定地积累更多用户。你的数据库能否胜任这项任务？你可能想测试你的数据库在压力下的扩展性。添加更多资源需要多长时间？升级扩展呢？
- en: Comparing Different Databases
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较不同的数据库
- en: Maybe you have the luxury of architecting an application with “the best” database
    from the ground up. Maybe you’ve hit the wall with your existing database and
    need to justify a potentially painful and costly migration. Or maybe you’re curious
    if it’s worth it to move across your existing database vendor’s various offerings.
    It’s critical to know how each database is built and understand both how to test
    its strengths as well as how to assess the true impact of its constraints.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你有幸从头开始设计一个使用“最佳”数据库的应用程序。也许你遇到了现有数据库的瓶颈，需要证明可能痛苦且昂贵的迁移是合理的。或者，你可能好奇迁移到现有数据库供应商的各种产品是否值得。了解每个数据库是如何构建的，以及如何测试其优势以及评估其限制的真正影响是至关重要的。
- en: Comparing the Same Database on Different Infrastructure
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在不同基础设施上比较相同的数据库
- en: Your preferred cloud vendor just released a shiny new series of instances with
    the potential for great power. But will you see any impact given your database
    and your workloads? Could vertical scaling reduce the size of your clusters (and
    the scope of your maintenance headaches)?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你偏好的云供应商刚刚发布了一系列具有巨大潜力的新实例。但是，考虑到你的数据库和你的工作负载，你会看到任何影响吗？垂直扩展能否减少你的集群大小（以及你的维护头痛的范围）？
- en: Pay attention to any configuration changes that might be needed (and sometimes
    unintended!) between both infrastructure settings. Recognize that some level of
    tuning will inevitably be required to ensure you get the maximum out of each.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在基础设施设置之间可能需要的任何配置更改（有时可能是意外的！）以确保你从每个设置中获得最大效果。
- en: Also keep in mind that some databases have limits as to how far they can scale.
    Some databases will be more efficient if you horizontally scale using smaller
    nodes. Others will excel when they’re run on larger capacity nodes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，一些数据库在可扩展性方面有局限性。如果你使用较小的节点进行横向扩展，某些数据库将更加高效。而其他数据库在运行在更大容量节点上时将表现出色。
- en: Finally, consider the application latency. In some cases, you can “bring” a
    testing application with you to the same cloud environment and reproduce it as
    if it were a local datacenter in order to reduce network RTT. In other cases,
    you might need to account for network latency on top of the results you received.
    If the application is in a separate environment, that can contribute to additional
    latency toward the database.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑应用延迟。在某些情况下，你可以“携带”一个测试应用到同一个云环境中，并像在本地数据中心一样重新生成它，以减少网络RTT。在其他情况下，你可能需要考虑在收到的结果之上加上网络延迟。如果应用在单独的环境中，这可能会对数据库造成额外的延迟。
- en: Assessing the Impact of a Data Modeling or Database Configuration Change
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评估数据建模或数据库配置更改的影响
- en: Say you just started reworking your data model and want to “unit test” it to
    check if you’re going down the right path. Your team is debating among different
    options and wants an objective assessment of how much they will optimize—or undermine—your
    performance.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你刚刚开始重构你的数据模型，并想要对其进行“单元测试”以检查你是否走在了正确的道路上。你的团队正在就不同的选项进行辩论，并希望有一个客观的评估，看看他们将会优化还是削弱你的性能。
- en: In this case, you have to consider a multitude of aspects. For instance, while
    assessing the impact of encryption-in-transit on your workload, you might collect
    the initial tests while the database was running with a hot cache. Then, after
    applying the necessary changes, you restart your database and get higher latencies
    as a result. You might think, “Oh no! The encryption setting is really hurting
    my latency!” But, you forgot that restarting the cluster to apply the change also
    cleared the cache—and upon restarting your tests, you’re basically reading from
    disk. In the end, after warming up the cache, you notice the encryption option
    barely impacted your latency. Whew!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你必须考虑众多方面。例如，在评估传输中加密对你的工作负载的影响时，你可能会收集数据库在运行热缓存时的初始测试。然后，在应用必要的更改后，你重新启动数据库，结果延迟更高。你可能会想，“哦不！加密设置真的伤害了我的延迟！”但，你忘记了重启集群以应用更改也清除了缓存——在你重新启动测试时，你基本上是从磁盘读取的。最终，在缓存预热后，你注意到加密选项几乎对你的延迟没有影响。呼！
- en: Beyond the Usual Benchmark
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超出常规基准测试
- en: Considering that you’re now many chapters deep into this book, you’re clearly
    quite obsessed. Perhaps you want to put your database to some less common or more
    extreme tests? Here are a few options.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到你现在已经深入到这本书的许多章节，你显然非常着迷。也许你想对你的数据库进行一些不太常见或更极端的测试？这里有一些选项。
- en: Benchmarking Admin Operations
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基准测试管理操作
- en: Even if you don’t anticipate expanding capacity often or dramatically, checking
    how long it takes to add a new node or increase your cluster capacity certainly
    falls under the realm of “due diligence.” And if you do expect sudden and significant
    increases, it’s a good idea to test something more extreme—like how rapidly you
    can double capacity.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不经常或大幅度地预期扩展容量，检查添加新节点或增加集群容量所需的时间当然属于“尽职调查”的范畴。如果你确实预期会有突然和显著的增加，测试一些更极端的东西——比如你多快能加倍容量。
- en: Keep in mind that databases must stream data into new nodes, and that this will
    consume some CPU time, along with disk I/O and networking bandwidth—so it’s important
    to assess this in a safe and controlled environment.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，数据库必须将数据流式传输到新节点，这将消耗一些CPU时间，以及磁盘I/O和网络带宽——因此，在安全且受控的环境中评估这一点很重要。
- en: Other admin operations you might want to benchmark include the time required
    to replace nodes as well as the latency impacts of compaction and other background
    operations. For example, in Cassandra or ScyllaDB, you might look into how repair
    operations running in the background impact the live workload. If you notice that
    the operation causes latency increases, you might be able to schedule a time window
    to run repairs weekly or run them with a lower intensity.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想基准测试的其他管理操作包括替换节点所需的时间以及压缩和其他后台操作对延迟的影响。例如，在Cassandra或ScyllaDB中，你可能想了解后台运行的修复操作如何影响实时工作负载。如果你注意到操作导致延迟增加，你可能能够安排一个时间窗口来每周运行修复，或者以较低的强度运行它们。
- en: Testing Disaster Recovery
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试灾难恢复
- en: You need to test your ability to sustain regular life events. Nodes will crash.
    Disks will become corrupt. And network cables will be disconnected. That will
    happen for sure—and it could very well be during the worst possible time (e.g.,
    Black Friday or during the big game you’re streaming to millions). You need to
    account for potential disasters and test capacity planning with reduced nodes,
    a network partition, or other undesired events. This has the added benefit of
    teaching you about the true capabilities of the system’s resiliency.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要测试您维持常规生活事件的能力。节点会崩溃。磁盘会损坏。网络电缆会断开。这肯定会发生——而且很可能是在最糟糕的时间（例如，黑色星期五或您正在向数百万观众直播的大型比赛期间）。您需要考虑潜在的灾难，并测试在减少节点、网络分区或其他不希望发生的事件下的容量规划。这还有额外的益处，即让您了解系统的真正恢复能力。
- en: Also, test the time and effort required to restore from a backup. Yes, this
    requires spending a fair bit of time and money on what’s essentially a fire drill.
    But knowing what to expect in a time of crisis is quite valuable—and avoiding
    databases with unacceptable recovery times can be priceless.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，测试从备份中恢复所需的时间和精力。是的，这需要花费相当多的时间和金钱进行本质上是一场消防演习。但了解危机时刻可以期待什么是非常有价值的——避免具有不可接受的恢复时间的数据库可能是无价的。
- en: If you’re running on the cloud, you might think you’re safe from disaster. “I’ll
    just spin up another cluster and move forward. Right?” Wrong! Apart from the data
    migration itself, there are a ton of other things that can go wrong. You’ll need
    to reconnect all network VPCs, redo all the networking configuration between the
    application and database, and so on. You may also run out of instances of the
    desired type in a given region or availability zone. Did you ever go to the supermarket
    to buy a basic item, say toilet paper, and find empty shelves because everybody
    suddenly started filling their carts with it (e.g., due to a disaster)? This can
    happen to anything, even virtual instances. It’s best to test disaster scenarios
    to gain a better understanding of what issues you could experience—and practice
    how you’ll react.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在云上运行，您可能会认为您可以免受灾难的侵害。“我只是再启动另一个集群，继续前进。对吧？” 错误！除了数据迁移本身之外，还有许多其他事情可能会出错。您需要重新连接所有网络
    VPC，重新执行应用程序和数据库之间的所有网络配置，等等。您也可能在某个区域或可用区中耗尽所需类型的实例。您是否曾经去过超市购买基本商品，比如卫生纸，却发现货架空了，因为每个人都突然开始填满他们的购物车（例如，由于灾难）？这种情况可能发生在任何事物上，甚至虚拟实例。最好测试灾难场景，以更好地了解您可能会遇到的问题——并练习您将如何反应。
- en: Benchmarking at Extreme Scale
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 极端规模基准测试
- en: Benchmarks performed at petabyte scale can help you understand how a particular
    database handles extremely large workloads that your company expects (or at least
    hopes) to encounter. However, such benchmarks can be challenging to design and
    execute.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在拍字节级进行的基准测试可以帮助您了解特定数据库如何处理公司期望（或至少希望）遇到的极端大型工作负载。然而，这样的基准测试可能具有挑战性，设计和执行起来都相当困难。
- en: 'The ScyllaDB engineering team recently decided to perform a petabyte-scale
    benchmark on a rather short timeline. We constructed a 20-node ScyllaDB cluster
    and loaded it with 1PB (replicated) of user data and 1TB of application data.
    The user workload was ~5 million TPS, and we measured two variants of it: one
    read-only and another with 80 percent reads and 20 percent writes. Since this
    workload simulated online analytics, high throughput was critical. At the same
    time, we ran a smaller 200,000 TPS application workload with 50 percent reads
    and 50 percent writes. Since this workload represented online transaction processing,
    low latency was prioritized over high throughput.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ScyllaDB 工程团队最近决定在相对较短的时间内进行一次拍字节级基准测试。我们构建了一个 20 节点的 ScyllaDB 集群，并加载了 1PB（复制）的用户数据和
    1TB 的应用程序数据。用户工作负载约为 500 万 TPS，我们测量了两种变体：一种是只读的，另一种是 80% 读取和 20% 写入。由于这种工作负载模拟了在线分析，高吞吐量至关重要。同时，我们还运行了一个较小的
    200,000 TPS 应用程序工作负载，其中 50% 读取和 50% 写入。由于这种工作负载代表了在线事务处理，低延迟比高吞吐量更为重要。
- en: 'To give you an idea of what this involved from a setup perspective, we provisioned
    20 x i3en.metal AWS instances for the ScyllaDB cluster. Each instance had:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您了解从设置角度来看这涉及到什么，我们为 ScyllaDB 集群配备了 20 个 i3en.metal AWS 实例。每个实例具有：
- en: 96 vCPUs
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 96 个 vCPU
- en: 768 GiB RAM
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 768 GiB RAM
- en: 60 TB NVMe disk space
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 60 TB NVMe 磁盘空间
- en: 100 Gbps network bandwidth
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 100 Gbps 网络带宽
- en: 'For the load generators, we used 50 x c5n.9xlarge AWS instances. Each instance
    had:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于负载生成器，我们使用了 50 个 c5n.9xlarge AWS 实例。每个实例具有：
- en: 36 vCPUs
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 36 个 vCPU
- en: 96 GiB RAM
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 96 GiB RAM
- en: 50 Gbps network bandwidth
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 50 Gbps 网络带宽
- en: 'If you’re thinking about performing your own extreme-scale benchmark, here
    are some lessons learned that you might want to consider:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在考虑进行自己的极端规模基准测试，以下是一些你可能想要考虑的经验教训：
- en: '**Provisioning**: It took a few days to find an availability zone in AWS that
    had sufficient instance types for a petabyte-scale benchmark. If you plan to deploy
    such a large cluster, make sure to provision your resources well ahead.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：在 AWS 中找到一个具有足够实例类型进行PB级基准测试的可用区域花了一些天。如果你计划部署如此大的集群，请确保提前充分配置你的资源。'
- en: '**Hardware tuning/interrupt handling**: At the time, our default assignment
    of cores to I/O queue handling wasn’t optimized for this extreme scenario. Interrupt
    handling CPUs had to be manually assigned to maximize throughput.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件调优/中断处理**：当时，我们将核心分配给 I/O 队列处理默认设置并未针对这种极端场景进行优化。为了最大化吞吐量，必须手动分配中断处理 CPU。'
- en: '**Hardware tuning/CPU power governor**: We needed to set the CPU power governor
    on each node to “performance” to maximize the performance of the system.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件调优/CPU 功率管理器**：我们需要将每个节点的 CPU 功率管理器设置为“性能”，以最大化系统的性能。'
- en: '**cassandra-stress**: cassandra-stress was not designed for this scale (the
    default population distribution is too small). Be prepared to experiment with
    non-default settings if you’re aiming to create and iterate through a petabyte
    dataset.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cassandra-stress**：cassandra-stress 并未设计用于此规模（默认的人口分布太小）。如果你旨在创建和迭代PB级数据集，请准备好尝试非默认设置。'
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Benchmarking is tedious and painstaking, so make sure that you have clear goals
    and effective reporting to ensure the work pays off. Some of the top tips we shared
    include:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试既繁琐又费力，所以请确保你有明确的目标和有效的报告，以确保工作有所回报。我们分享的一些顶级技巧包括：
- en: Start small so you don’t end up wasting time and money.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从小开始，以免浪费时间和金钱。
- en: Understand your database in order to craft tests that showcase its strengths
    and assess whether you can live with its weaknesses.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解你的数据库，以便制定展示其优势并评估你是否可以容忍其弱点的测试。
- en: Rely on standard tools to start, but be sure to work up to representative data
    models, datasets, and workloads.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依靠标准工具开始，但确保逐步发展到代表性的数据模型、数据集和工作负载。
- en: Get your monitoring stack in shape prior to benchmarking, and use it to benchmark
    strategically (e.g., to exercise your cache realistically).
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基准测试之前，确保你的监控堆栈处于良好状态，并战略性地使用它进行基准测试（例如，以实际测试你的缓存）。
- en: Plan to dedicate a good amount of time to crafting convincing reports and beware
    of challenges such as coordinated omission.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计划投入大量时间来制作令人信服的报告，并警惕如协调遗漏等挑战。
- en: The next chapter dives into best practices for the ongoing monitoring that is
    critical to interpreting many benchmarking results, as well as preventing and
    troubleshooting performance issues in production.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章深入探讨了持续监控的最佳实践，这对于解释许多基准测试结果至关重要，以及在生产中防止和排查性能问题。
- en: '[![Creative Commons](../css/cc-by.png)](https://creativecommons.org/licenses/by/4.0)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[![Creative Commons](../css/cc-by.png)](https://creativecommons.org/licenses/by/4.0)'
- en: '**Open Access** This chapter is licensed under the terms of the Creative Commons
    Attribution 4.0 International License ([http://​creativecommons.​org/​licenses/​by/​4.​0/​](http://creativecommons.org/licenses/by/4.0/)),
    which permits use, sharing, adaptation, distribution and reproduction in any medium
    or format, as long as you give appropriate credit to the original author(s) and
    the source, provide a link to the Creative Commons license and indicate if changes
    were made.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放获取**本章根据 Creative Commons Attribution 4.0 国际许可协议（[http://creativecommons.org/licenses/by/4.0/](http://creativecommons.org/licenses/by/4.0/)）许可，允许在任何媒介或格式中使用、分享、改编、分发和复制，只要您适当引用原始作者和来源，提供
    Creative Commons 许可证的链接，并指出是否进行了更改。'
- en: The images or other third party material in this chapter are included in the
    chapter's Creative Commons license, unless indicated otherwise in a credit line
    to the material. If material is not included in the chapter's Creative Commons
    license and your intended use is not permitted by statutory regulation or exceeds
    the permitted use, you will need to obtain permission directly from the copyright
    holder.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的图像或其他第三方材料包含在本章的 Creative Commons 许可证中，除非在材料引用行中另有说明。如果材料未包含在本章的 Creative
    Commons 许可证中，且你的预期使用未获得法定监管的许可或超出许可的使用范围，你将需要直接从版权持有人处获得许可。
